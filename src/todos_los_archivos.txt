
// app.js

import "dotenv/config";
import flowManager from './modules/flowManager.js';
import whatsappService from './services/whatsappService.js';
import sheetService from './services/sheetService.js';
import logger from './utils/logger.js';
import createMiddleware from './core/middleware.js';
import logMiddleware from './core/log-middleware.js';
import userContextManager from './modules/userContext.js';
import config from './config/config.js';
import { errorHandler } from './utils/errorHandler.js';
import fileValidationService from './services/fileValidationService.js';

const middleware = createMiddleware([logMiddleware]);

const initializeServices = async () => {
  let services = null;
  let additionalInfo = null;

  try {
    await sheetService.initialize();

    services = await sheetService.getServices();
    additionalInfo = await sheetService.getAdditionalInfo();
    
    if (services && additionalInfo) {
      userContextManager.setGlobalData(services, additionalInfo);
      logger.info("Servicios e información adicional inicializados correctamente");
    } else {
      throw new Error("No se pudieron obtener los servicios o la información adicional");
    }
  } catch (error) {
    logger.error(`Error al inicializar servicios: ${error.message}`);
    logger.warn("Iniciando con funcionalidad reducida");
  }

  return { services, additionalInfo };
};

const main = async () => {
  try {
    const { services, additionalInfo } = await initializeServices();

    const flows = await flowManager.initializeFlows();

    flows.forEach(flow => {
      flow.addAction(middleware);
    });

    await whatsappService.initialize(flows);

    logger.info('Bot inicializado correctamente');

    if (services && additionalInfo) {
      logger.info('Bot iniciado con todas las funcionalidades');
    } else {
      logger.warn('Bot iniciado con funcionalidad reducida. Algunas características pueden no estar disponibles.');
    }

    // Configurar actualización periódica de los servicios y la información adicional
    setInterval(async () => {
      try {
        await sheetService.reinitialize();
        const updatedServices = await sheetService.getServices();
        const updatedAdditionalInfo = await sheetService.getAdditionalInfo();
        if (updatedServices && updatedAdditionalInfo) {
          userContextManager.setGlobalData(updatedServices, updatedAdditionalInfo);
          logger.info("Servicios e información adicional actualizados correctamente");
        } else {
          logger.warn("No se pudieron actualizar los servicios o la información adicional");
        }
      } catch (error) {
        logger.error(`Error al actualizar servicios e información adicional: ${error.message}`);
      }
    }, config.servicesUpdateInterval);

  } catch (error) {
    logger.error(`Error crítico al inicializar el bot: ${error.message}`);
    process.exit(1);
  }
};

main().catch(err => {
  logger.error('Error fatal en main:', err);
  process.exit(1);
});

// Manejo de errores no capturados
process.on('uncaughtException', (error) => {
  logger.error(`Uncaught Exception: ${error.message}`);
  // Implementar lógica adicional si es necesario (por ejemplo, reiniciar el bot)
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error(`Unhandled Rejection at: ${promise}, reason: ${reason}`);
  // Implementar lógica adicional si es necesario
});


// commandProcessor.js

import logger from './utils/logger.js';
import userContextManager from './modules/userContext.js';
import orderManager from './modules/orderManager.js';
import openaiService from './services/openaiService.js';
import config from './config/config.js';

class CommandProcessor {
  constructor() {}

  async processCommand(command, userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      switch (command.command) {
        case "LIST_ALL_SERVICES":
          return this.handleListAllServices(ctx, flowDynamic);
        case "SELECT_SERVICE":
          return this.handleSelectService(ctx, flowDynamic, command.service);
        case "SET_MEASURES":
          return this.handleSetMeasures(ctx, flowDynamic, command.width, command.height);
        case "SET_QUANTITY":
          return this.handleSetQuantity(ctx, flowDynamic, command.quantity);
        case "SET_FINISHES":
          return this.handleSetFinishes(userId, command.sellado, command.ojetillos, command.bolsillo);
        case "VALIDATE_FILE_FOR_SERVICE":
          return this.handleValidateFileForService(ctx, flowDynamic);
        case "CONFIRM_ORDER":
          return this.handleConfirmOrder(ctx, flowDynamic, gotoFlow, endFlow);
        case "SERVICE_NOT_FOUND":
          return this.handleServiceNotFound(ctx, flowDynamic, command.service);
        case "MISSING_INFO":
          return this.handleMissingInfo(ctx, flowDynamic, command.missingField);
        case "ERROR":
          return this.handleGeneralError(ctx, flowDynamic, command.message);
        default:
          logger.warn(`Comando desconocido recibido: ${command.command}`);
          return null;
      }
    } catch (error) {
      logger.error(`Error al procesar comando: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error inesperado. Por favor, intenta nuevamente en unos momentos.");
    }
  }

  async handleListAllServices(ctx, flowDynamic) {
    try {
      const allServices = userContextManager.getAllServices();
      let serviceList = "Aquí tienes la lista completa de nuestros servicios:\n\n";
      allServices.forEach(service => {
        serviceList += `- ${service.name} (${service.category})\n`;
      });
      await flowDynamic(serviceList);
    } catch (error) {
      logger.error(`Error al listar todos los servicios: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al obtener la lista de servicios. Por favor, intenta nuevamente.");
    }
  }

  async handleSelectService(ctx, flowDynamic, serviceName) {
    try {
      const result = await orderManager.handleSelectService(ctx.from, serviceName);
      if (result.action === "INVALID_SERVICE") {
        if (result.similarServices.length > 0) {
          await flowDynamic(`Lo siento, no pude encontrar el servicio "${serviceName}". ¿Quizás te refieres a uno de estos? ${result.similarServices.join(', ')}`);
        } else {
          const categories = Object.keys(userContextManager.getGlobalServices());
          await flowDynamic(`Lo siento, no pude encontrar el servicio "${serviceName}". Estas son nuestras categorías disponibles: ${categories.join(', ')}. ¿En cuál estás interesado?`);
        }
      } else {
        const serviceInfo = result.serviceInfo;
        await flowDynamic(`Has seleccionado el servicio: *${serviceName}* de la categoría *${serviceInfo.category}*.`);
        if (['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
          const availableWidths = serviceInfo.availableWidths.map(w => `${w.material}m`).join(', ');
          await flowDynamic(`Por favor, especifica las medidas que necesitas. Anchos disponibles: ${availableWidths}. El alto debe ser mayor a 1 metro.`);
        } else {
          await flowDynamic(`¿Cuántas unidades necesitas?`);
        }
        
        const availableFinishes = [];
        if (serviceInfo.sellado) availableFinishes.push("sellado");
        if (serviceInfo.ojetillos) availableFinishes.push("ojetillos");
        if (serviceInfo.bolsillo) availableFinishes.push("bolsillo");
        
        if (availableFinishes.length > 0) {
          await flowDynamic(`Este servicio tiene las siguientes terminaciones disponibles: ${availableFinishes.join(', ')}. ¿Deseas alguna de estas terminaciones?`);
        } else {
          await flowDynamic(`Este servicio no tiene terminaciones disponibles.`);
        }
      }
    } catch (error) {
      logger.error(`Error al manejar la selección de servicio: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al procesar tu selección. Por favor, intenta nuevamente.");
    }
  }

  async handleSetMeasures(ctx, flowDynamic, width, height) {
    try {
      const result = await orderManager.handleSetMeasures(ctx.from, width, height);
      await flowDynamic(`Medidas registradas: *${result.order.measures.width}m de ancho x ${result.order.measures.height}m de alto*. ¿Cuántas unidades necesitas?`);
    } catch (error) {
      logger.error(`Error al manejar las medidas: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al registrar las medidas. Por favor, asegúrate de proporcionar medidas válidas e intenta nuevamente.");
    }
  }

  async handleSetQuantity(ctx, flowDynamic, quantity) {
    try {
      const result = await orderManager.handleSetQuantity(ctx.from, quantity);
      await flowDynamic(`Cantidad registrada: *${result.order.quantity} unidades*. ¿Necesitas algún acabado especial?`);
    } catch (error) {
      logger.error(`Error al manejar la cantidad: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al registrar la cantidad. Por favor, asegúrate de proporcionar un número válido e intenta nuevamente.");
    }
  }

  async handleSetFinishes(userId, sellado, ojetillos, bolsillo) {
    try {
      const result = await orderManager.setFinishes(userId, sellado, ojetillos, bolsillo);
      return result;
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      throw error;
    }
  }

  async handleValidateFile(ctx, flowDynamic, command) {
    try {
      const result = await orderManager.handleValidateFile(ctx.from, command.isValid, command.reason);
      if (result.order.fileAnalysis.isValid) {
        await flowDynamic("*Archivo validado correctamente.* ✅ Voy a preparar un resumen de tu cotización.");
      } else {
        await flowDynamic(`*El archivo no cumple con los requisitos:* ❌\n${result.order.fileAnalysis.reason}\nPor favor, envía un nuevo archivo que cumpla con las especificaciones.`);
      }
    } catch (error) {
      logger.error(`Error al validar el archivo: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al validar tu archivo. Por favor, intenta enviarlo nuevamente.");
    }
  }

  async handleValidateFileForService(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);
    const fileAnalysis = currentOrder.fileAnalysis;

    if (!fileAnalysis) {
      await flowDynamic("Lo siento, parece que no hay un archivo para validar. Por favor, envía un archivo primero.");
      return;
    }

    if (currentOrder.fileAnalysisHandled) {
      logger.info(`Análisis de archivo ya manejado para usuario ${userId}. Ignorando solicitud duplicada.`);
      return;
    }

    let response = "He analizado tu archivo. Aquí están los resultados:\n\n";
    response += `📄 Formato: ${fileAnalysis.format}\n`;
    response += `📏 Dimensiones: ${fileAnalysis.width}x${fileAnalysis.height}\n`;
    response += `🔍 Resolución: ${fileAnalysis.dpi} DPI\n`;
    if (fileAnalysis.colorSpace) {
      response += `🎨 Espacio de color: ${fileAnalysis.colorSpace}\n`;
    }

    if (!currentOrder.service) {
      response += "\nPara determinar si este archivo es adecuado para tu proyecto, necesito saber qué servicio específico estás buscando. ¿Podrías decirme qué tipo de impresión necesitas realizar?";
    } else {
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);
      if (!currentOrder.measures && ['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        response += `\nYa tenemos seleccionado el servicio ${currentOrder.service}. Para validar completamente el archivo, necesito que me proporciones las medidas que necesitas. ¿Podrías indicarme el ancho y alto requeridos?`;
      } else {
        response += "\nCon esta información, puedo determinar si el archivo es adecuado para tu proyecto. ¿Necesitas que revise algo más específico del archivo?";
      }
    }

    await flowDynamic(response);
    userContextManager.updateFileAnalysisResponded(userId, true);
    userContextManager.updateFileAnalysisHandled(userId, true);
    logger.info(`Análisis de archivo manejado y respuesta enviada para usuario ${userId}`);
  }

  async handleConfirmOrder(ctx, flowDynamic, gotoFlow, endFlow) {
    try {
      const { summary, result } = await orderManager.handleConfirmOrder(ctx.from);
      await flowDynamic(summary);
      await flowDynamic(result.message);
      logger.info(`Cotización confirmada para ${ctx.from}. Finalizando flujo.`);
      
      setTimeout(() => {
        gotoFlow('promoFlow');
      }, config.promoMessageDelay);
      
      return endFlow();
    } catch (error) {
      logger.error(`Error al finalizar la cotización para ${ctx.from}: ${error.message}`);
      await flowDynamic("Lo siento, ha ocurrido un error al procesar tu cotización. Por favor, intenta nuevamente o contacta con nuestro equipo de soporte.");
    }
  }

  async handleServiceNotFound(ctx, flowDynamic, serviceName) {
    await flowDynamic(`Lo siento, no pude encontrar información sobre el servicio "${serviceName}". ¿Podrías verificar el nombre del servicio o elegir uno de nuestra lista de servicios disponibles?`);
  }

  async handleMissingInfo(ctx, flowDynamic, missingField) {
    await flowDynamic(`Parece que falta información importante para completar tu pedido. Específicamente, necesito saber más sobre: ${missingField}. ¿Podrías proporcionarme esa información?`);
  }

  async handleGeneralError(ctx, flowDynamic, errorMessage) {
    await flowDynamic(`Lo siento, ha ocurrido un error inesperado: ${errorMessage}. Estamos trabajando para resolverlo. Por favor, intenta nuevamente en unos momentos o contacta a nuestro soporte si el problema persiste.`);
  }
}

export default new CommandProcessor();


// config\config.js

// config/config.js

import dotenv from 'dotenv';
import { CustomError } from '../utils/errorHandler.js';

dotenv.config();

const requiredEnvVars = [
  'PORT',
  'GOOGLE_SHEET_ID',
  'OPENAI_API_KEY',
  'GOOGLE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_PRIVATE_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable: ${envVar}`);
  }
}

export default {
  port: process.env.PORT,
  googleSheetId: process.env.GOOGLE_SHEET_ID,
  openaiApiKey: process.env.OPENAI_API_KEY,
  googleServiceAccountEmail: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
  googlePrivateKey: process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  blacklistDuration: parseInt(process.env.BLACKLIST_DURATION) || 10 * 60 * 1000,
  humanBlacklistDuration: parseInt(process.env.HUMAN_BLACKLIST_DURATION) || 60 * 60 * 1000,
  abuseBlacklistDuration: parseInt(process.env.ABUSE_BLACKLIST_DURATION) || 24 * 60 * 60 * 1000,
  idleWarningTime: parseInt(process.env.IDLE_WARNING_TIME) || 5 * 60 * 1000,
  idleTimeoutTime: parseInt(process.env.IDLE_TIMEOUT_TIME) || 10 * 60 * 1000,
  maxAudioSize: parseInt(process.env.MAX_AUDIO_SIZE) || 5 * 1024 * 1024,
  languageModel: process.env.LANGUAGE_MODEL || 'gpt-4o-mini',
  timezone: process.env.TIMEZONE || 'America/Santiago',
  logLevel: process.env.LOG_LEVEL || 'info',
  maxTokens: parseInt(process.env.MAX_TOKENS) || 2000,
  temperature: parseFloat(process.env.TEMPERATURE) || 0.5,
  messageQueueGapSeconds: parseInt(process.env.MESSAGE_QUEUE_GAP_SECONDS) || 3000,
  promoMessageDelay: parseInt(process.env.PROMO_MESSAGE_DELAY) || 15000,
  servicesUpdateInterval: parseInt(process.env.SERVICES_UPDATE_INTERVAL) || 60 * 60 * 1000,
};


// core\blacklist-middleware.js

// core/blacklist-middleware.js

import logger from '../utils/logger.js';

const blacklistMiddleware = (flowManager) => async (ctx, { endFlow }) => {
  const userId = ctx.from;

  if (flowManager.isBlacklisted(userId)) {
    logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
    return endFlow();
  }

  return false; // Continuar con el flujo normal
};

export default blacklistMiddleware;


// core\inactivity-middleware.js

// core/inactivity-middleware.js

import logger from '../utils/logger.js';
import config from '../config/config.js';

const inactivityMiddleware = (flowManager) => async (ctx, { flowDynamic, gotoFlow }) => {
  const userId = ctx.from;

  flowManager.clearIdleTimer(userId);
  
  const warningTimer = setTimeout(async () => {
    await flowDynamic('*⏰ ¿Sigues ahí? Si necesitas más tiempo, por favor responde cualquier mensaje.*');
  }, config.idleWarningTime);

  const timeoutTimer = setTimeout(() => {
    flowManager.resetConversation(userId);
    gotoFlow(flowManager.getIdleTimeoutFlow());
  }, config.idleTimeoutTime);

  flowManager.setIdleTimers(userId, { warningTimer, timeoutTimer });

  return false; // Continuar con el flujo normal
};

export default inactivityMiddleware;


// core\log-middleware.js

import logger from '../utils/logger.js';

const logMiddleware = async (ctx) => {
  const { from, body } = ctx;
  logger.info(`Mensaje recibido de ${from}: ${body}`);
  return false; // Continuar con el flujo normal
};

export default logMiddleware;


// core\middleware.js

// core/middleware.js

import logger from '../utils/logger.js';

const createMiddleware = (middlewares) => {
  return async (ctx, { flowDynamic, endFlow }) => {
    for (const middleware of middlewares) {
      try {
        const result = await middleware(ctx, { flowDynamic, endFlow });
        if (result === true) {
          return true; // Middleware ha manejado la solicitud, detener el flujo
        }
      } catch (error) {
        logger.error(`Error en middleware: ${error.message}`);
        await flowDynamic('Lo siento, ha ocurrido un error. Por favor, inténtalo de nuevo más tarde.');
        return endFlow();
      }
    }
    return false; // Continuar con el flujo normal
  };
};

export default createMiddleware;



// modules\flowManager.js

import { addKeyword, EVENTS } from '@builderbot/bot';
import logger from '../utils/logger.js';
import userContextManager from './userContext.js';
import orderManager from './orderManager.js';
import openaiService from '../services/openaiService.js';
import whatsappService from '../services/whatsappService.js';
import config from '../config/config.js';
import { CustomError } from '../utils/errorHandler.js';
import inactivityMiddleware from '../core/inactivity-middleware.js';
import blacklistMiddleware from '../core/blacklist-middleware.js';
import MessageQueue from './messageQueue.js';
import fileValidationService from '../services/fileValidationService.js';
import commandProcessor from '../commandProcessor.js';

class FlowManager {
  constructor() {
    this.flows = {
      principalFlow: null,
      confirmedFlow: null,
      restartBotFlow: null,
      documentFlow: null,
      voiceNoteFlow: null,
      catchAllFlow: null,
      idleTimeoutFlow: null,
      promoFlow: null
    };
    this.blacklist = new Map();
    this.idleTimers = new Map();
    this.messageQueue = new MessageQueue({ gapSeconds: config.messageQueueGapSeconds });
  }
  async initializeFlows() {
    try {
      this.flows.principalFlow = this.createPrincipalFlow();
      this.flows.confirmedFlow = this.createConfirmedFlow();
      this.flows.restartBotFlow = this.createRestartBotFlow();
      this.flows.documentFlow = this.createDocumentFlow();
      this.flows.voiceNoteFlow = this.createVoiceNoteFlow();
      this.flows.catchAllFlow = this.createCatchAllFlow();
      this.flows.idleTimeoutFlow = this.createIdleTimeoutFlow();
      this.flows.promoFlow = this.createPromoFlow();

      Object.values(this.flows).forEach(flow => {
        if (flow && typeof flow.addAction === 'function') {
          flow.addAction(inactivityMiddleware(this));
          flow.addAction(blacklistMiddleware(this));
        } else {
          logger.warn(`Un flujo no tiene el método addAction o es nulo`);
        }
      });

      logger.info('Flujos inicializados correctamente');
      return Object.values(this.flows).filter(flow => flow !== null);
    } catch (error) {
      logger.error(`Error al inicializar flujos: ${error.message}`);
      throw new CustomError('FlowInitializationError', 'Error al inicializar los flujos', error);
    }
  }


  getFlowByName(name) {
    return this.flows[name];
  }

  createPrincipalFlow() {
    return addKeyword(EVENTS.WELCOME)
      .addAction(async (ctx, { flowDynamic, gotoFlow, endFlow }) => {
        const userId = ctx.from;
        this.enqueueMessage(userId, ctx.body, async (accumulatedMessage) => {
          await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
        });
      });
  }

  createConfirmedFlow() {
    return addKeyword(EVENTS.ACTION)
      .addAction(this.blacklistMiddleware.bind(this))
      .addAction(async (ctx, { flowDynamic, endFlow }) => {
        await flowDynamic("SOLICITUD_HUMANO");
        this.addToBlacklist(ctx.from, config.humanBlacklistDuration);
        logger.info(`Cotización ya confirmada para ${ctx.from}. Redirigiendo a atención humana.`);
        return endFlow("Un representante se pondrá en contacto contigo pronto para finalizar tu cotización. Gracias por tu paciencia.");
      });
  }
  
    createRestartBotFlow() {
      return addKeyword(['bot', 'Bot', 'BOT'])
        .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
          const userId = ctx.from;
          logger.info(`Intento de reinicio de bot por usuario ${userId}`);
          this.resetConversation(userId);
          logger.info(`Bot reiniciado para usuario ${userId}`);
          await flowDynamic('*¡Bienvenido de nuevo!* 🎉 El bot ha sido reiniciado. *¿En qué puedo ayudarte hoy?* 😊');
          return gotoFlow(this.flows.principalFlow);
        });
    }
  
    createDocumentFlow() {
      return addKeyword(EVENTS.DOCUMENT)
        .addAction(async (ctx, { flowDynamic, gotoFlow, endFlow }) => {
          try {
            const filePath = await whatsappService.saveFile(ctx);
            const fileInfo = await fileValidationService.analyzeFile(filePath);
            
            await userContextManager.updateCurrentOrder(ctx.from, {
              filePath: filePath,
              fileAnalysis: fileInfo
            });
            
            logger.info(`Archivo analizado para usuario ${ctx.from}: ${JSON.stringify(fileInfo)}`);
            
            const analysisResponse = this.generateFileAnalysisResponse(fileInfo);
            await flowDynamic(analysisResponse);
            
            this.enqueueMessage(ctx.from, "", async (accumulatedMessage) => {
              await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
            });          
          } catch (error) {
            logger.error(`Error al procesar el archivo: ${error.message}`);
            await flowDynamic('Hubo un error al procesar tu archivo. Por favor, intenta enviarlo nuevamente.');
          }
        });
    }

    createVoiceNoteFlow() {
      return addKeyword(EVENTS.VOICE_NOTE)
        .addAction(async (ctx, { flowDynamic, state, gotoFlow, endFlow }) => {
          try {
            const audioPath = await whatsappService.saveAudioFile(ctx);
            const transcription = await openaiService.transcribeAudio(audioPath);
            logger.info(`Transcripción del audio: ${transcription}`);
            
            await state.update({ lastTranscription: transcription });
            await flowDynamic(`*📝 Transcripción:*\n${transcription}`);
  
            this.enqueueMessage(ctx.from, transcription, async (accumulatedMessage) => {
              await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage, true);
            });
          } catch (error) {
            logger.error(`Error al procesar la nota de voz: ${error.message}`);
            await flowDynamic('Hubo un error al procesar la nota de voz. Por favor, intenta enviar un mensaje de texto.');
          }
        });
    }
  
  
    createCatchAllFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { gotoFlow }) => {
          if (orderManager.isOrderConfirmed(ctx.from)) {
            return gotoFlow(this.flows.confirmedFlow);
          } else {
            return gotoFlow(this.flows.principalFlow);
          }
        });
    }
  
    createIdleTimeoutFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { endFlow }) => {
          logger.info(`Tiempo de espera agotado para usuario ${ctx.from}`);
          this.resetConversation(ctx.from);
          return endFlow('*😴 Lo siento, el tiempo de espera ha expirado. Tu cotización ha sido cancelada. Si deseas hacer una nueva cotización, por favor envía un mensaje.*');
        });
    }
  
    createPromoFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          const promoMessage = whatsappService.getPromoMessage();
          try {
            await flowDynamic(promoMessage);
            logger.info(`Mensaje promocional enviado a ${ctx.from}`);
          } catch (error) {
            logger.error(`Error al enviar mensaje promocional a ${ctx.from}: ${error.message}`);
          }
          return endFlow();
        });
    }
  
    enqueueMessage(userId, message, callback) {
      this.messageQueue.enqueueMessage(userId, message, callback);
    }
  
    async handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, message) {
      const userId = ctx.from;
      logger.info(`Procesando mensaje para usuario ${userId}`);
    
      if (this.isBlacklisted(userId)) {
        logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
    
      if (orderManager.isOrderConfirmed(userId)) {
        logger.info(`Cotización ya confirmada para ${userId}. Redirigiendo a atención humana.`);
        return gotoFlow(this.getFlowByName('confirmedFlow'));
      }
    
      this.startIdleTimer(ctx, flowDynamic, gotoFlow);
    
      try {
        const userContext = userContextManager.getUserContext(userId);
        const chatContext = userContextManager.getChatContext(userId);
        
        const hasRecentFileAnalysis = userContext.currentOrder.fileAnalysis && 
                                      !userContext.currentOrder.fileAnalysisResponded;
    
        if (hasRecentFileAnalysis) {
          logger.info(`Análisis de archivo reciente detectado para usuario ${userId}`);
          if (!userContext.currentOrder.fileAnalysisHandled) {
            logger.info(`Delegando manejo de análisis de archivo a commandProcessor para usuario ${userId}`);
            await commandProcessor.handleValidateFileForService(ctx, flowDynamic);
            userContextManager.updateFileAnalysisHandled(userId, true);
          } else {
            logger.info(`Análisis de archivo ya manejado para usuario ${userId}. Ignorando.`);
          }
          return; // Terminamos aquí para evitar procesamiento adicional
        }
  
        let aiResponse = await openaiService.getChatCompletion(
          openaiService.getSystemPrompt(userContext.services, userContext.currentOrder, userContext.additionalInfo, chatContext),
          [...chatContext, { role: "user", content: message }]
        );
    
        logger.info(`Respuesta AI para ${userId}: ${aiResponse}`);
    
        userContextManager.updateContext(userId, message, "user");
        userContextManager.updateContext(userId, aiResponse, "assistant");
    
        const commands = this.processAIResponse(aiResponse);
        
        for (const command of commands) {
          await commandProcessor.processCommand(command, userId, ctx, { flowDynamic, gotoFlow, endFlow });
        }
    
        if (commands.length === 0 && !hasRecentFileAnalysis) {
          await flowDynamic(aiResponse);
        }
    
        if (userContextManager.isOrderComplete(userId)) {
          return gotoFlow(this.getFlowByName('confirmedFlow'));
        }
    
      } catch (error) {
        logger.error(`Error al procesar respuesta para usuario ${userId}: ${error.message}`);
        logger.error(`Stack trace: ${error.stack}`);
        await flowDynamic("Lo siento, ha ocurrido un error inesperado. Por favor, intenta nuevamente en unos momentos.");
      }
    }
  
    processAIResponse(aiResponse) {
      try {
        const jsonCommands = aiResponse.match(/\{.*?\}/g);
        if (jsonCommands) {
          return jsonCommands.map(jsonCommand => JSON.parse(jsonCommand));
        }
        return [];
      } catch (error) {
        logger.error(`Error al procesar la respuesta de AI: ${error.message}`);
        return [];
      }
    }
  
    generateFileAnalysisResponse(fileInfo) {
      let response = "He analizado tu archivo. Aquí están los resultados:\n\n";
      response += `📄 Formato: ${fileInfo.format}\n`;
      response += `📏 Dimensiones: ${fileInfo.width}x${fileInfo.height}\n`;
      response += `🔍 Resolución: ${fileInfo.dpi} DPI\n`;
      if (fileInfo.colorSpace) {
        response += `🎨 Espacio de color: ${fileInfo.colorSpace}\n`;
      }
      response += "\nPor favor, indícame qué servicio de impresión necesitas y te diré si el archivo es compatible.";
      return response;
    }
  
  
    setIdleTimers(userId, timers) {
      this.idleTimers.set(userId, timers);
    }
  
    addToBlacklist(userId, duration) {
      this.blacklist.set(userId, Date.now() + duration);
      logger.info(`Usuario ${userId} añadido a la lista negra por ${duration/1000} segundos`);
    }
  
    isBlacklisted(userId) {
      if (this.blacklist.has(userId)) {
        const blacklistExpiry = this.blacklist.get(userId);
        if (Date.now() < blacklistExpiry) {
          logger.info(`Usuario ${userId} está en la lista negra. Tiempo restante: ${(blacklistExpiry - Date.now()) / 1000} segundos`);
          return true;
        } else {
          this.blacklist.delete(userId);
          this.resetConversation(userId);
          logger.info(`Usuario ${userId} removido de la lista negra`);
        }
      }
      return false;
    }
  
    resetConversation(userId) {
      userContextManager.resetContext(userId);
      orderManager.resetOrderConfirmation(userId);
      this.blacklist.delete(userId);
      this.clearIdleTimer(userId);
      logger.info(`Conversación reiniciada para usuario ${userId}`);
    }
  
    startIdleTimer(ctx, flowDynamic, gotoFlow) {
      this.clearIdleTimer(ctx.from);
      
      const warningTimer = setTimeout(async () => {
        await flowDynamic('*⏰ ¿Sigues ahí? Si necesitas más tiempo, por favor responde cualquier mensaje.*');
      }, config.idleWarningTime);
  
      const timeoutTimer = setTimeout(() => {
        this.resetConversation(ctx.from);
        gotoFlow(this.getFlowByName('idleTimeoutFlow'));
      }, config.idleTimeoutTime);
  
      this.setIdleTimers(ctx.from, { warningTimer, timeoutTimer });
    }
  
    clearIdleTimer(userId) {
      const timers = this.idleTimers.get(userId);
      if (timers) {
        clearTimeout(timers.warningTimer);
        clearTimeout(timers.timeoutTimer);
        this.idleTimers.delete(userId);
      }
    }
  
    blacklistMiddleware(ctx, { endFlow }) {
      if (this.isBlacklisted(ctx.from)) {
        logger.info(`Usuario ${ctx.from} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
      return false;
    }
  }
  
  export default new FlowManager();


// modules\messageQueue.js

// modules/messageQueue.js

import logger from '../utils/logger.js';

class MessageQueue {
  constructor(config) {
    this.queue = new Map();
    this.config = config;
  }

  enqueueMessage(userId, messageText, callback) {
    logger.info(`Encolando mensaje para usuario ${userId}. Mensaje: ${messageText}`);
    
    if (!this.queue.has(userId)) {
      this.queue.set(userId, { messages: [], timer: null });
      logger.info(`Nueva cola creada para usuario ${userId}`);
    }

    const userQueue = this.queue.get(userId);
    userQueue.messages.push(messageText);

    logger.info(`Mensaje añadido a la cola del usuario ${userId}. Mensajes en cola: ${userQueue.messages.length}`);

    clearTimeout(userQueue.timer);

    userQueue.timer = setTimeout(() => {
      logger.info(`Temporizador expirado para usuario ${userId}. Procesando cola...`);
      const messages = userQueue.messages;
      this.queue.delete(userId);
      logger.info(`Cola procesada y eliminada para usuario ${userId}. Mensajes procesados: ${messages.length}`);
      if (typeof callback === 'function') {
        try {
          callback(messages.join(" "));
        } catch (error) {
          logger.error(`Error en el callback para usuario ${userId}: ${error.message}`);
        }
      }
    }, this.config.gapSeconds);
  }

  clearQueue(userId) {
    if (this.queue.has(userId)) {
      const userQueue = this.queue.get(userId);
      clearTimeout(userQueue.timer);
      this.queue.delete(userId);
      logger.info(`Cola eliminada para usuario ${userId}`);
    }
  }

  getQueueSize(userId) {
    if (this.queue.has(userId)) {
      return this.queue.get(userId).messages.length;
    }
    return 0;
  }

  isQueueEmpty(userId) {
    return this.getQueueSize(userId) === 0;
  }
}

export default MessageQueue;


// modules\orderManager.js

import logger from '../utils/logger.js';
import { formatPrice, censorPhoneNumber } from '../utils/helpers.js';
import moment from 'moment-timezone';
import config from '../config/config.js';
import sheetService from '../services/sheetService.js';
import userContextManager from './userContext.js';
import { CustomError } from '../utils/errorHandler.js';

class OrderManager {
  constructor() {
    this.orderConfirmed = new Set();
  }

  async handleSelectService(userId, serviceName) {
    logger.info(`Manejando selección de servicio para usuario ${userId}: ${serviceName}`);
    try {
      const serviceInfo = userContextManager.getServiceInfo(serviceName);
      
      if (!serviceInfo) {
        const similarServices = userContextManager.findSimilarServices(serviceName);
        return {
          action: "INVALID_SERVICE",
          similarServices,
          order: userContextManager.getCurrentOrder(userId)
        };
      }

      userContextManager.updateCurrentOrder(userId, { 
        service: serviceName,
        category: serviceInfo.category,
        availableWidths: serviceInfo.availableWidths,
        availableFinishes: userContextManager.getAvailableFinishes(serviceInfo)
      });
      
      return {
        action: "SELECT_SERVICE",
        order: userContextManager.getCurrentOrder(userId),
        serviceInfo: serviceInfo
      };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      throw new CustomError('ServiceSelectionError', 'Error al seleccionar el servicio', error);
    }
  }

  async handleSetMeasures(userId, width, height) {
    logger.info(`Manejando configuración de medidas para usuario ${userId}: ${width}x${height}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        throw new CustomError('InvalidMeasuresError', 'Este servicio no requiere medidas personalizadas');
      }

      const validWidth = serviceInfo.availableWidths.find(w => w.material === parseFloat(width));
      if (!validWidth) {
        throw new CustomError('InvalidWidthError', 'Ancho no válido para este servicio');
      }

      if (parseFloat(height) <= 1) {
        throw new CustomError('InvalidHeightError', 'El alto debe ser mayor a 1 metro');
      }

      const measures = { width: validWidth.material, height: parseFloat(height) };
      const { total, area } = this.calculatePrice({ ...currentOrder, measures });

      userContextManager.updateCurrentOrder(userId, { measures, total, area });

      return {
        action: "SET_MEASURES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      throw new CustomError('MeasuresSetupError', 'Error al configurar las medidas', error);
    }
  }

  async handleSetQuantity(userId, quantity) {
    logger.info(`Manejando configuración de cantidad para usuario ${userId}: ${quantity}`);
    try {
      if (quantity <= 0) {
        throw new CustomError('InvalidQuantityError', 'La cantidad debe ser mayor que cero');
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        // Para categorías sin medidas personalizadas, calculamos el precio directamente
        const { total } = this.calculatePrice({ ...currentOrder, quantity });
        userContextManager.updateCurrentOrder(userId, { quantity, total });
      } else {
        userContextManager.updateCurrentOrder(userId, { quantity });
      }

      return {
        action: "SET_QUANTITY",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      throw new CustomError('QuantitySetupError', 'Error al configurar la cantidad', error);
    }
  }

  async setFinishes(userId, sellado, ojetillos, bolsillo) {
    logger.info(`Manejando configuración de acabados para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      const finishes = {
        sellado: sellado && serviceInfo.sellado,
        ojetillos: ojetillos && serviceInfo.ojetillos,
        bolsillo: bolsillo && serviceInfo.bolsillo
      };

      userContextManager.updateCurrentOrder(userId, { finishes: finishes});

      return {
        action: "SET_FINISHES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      throw new CustomError('FinishesSetupError', 'Error al configurar los acabados', error);
    }
  }

  async handleValidateFile(userId, isValid, reason) {
    logger.info(`Manejando validación de archivo para usuario ${userId}`);
    try {
      userContextManager.updateCurrentOrder(userId, {
        fileAnalysis: { isValid, reason }
      });
      
      return {
        action: "VALIDATE_FILE",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al validar archivo para usuario ${userId}: ${error.message}`);
      throw new CustomError('FileValidationError', 'Error al validar el archivo', error);
    }
  }

  async handleConfirmOrder(userId) {
    logger.info(`Manejando confirmación de pedido para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        throw new CustomError('IncompleteOrderError', 'La orden no está completa');
      }

      const total = this.calculatePrice(currentOrder);
      userContextManager.updateCurrentOrder(userId, { total: total });

      const orderSummary = this.formatOrderSummary(currentOrder);
      const result = await this.finalizeOrder(userId, currentOrder);

      this.orderConfirmed.add(userId);

      return {
        action: "CONFIRM_ORDER",
        order: currentOrder,
        summary: orderSummary,
        result: result
      };
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      throw new CustomError('OrderConfirmationError', 'Error al confirmar el pedido', error);
    }
  }

  calculatePrice(order) {
    const serviceInfo = userContextManager.getServiceInfo(order.service);

    let total = 0;
    let area = 0;

    if (['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
      area = order.measures.width * order.measures.height;
      total = area * serviceInfo.precio * order.quantity;

      if (order.finishes.sellado) total += serviceInfo.precioSellado * area;
      if (order.finishes.ojetillos) total += serviceInfo.precioOjetillos * area;
      if (order.finishes.bolsillo) total += serviceInfo.precioBolsillo * area;
    } else {
      total = serviceInfo.precio * order.quantity;

      if (order.finishes.sellado) total += serviceInfo.precioSellado * order.quantity;
      if (order.finishes.ojetillos) total += serviceInfo.precioOjetillos * order.quantity;
      if (order.finishes.bolsillo) total += serviceInfo.precioBolsillo * order.quantity;
    }

    return { total, area };
  }

  formatOrderSummary(order) {
    let summary = "📋 Resumen final de tu cotización:\n\n";

    const serviceInfo = userContextManager.getServiceInfo(order.service);
    summary += `*Servicio:* ${order.service} (${serviceInfo.category})\n`;

    if (order.measures) {
      summary += `*Medidas:* ${order.measures.width}m x ${order.measures.height}m\n`;
    }

    summary += `*Cantidad:* ${order.quantity}\n`;

    if (order.finishes) {
      summary += "*Terminaciones:*\n";
      if (order.finishes.sellado) summary += "- Sellado\n";
      if (order.finishes.ojetillos) summary += "- Ojetillos\n";
      if (order.finishes.bolsillo) summary += "- Bolsillo\n";
    }

    summary += `\n💰 *Total:* $${formatPrice(order.total)}\n`;

    return summary;
  }

  async finalizeOrder(userId, order) {
    logger.info(`Finalizando orden para usuario ${userId}`);
    
    const finalOrder = {
      fecha: moment().tz(config.timezone).format('DD-MM-YYYY HH:mm[hrs] - dddd'),
      telefono: userId,
      nombre: order.userName || 'Cliente',
      pedido: this.formatOrderForSheet(order),
      observaciones: order.observaciones || 'Sin observaciones',
      total: `$${formatPrice(order.total)}`
    };
  
    logger.info(`Orden final para usuario ${userId}: ${JSON.stringify(finalOrder)}`);
  
    try {
      const result = await sheetService.saveOrder(finalOrder);
      logger.info(`Resultado de guardado para usuario ${userId}: ${JSON.stringify(result)}`);

      if (result.success) {
        logger.info(`Cotización finalizada y guardada correctamente para usuario ${userId}`);
        return { 
          success: true,
          message: "Tu cotización ha sido registrada. Un representante se pondrá en contacto contigo pronto para confirmar los detalles y coordinar la entrega de los archivos finales.",
          orderNumber: result.rowIndex
        };
      } else {
        throw new Error("Error al guardar la cotización");
      }
    } catch (error) {
      logger.error(`Error detallado al finalizar la cotización para usuario ${userId}:`, error);
      throw new CustomError('OrderFinalizationError', 'Error al finalizar la cotización', error);
    }
  }


  formatOrderForSheet(order) {
    let details = `Servicio: ${order.service}\n`;
    
    if (order.measures) {
      details += `Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    
    details += `Cantidad: ${order.quantity}\n`;
    
    if (order.finishes) {
      details += "Terminaciones:\n";
      if (order.finishes.sellado) details += "- Sellado\n";
      if (order.finishes.ojetillos) details += "- Ojetillos\n";
      if (order.finishes.bolsillo) details += "- Bolsillo\n";
    }
    
    return details.trim();
  }

  isOrderConfirmed(userId) {
    return this.orderConfirmed.has(userId);
  }

  resetOrderConfirmation(userId) {
    this.orderConfirmed.delete(userId);
  }
}

export default new OrderManager();


// modules\userContext.js

import logger from '../utils/logger.js';
import sheetService from '../services/sheetService.js';

class UserContextManager {
  constructor() {
    this.userContexts = new Map();
  }

  getUserContext(userId) {
    if (!this.userContexts.has(userId)) {
      this.userContexts.set(userId, {
        context: "",
        chatContext: [],
        currentOrder: this.getEmptyOrder(),
        services: this.services,
        additionalInfo: this.additionalInfo
      });
      logger.info(`Nuevo contexto creado para usuario ${userId}`);
    }
    return this.userContexts.get(userId);
  }

  getEmptyOrder() {
    return {
      service: null,
      category: null,
      type: null,
      measures: null,
      finishes: {
        sellado: false,
        ojetillos: false,
        bolsillo: false
      },
      quantity: null,
      filePath: null,
      fileAnalysis: null,
      fileAnalysisResponded: false,
      fileAnalysisHandled: false,
      fileValidation: null,
      availableWidths: [],
      availableFinishes: [],
      price: 0
    };
  }

  updateContext(userId, message, role) {
    const userContext = this.getUserContext(userId);
    userContext.context += `${role}: ${message}\n`;
    userContext.chatContext.push({ role, content: message });
    this.limitContextSize(userId);
    logger.info(`Contexto actualizado para usuario ${userId}. Mensajes en contexto: ${userContext.chatContext.length}`);
  }

  limitContextSize(userId) {
    const userContext = this.getUserContext(userId);
    if (userContext.chatContext.length > 10) {
      userContext.chatContext = userContext.chatContext.slice(-10);
    }
    const words = userContext.context.split(/\s+/);
    if (words.length > 1500) {
      userContext.context = words.slice(-1500).join(" ");
    }
    logger.info(`Contexto limitado para usuario ${userId}`);
  }

  setGlobalData(services, additionalInfo) {
    this.services = services;
    this.additionalInfo = additionalInfo;
    logger.info('Datos globales actualizados en UserContextManager');
    logger.info(`Menú global: ${JSON.stringify(this.services)}`);
    logger.info(`Información adicional global: ${JSON.stringify(this.additionalInfo)}`);
  }

  updateCurrentOrder(userId, updates) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder = { ...userContext.currentOrder, ...updates };
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
    
    if (updates.service) {
      const serviceInfo = sheetService.getServiceInfo(updates.service);
      if (serviceInfo) {
        userContext.currentOrder.category = serviceInfo.category;
        userContext.currentOrder.type = serviceInfo.type;
        userContext.currentOrder.availableWidths = serviceInfo.availableWidths;
        userContext.currentOrder.availableFinishes = {
          sellado: serviceInfo.sellado,
          ojetillos: serviceInfo.ojetillos,
          bolsillo: serviceInfo.bolsillo
        };
        userContext.currentOrder.fileValidationCriteria = {
          format: serviceInfo.format,
          minDPI: serviceInfo.minDPI,
        };
        logger.info(`Servicio seleccionado para usuario ${userId}: ${JSON.stringify(serviceInfo)}`);
      } else {
        logger.warn(`Servicio no encontrado: ${updates.service}`);
      }
    }

    if (updates.fileAnalysis) {
      userContext.currentOrder.fileAnalysisResponded = false;
    }

    if (updates.fileValidation) {
      userContext.currentOrder.fileValidation = updates.fileValidation;
    }
    
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
  }

  // Nuevo método para actualizar fileAnalysisResponded
  updateFileAnalysisResponded(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisResponded = value;
    logger.info(`FileAnalysisResponded actualizado para usuario ${userId}: ${value}`);
  }

  updateFileAnalysisHandled(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisHandled = value;
    logger.info(`FileAnalysisHandled actualizado para usuario ${userId}: ${value}`);
  }

  hasFileAnalysisBeenResponded(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisResponded;
  }

  hasFileAnalysisBeenHandled(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisHandled;
  }


  getCurrentOrder(userId) {
    const userContext = this.getUserContext(userId);
    logger.info(`Obteniendo orden actual para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
    return userContext.currentOrder;
  }

  resetContext(userId) {
    this.userContexts.delete(userId);
    logger.info(`Contexto reiniciado para usuario ${userId}`);
  }

  getGlobalServices() {
    return sheetService.getServices();
  }

  getGlobalAdditionalInfo() {
    return sheetService.getAdditionalInfo();
  }

  getServiceInfo(serviceName) {
    return sheetService.getServiceInfo(serviceName);
  }

  getAllServices() {
    if (!this.services) {
      logger.warn('Los servicios no han sido inicializados');
      return [];
    }
    return Object.values(this.services).flat();
  }

  findSimilarServices(serviceName) {
    return sheetService.findSimilarServices(serviceName);
  }

  getServicesInCategory(category) {
    return sheetService.getServicesInCategory(category);
  }

  getFileValidationCriteria() {
    return sheetService.getFileValidationCriteria();
  }

  getAvailableFinishes(serviceInfo) {
    const finishes = [];
    if (serviceInfo.sellado) finishes.push("sellado");
    if (serviceInfo.ojetillos) finishes.push("ojetillos");
    if (serviceInfo.bolsillo) finishes.push("bolsillo");
    return finishes;
  }

  isOrderComplete(userId) {
    const order = this.getCurrentOrder(userId);
    const requiredFields = ['service', 'quantity', 'filePath', 'fileAnalysis', 'fileValidation'];
    const hasAllRequiredFields = requiredFields.every(field => order[field] !== null);

    if (!hasAllRequiredFields) return false;

    const serviceInfo = this.getServiceInfo(order.service);
    const needsMeasures = ['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category);

    if (needsMeasures && (!order.measures || !order.measures.width || !order.measures.height)) {
      return false;
    }

    return order.fileValidation && order.fileValidation.isValid;
  }

  getChatContext(userId) {
    return this.getUserContext(userId).chatContext;
  }
}

export default new UserContextManager();


// services\fileValidationService.js

import fs from 'fs';
import { promisify } from 'util';
import path from 'path';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import sharp from 'sharp';
import fileType from 'file-type';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const pdfParse = require('pdf-parse');

const readFile = promisify(fs.readFile);

class FileValidationService {
  constructor() {
    this.supportedFormats = ['jpg', 'jpeg', 'png', 'pdf', 'ai', 'psd', 'cdr'];
  }

  async analyzeFile(filePath) {
    try {
      if (!fs.existsSync(filePath)) {
        throw new CustomError('FileNotFoundError', `El archivo no existe: ${filePath}`);
      }

      const buffer = await readFile(filePath);
      const fileTypeResult = await fileType.fromBuffer(buffer);
      const fileExtension = fileTypeResult ? fileTypeResult.ext : path.extname(filePath).toLowerCase().slice(1);

      if (!this.supportedFormats.includes(fileExtension)) {
        return {
          format: fileExtension,
          supported: false,
          reason: `Formato de archivo no soportado: ${fileExtension}`
        };
      }

      let fileInfo;
      if (['jpg', 'jpeg', 'png'].includes(fileExtension)) {
        fileInfo = await this.analyzeImage(buffer);
      } else if (fileExtension === 'pdf') {
        fileInfo = await this.analyzePDF(buffer);
      } else {
        fileInfo = { format: fileExtension };
      }

      fileInfo.mimeType = fileTypeResult ? fileTypeResult.mime : '';
      fileInfo.supported = true;
      return fileInfo;
    } catch (error) {
      logger.error(`Error al analizar el archivo: ${error.message}`);
      throw new CustomError('FileAnalysisError', 'Error al analizar el archivo', error);
    }
  }

  async analyzeImage(buffer) {
    const image = sharp(buffer);
    const metadata = await image.metadata();

    return {
      format: metadata.format,
      width: metadata.width,
      height: metadata.height,
      dpi: metadata.density || 72,
      colorSpace: metadata.space
    };
  }

  async analyzePDF(buffer) {
    try {
      const data = await pdfParse(buffer);

      return {
        format: 'pdf',
        pages: data.numpages,
        width: data.metadata?.width || 0,
        height: data.metadata?.height || 0,
        dpi: 72 // Asumimos 72 DPI para PDFs
      };
    } catch (error) {
      logger.error(`Error al analizar PDF: ${error.message}`);
      throw new CustomError('PDFAnalysisError', 'Error al analizar el archivo PDF', error);
    }
  }
}

export default new FileValidationService();


// services\openaiService.js

import OpenAI from "openai";
import fs from 'fs';
import { promises as fsPromises } from 'fs';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import userContextManager from '../modules/userContext.js';

class OpenAIService {
  constructor() {
    this.openai = new OpenAI({ apiKey: config.openaiApiKey });
  }

  async getChatCompletion(systemPrompt, context) {
    try {
      const response = await this.openai.chat.completions.create({
        model: config.languageModel,
        messages: [
          { role: "system", content: systemPrompt },
          ...context
        ],
        max_tokens: config.maxTokens,
        temperature: config.temperature,
      });

      return response.choices[0].message.content.trim();
    } catch (error) {
      logger.error("Error al obtener respuesta de OpenAI:", error);
      throw new CustomError('OpenAIError', 'Error al obtener respuesta de OpenAI', error);
    }
  }

  getSystemPrompt(services, currentOrder, additionalInfo, chatContext) {
    const contextStr = chatContext.map(msg => `${msg.role}: ${msg.content}`).join('\n');
    const allServices = this.getAllServicesInfo(services);
    const criteria = userContextManager.getFileValidationCriteria();

    let fileValidationInfo = "";
    if (currentOrder.fileValidation) {
      fileValidationInfo = `
      Información de validación del archivo:
      Válido: ${currentOrder.fileValidation.isValid ? 'Sí' : 'No'}
      Razón: ${currentOrder.fileValidation.reason}
      `;
    }


    return `Eres un asistente experto en servicios de imprenta llamada Chileimprime. Tu objetivo es guiar al cliente a través del proceso de cotización para un único servicio de impresión. Sigue estas instrucciones detalladas:

    1. Análisis Continuo del Estado del Pedido:
       - Examina constantemente el contenido de currentOrder: ${JSON.stringify(currentOrder)}
       - Elementos posibles en currentOrder: {service, category, type, measures, finishes, quantity, filePath, fileAnalysis, fileAnalysisResponded}
       - Adapta tu respuesta basándote en la información disponible y lo que falta por completar.

  2. Inicio y Selección de Servicio:
       - Si es el primer mensaje, saluda al cliente y ofrece asistencia.
       - Si el cliente solicita la lista completa de servicios o el menú, responde con el comando JSON:
         {"command": "LIST_ALL_SERVICES"}
       - Si no hay un servicio seleccionado, pregunta al cliente qué servicio necesita.
       - Utiliza procesamiento de lenguaje natural para detectar si el cliente menciona un servicio específico.
       - IMPORTANTE: Siempre que detectes que el cliente ha seleccionado o mencionado un servicio específico, 
         debes generar el comando JSON correspondiente antes de proporcionar cualquier información adicional:
         {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}
       - Si el servicio mencionado no es válido, sugiere servicios similares o muestra las categorías disponibles.

3. Manejo de Categorías y Tipos de Servicios:
     - Una vez seleccionado el servicio, verifica su categoría y tipo en currentOrder.
     - Para categorías "Telas PVC", "Banderas", "Adhesivos", "Adhesivo Vehicular", "Back Light":
       a) Solicita ancho, alto y cantidad.
       b) Ofrece los anchos disponibles específicos para el servicio (están en currentOrder.availableWidths).
       c) El alto debe ser mayor a 1 metro.
       d) Ofrece terminaciones si están disponibles (revisa currentOrder.availableFinishes).
     - Para categorías "Otros", "Imprenta", "Péndon Roller", "Palomas", "Figuras", "Extras":
       a) Solicita solo la cantidad.
       b) No trabajes con medidas personalizadas.
       c) Ofrece terminaciones si el servicio lo permite (revisa currentOrder.availableFinishes).

4. Especificación de Medidas y Terminaciones:
     - Si el servicio requiere medidas (categorías: Telas PVC, Banderas, Adhesivos, Adhesivo Vehicular, Back Light):
       a) Presenta al cliente los anchos disponibles específicos para este servicio:
          Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
       b) Guía al cliente para que elija uno de estos anchos válidos.
       c) Pide al cliente que especifique un alto mayor a 1 metro.
       d) Solicita la cantidad deseada.
     - Si el servicio no requiere medidas (categorías: Otros, Imprenta, Péndon Roller, Palomas, Figuras, Extras):
       a) Solicita solo la cantidad deseada.
     - Para todos los servicios, ofrece las terminaciones disponibles según:
       Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
     - Explica claramente qué terminaciones están disponibles y pide al cliente que elija.
     - Cuando el cliente proporcione información válida, responde con los comandos JSON apropiados:
       Para servicios con medidas:
       {"command": "SET_MEASURES", "width": X, "height": Y}
       {"command": "SET_QUANTITY", "quantity": Z}
       {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
       Para servicios sin medidas:
       {"command": "SET_QUANTITY", "quantity": Z}
       {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
 
  5. Validación de Archivos:
       - Cuando el cliente haya proporcionado toda la información necesaria (servicio, medidas si aplica, cantidad y terminaciones),
         y si hay un archivo en currentOrder.fileAnalysis, debes solicitar la validación del archivo.
       - Para solicitar la validación, responde con el comando JSON:
         {"command": "VALIDATE_FILE_FOR_SERVICE"}
       - Después de enviar este comando, espera la respuesta del sistema con el resultado de la validación.
       - Una vez recibido el resultado, informa al cliente sobre la validez del archivo y proporciona recomendaciones si es necesario.
       - Los criterios de validación son los siguientes:
        <criterios_validacion> ${criteria}<criterios_validacion>
        Informacion de validacion: <file_validation_info> ${fileValidationInfo} <file_validation_info> (si <file_validation_info> esta vacio es porque no se ha enviado un archivo)

    6. Resumen y Confirmación:
       - Cuando tengas toda la información necesaria, presenta un resumen detallado del pedido.
       - El resumen debe incluir: servicio, medidas (si aplica), cantidad, terminaciones seleccionadas, y confirmación de archivo válido.
       - Permite al cliente modificar cualquier aspecto antes de la confirmación final.
       - Si el cliente confirma, responde con el comando JSON:
         {"command": "CONFIRM_ORDER"}

    7. Comunicación Clara:
       - Usa un tono amigable pero profesional.
       - Estructura tus respuestas en párrafos cortos para mejor legibilidad.
       - Utiliza emojis ocasionalmente para dar un tono más amigable.

    8. Manejo de Errores y Casos Especiales:
      - Si no puedes encontrar información sobre un servicio mencionado por el cliente, responde con:
        {"command": "SERVICE_NOT_FOUND", "service": "Nombre del servicio"}
      - Si detectas que falta información crucial en la orden actual, como el servicio o las medidas, responde con:
        {"command": "MISSING_INFO", "missingField": "Campo faltante"}
      - En caso de cualquier otro error o situación inesperada, responde con:
        {"command": "ERROR", "message": "Descripción del error"}

    9. Validación Continua:
       - Verifica constantemente que la información proporcionada por el cliente sea coherente con el servicio seleccionado.
       - Si detectas alguna incongruencia, solicita aclaración al cliente y utiliza los comandos apropiados para corregir la información.

    10. Comunicación Clara de Errores:
       - Si ocurre algún error durante el proceso, explica al cliente de manera amable y clara lo que ha sucedido.
       - Ofrece alternativas o sugerencias para resolver el problema cuando sea posible.
   
       IMPORTANTE:
    - Utiliza los comandos JSON especificados para comunicar selecciones y validaciones al sistema.
    - Actúa como un experto humano en impresión, no como una IA.
    - Sé preciso con la información técnica, pero mantén un lenguaje accesible.
    - Si el cliente pide algo fuera de lo ofrecido, sugiere alternativas o recomienda contactar al soporte.
    - No calcules precios. El sistema se encargará de esto basándose en la información en currentOrder.
    - Maneja solo un servicio por conversación.
    - Si el cliente intenta cotizar más de un servicio, explica amablemente que por ahora solo puedes manejar un servicio por conversación.
    - Si el sistema indica que un servicio es inválido, explica al cliente que no se encontró el servicio y ofrece alternativas o categorías disponibles.

       Servicios disponibles:
    ${JSON.stringify(allServices, null, 2)}

    Información adicional:
    ${JSON.stringify(additionalInfo, null, 2)}

    Contexto de la conversación:
    ${contextStr}

    Responde al siguiente mensaje del cliente:`;
  }

  getAllServicesInfo(services) {
    const allServices = [];
    for (const category in services) {
      services[category].forEach(service => {
        allServices.push({
          name: service.name,
          category: service.category,
          availableWidths: service.availableWidths,
          availableFinishes: [
            service.sellado ? "sellado" : null,
            service.ojetillos ? "ojetillos" : null,
            service.bolsillo ? "bolsillo" : null
          ].filter(Boolean)
        });
      });
    }
    return allServices;
  }

  async validateFileForService(fileAnalysis, service, measures, currentOrder) {
    const validationCriteria = userContextManager.getFileValidationCriteria();
    
    const prompt = `Eres un experto en análisis de archivos de impresión. 
    Analiza el siguiente archivo para el servicio "${service.name}" con las siguientes medidas: 
    Ancho: ${measures.width}m, Alto: ${measures.height}m.

    Información del archivo:
    ${JSON.stringify(fileAnalysis)}

    Criterios de validación:
    ${validationCriteria}

    Basándote en estos criterios y tu experiencia, determina si el archivo es válido para este servicio y medidas.
    Proporciona una explicación detallada de tu análisis y recomendaciones si el archivo no cumple con los requisitos.
    
    Al final de tu análisis, incluye un comando JSON con el siguiente formato:
    {"command": "VALIDATE_FILE", "isValid": true/false, "reason": "Explicación detallada"}
    
    Asegúrate de que el valor de "isValid" sea true si el archivo cumple con todos los criterios, y false en caso contrario.`;

    try {
      const response = await this.openai.chat.completions.create({
        model: config.languageModel,
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: "Valida este archivo para el servicio y medidas especificados." }
        ],
        max_tokens: config.maxTokens,
        temperature: 0.7,
      });

      const analysis = response.choices[0].message.content.trim();
      const commandMatch = analysis.match(/\{.*\}/);
      if (!commandMatch) {
        throw new Error("No se pudo extraer el comando JSON del análisis");
      }

      const command = JSON.parse(commandMatch[0]);
      return {
        analysis: analysis.replace(commandMatch[0], '').trim(),
        isValid: command.isValid,
        reason: command.reason
      };
    } catch (error) {
      logger.error("Error al validar el archivo con OpenAI:", error);
      throw new CustomError('FileValidationError', 'Error al validar el archivo', error);
    }
  }



  async transcribeAudio(audioFilePath) {
    try {
      const stats = await fsPromises.stat(audioFilePath);
      if (stats.size > config.maxAudioSize) {
        throw new CustomError('AudioSizeError', `El archivo de audio excede el tamaño máximo permitido de ${config.maxAudioSize / (1024 * 1024)} MB`);
      }

      const response = await this.openai.audio.transcriptions.create({
        file: fs.createReadStream(audioFilePath),
        model: "whisper-1",
      });
      logger.info(`Audio transcrito exitosamente: ${audioFilePath}`);
      return response.text;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      logger.error(`Error al transcribir audio: ${error.message}`);
      throw new CustomError('TranscriptionError', 'Error al transcribir el audio', error);
    }
  }
}

export default new OpenAIService();


// services\sheetService.js

import { JWT } from "google-auth-library";
import { GoogleSpreadsheet } from "google-spreadsheet";
import moment from 'moment-timezone';
import 'moment/locale/es.js';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';

class GoogleSheetService {
  constructor() {
    this.jwtFromEnv = new JWT({
      email: config.googleServiceAccountEmail,
      key: config.googlePrivateKey,
      scopes: [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
      ],
    });
    this.doc = new GoogleSpreadsheet(config.googleSheetId, this.jwtFromEnv);
    moment.locale('es');
    moment.tz.setDefault(config.timezone);
    this.services = null;
    this.additionalInfo = null;
    this.isInitialized = false;
  }

  async initialize() {
    try {
      logger.info("Iniciando inicialización de SheetService");
      await this.doc.loadInfo();
      logger.info("Documento de Google Sheets cargado correctamente");
      
      await this.retryOperation(() => this.loadServicesWithRetry());
      logger.info("Servicios cargados correctamente");await this.retryOperation(() => this.loadAdditionalInfoWithRetry());
      logger.info("Información adicional cargada correctamente");
      
      this.isInitialized = true;
      logger.info("SheetService inicializado completamente");
    } catch (error) {
      logger.error(`Error al inicializar SheetService: ${error.message}`);
      throw new CustomError('SheetServiceInitError', 'Error al inicializar el servicio de Google Sheets', error);
    }
  }

  async retryOperation(operation, maxRetries = 5) {
    let retries = 0;
    while (retries < maxRetries) {
      try {
        return await operation();
      } catch (error) {
        if (retries === maxRetries - 1) {
          logger.error(`Error después de ${maxRetries} intentos: ${error.message}`);
          throw error;
        }
        const delay = Math.pow(2, retries) * 1000;
        logger.warn(`Reintento ${retries + 1} en ${delay}ms: ${error.message}`);
        await new Promise(resolve => setTimeout(resolve, delay));
        retries++;
      }
    }
  }

  async loadServicesWithRetry() {
    logger.info("Iniciando carga de servicios");
    this.services = await this.getServices();
    logger.info(`Servicios cargados: ${Object.keys(this.services).length} categorías`);
  }

  async loadAdditionalInfoWithRetry() {
    logger.info("Iniciando carga de información adicional");
    this.additionalInfo = await this.getAdditionalInfo();
    logger.info("Información adicional cargada");
  }

  getServices() {
    return this.services;
  }

  getAdditionalInfo() {
    return this.additionalInfo;
  }

  getServiceInfo(serviceName) {
    if (!serviceName || typeof serviceName !== 'string') {
      logger.warn(`Nombre de servicio inválido: ${serviceName}`);
      return null;
    }

    const lowerServiceName = serviceName.toLowerCase();
    for (const category in this.services) {
      const service = this.services[category].find(s => s.name.toLowerCase() === lowerServiceName);
      if (service) {
        return service;
      }
    }
    logger.warn(`Servicio no encontrado: ${serviceName}`);
    return null;
  }

  getAllServices() {
    let allServices = [];
    for (const category in this.services) {
      allServices = allServices.concat(this.services[category]);
    }
    return allServices;
  }

  getServicesInCategory(category) {
    return this.services[category] || [];
  }

  getFileValidationCriteria() {
    return this.additionalInfo.criteriosValidacion;
  }

  findSimilarServices(serviceName) {
    const allServices = this.getAllServices();
    return allServices
      .filter(service => 
        service.name.toLowerCase().includes(serviceName.toLowerCase()) || 
        serviceName.toLowerCase().includes(service.name.toLowerCase())
      )
      .map(service => ({
        name: service.name,
        category: service.category
      }));
  }

  async getServices() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[0];
      await sheet.loadCells('A1:Q1000');
  
      const services = {};
      for (let i = 1; i < sheet.rowCount; i++) {
        const id = sheet.getCell(i, 0).value;
        if (!id) break;
  
        const service = this.extractServiceData(sheet, i);
        if (service) {
          if (!services[service.category]) {
            services[service.category] = [];
          }
          services[service.category].push(service);
        }
      }
  
      return services;
    } catch (err) {
      logger.error("Error al obtener los servicios:", err);
      throw new CustomError('ServicesFetchError', 'Error al obtener los servicios desde Google Sheets', err);
    }
  }

  extractServiceData(sheet, row) {
    try {
      const widthsString = sheet.getCell(row, 12).value;
      const availableWidths = widthsString ? this.parseAvailableWidths(widthsString) : [];
  
      const sellado = sheet.getCell(row, 4).value.toLowerCase();
      const ojetillos = sheet.getCell(row, 5).value.toLowerCase();
      const bolsillo = sheet.getCell(row, 6).value.toLowerCase();
  
      logger.info(`Valores leídos para el servicio en la fila ${row}:`);
      logger.info(`Sellado: ${sellado}, Ojetillos: ${ojetillos}, Bolsillo: ${bolsillo}`);
  
      const service = {
        id: sheet.getCell(row, 0).value,
        category: sheet.getCell(row, 1).value,
        type: sheet.getCell(row, 2).value,
        name: sheet.getCell(row, 3).value,
        sellado: sellado === 'sí' || sellado === 'si',
        ojetillos: ojetillos === 'sí' || ojetillos === 'si',
        bolsillo: bolsillo === 'sí' || bolsillo === 'si',
        format: sheet.getCell(row, 7).value,
        minDPI: parseInt(sheet.getCell(row, 8).value) || 0,
        stock: parseInt(sheet.getCell(row, 9).value) || 0,
        status: sheet.getCell(row, 10).value,
        precio: parseFloat(sheet.getCell(row, 11).value) || 0,
        availableWidths: availableWidths,
        precioSellado: parseFloat(sheet.getCell(row, 14).value) || 0,
        precioBolsillo: parseFloat(sheet.getCell(row, 15).value) || 0,
        precioOjetillos: parseFloat(sheet.getCell(row, 16).value) || 0
      };
  
      logger.info(`Servicio extraído: ${JSON.stringify(service)}`);
  
      return service;
    } catch (error) {
      logger.error(`Error al extraer datos del servicio en la fila ${row}: ${error.message}`);
      return null;
    }
  }

  parseAvailableWidths(widthsString) {
    if (!widthsString || widthsString.toLowerCase().includes('no tiene rollos')) {
      return [];
    }
    
    logger.info(`Procesando medidas: ${widthsString}`);
    
    const lines = widthsString.split('\n').filter(line => !line.includes('Ancho material'));
    
    return lines.map(line => {
      const [material, imprimible] = line.split('-').map(part => part.trim());
      
      const parseMeasure = (measure) => {
        if (typeof measure !== 'string') {
          logger.warn(`Medida no es un string: ${measure}`);
          return 0;
        }
        return parseFloat(measure.replace('m', '').replace(',', '.')) || 0;
      };
      
      const parsedMaterial = parseMeasure(material);
      const parsedImprimible = parseMeasure(imprimible);
      
      if (parsedMaterial && parsedImprimible) {
        logger.info(`Medida procesada: material ${parsedMaterial}m, imprimible ${parsedImprimible}m`);
        return {
          material: parsedMaterial,
          imprimible: parsedImprimible
        };
      } else {
        logger.warn(`No se pudo procesar la medida: ${line}`);
        return null;
      }
    }).filter(w => w !== null);
  }

  async getAdditionalInfo() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[2];
      await sheet.loadCells();
  
      logger.info("Cargando información adicional de la hoja 'Informacion'");
  
      const additionalInfo = {
        horarios: {},
        zonasDespacho: [],
        direccionRetiro: '',
        promocionDia: '',
        metodosPago: '',
        tiempoPreparacion: '',
        criteriosValidacion: '',
        estadoBot: ''
      };
  
      this.extractAdditionalInfo(sheet, additionalInfo);
  
      logger.info("Información adicional cargada completamente");
      logger.debug(`Información adicional: ${JSON.stringify(additionalInfo)}`);
  
      return additionalInfo;
    } catch (err) {
      logger.error("Error al obtener información adicional:", err);
      throw new CustomError('AdditionalInfoError', 'Error al obtener información adicional desde Google Sheets', err);
    }
  }

  extractAdditionalInfo(sheet, additionalInfo) {
    const safeGetCellValue = (row, col) => {
      try {
        const cell = sheet.getCell(row, col);
        return cell.value || '';
      } catch (error) {
        logger.warn(`No se pudo obtener el valor de la celda (${row}, ${col}): ${error.message}`);
        return '';
      }
    };

    ['Lunes a viernes', 'Sábados', 'Domingos'].forEach((dia, index) => {
      additionalInfo.horarios[dia] = `${safeGetCellValue(index + 1, 0)} ${safeGetCellValue(index + 1, 1)}`.trim() || 'No disponible';
    });
  
    for (let row = 1; row <= 9; row++) {
      const zona = safeGetCellValue(row, 2);
      if (zona && zona.trim()) additionalInfo.zonasDespacho.push(zona.trim());
    }
  
    additionalInfo.direccionRetiro = safeGetCellValue(1, 4) || 'No disponible';
    additionalInfo.promocionDia = safeGetCellValue(1, 5) || 'No hay promociones actualmente';
    additionalInfo.metodosPago = safeGetCellValue(1, 6) || 'No especificado';
    additionalInfo.tiempoPreparacion = safeGetCellValue(1, 7) || 'No especificado';
    additionalInfo.criteriosValidacion = safeGetCellValue(1, 8) || 'No especificado';
    additionalInfo.estadoBot = safeGetCellValue(1, 9) || 'No especificado';
  
    logger.info(`Criterios de validación extraídos: ${additionalInfo.criteriosValidacion}`);
    logger.info(`Estado del bot: ${additionalInfo.estadoBot}`);
  }

  async saveOrder(data) {
    logger.info(`Iniciando guardado de cotización en Google Sheets: ${JSON.stringify(data)}`);
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1];
      await sheet.loadCells();
  
      const rowData = this.prepareRowData(data);
      const result = await sheet.addRows([rowData]);
  
      return this.processAddRowResult(result, sheet);
    } catch (err) {
      logger.error("Error detallado al guardar la cotización en Google Sheets:", err.message);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('OrderSaveError', `Error al guardar la cotización: ${err.message}`, err);
    }
  }

  prepareRowData(data) {
    const formattedDate = moment().tz(config.timezone).format('DD-MM-YYYY HH:mm[hrs] - dddd');
    const censoredPhone = this.censorPhoneNumber(data.telefono);
    return [
      formattedDate,
      censoredPhone,
      data.nombre,
      data.correo || '',
      data.pedido,
      data.archivos || '',
      data.total,
      "Nueva cotización"
    ];
  }

  processAddRowResult(result, sheet) {
    if (Array.isArray(result) && result.length > 0) {
      const firstRow = result[0];
      const rowIndex = firstRow.rowIndex || firstRow._rowNumber || sheet.rowCount;
      logger.info(`Fila añadida exitosamente. ID de la nueva fila: ${rowIndex}`);
      return { success: true, message: "Cotización guardada exitosamente", rowIndex: rowIndex };
    } else {
      logger.warn("No se pudo obtener información de la fila añadida");
      return { success: true, message: "Cotización guardada exitosamente, pero no se pudo obtener el ID de la fila" };
    }
  }

  censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) return phoneNumber;
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    return `${firstTwo}${'*'.repeat(middleLength)}${lastThree}`;
  }

  async reinitialize() {
    try {
      logger.info("Reinicializando servicios e información adicional");
      await this.retryOperation(() => this.loadServicesWithRetry());
      await this.retryOperation(() => this.loadAdditionalInfoWithRetry());
      logger.info("Servicios e información adicional reinicializados correctamente");
    } catch (error) {
      logger.error(`Error al reinicializar SheetService: ${error.message}`);
      throw new CustomError('SheetServiceReinitError', 'Error al reinicializar el servicio de Google Sheets', error);
    }
  }
}

export default new GoogleSheetService();


// services\whatsappService.js

// services/whatsappService.js

import { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot';
import { BaileysProvider } from '@builderbot/provider-baileys';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import fs from 'fs/promises';
import path from 'path';

class WhatsAppService {
  constructor() {
    this.provider = null;
    this.bot = null;
  }

  async initialize(flows) {
    try {
      const adapterDB = new MemoryDB();
      const adapterFlow = createFlow(flows);
      const adapterProvider = createProvider(BaileysProvider, {
        groupsIgnore: true,
      });

      this.provider = adapterProvider;

      const { bot, httpServer } = await createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
      }, {
        queue: {
          timeout: 60000,
          concurrencyLimit: 100
        }
      });

      this.bot = bot;

      httpServer(config.port);
      logger.info(`Bot iniciado en el puerto ${config.port}`);
    } catch (error) {
      logger.error('Error al inicializar WhatsApp Service:', error);
      throw new CustomError('WhatsAppInitError', 'Error al inicializar el servicio de WhatsApp', error);
    }
  }

  async sendMessage(to, message, options = {}) {
    try {
      await this.bot.sendMessage(to, message, options);
      logger.info(`Mensaje enviado a ${to}`);
    } catch (error) {
      logger.error(`Error al enviar mensaje a ${to}:`, error);
      throw new CustomError('MessageSendError', 'Error al enviar mensaje de WhatsApp', error);
    }
  }

  async saveAudioFile(ctx) {
    try {
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo de audio');
      }
    } catch (error) {
      logger.error('Error al guardar archivo de audio:', error);
      throw new CustomError('AudioSaveError', 'Error al guardar archivo de audio', error);
    }
  }

  async saveFile(ctx) {
    try {
      if (!this.provider) {
        throw new Error('El proveedor de WhatsApp no está inicializado');
      }
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo');
      }
    } catch (error) {
      logger.error('Error al guardar archivo:', error);
      throw new CustomError('FileSaveError', 'Error al guardar archivo', error);
    }
  }

  async processVoiceNote(ctx, audioPath) {
    try {
      logger.info(`Procesando nota de voz para usuario ${ctx.from}`);
      const transcription = await openaiService.transcribeAudio(audioPath);
      await fs.unlink(audioPath);
      logger.info(`Nota de voz procesada y archivo eliminado: ${audioPath}`);
      return transcription;
    } catch (error) {
      logger.error(`Error procesando nota de voz: ${error.message}`);
      throw new CustomError('VoiceNoteProcessError', 'Error al procesar nota de voz', error);
    }
  }

  getPromoMessage() {
    return `🤖 *¡Gracias por probar nuestro Bot de Demostración!* 🚀
  
  Desarrollado con ❤️ por *SuperPyme*
  
  🍽️ *Ver Menú y Pedidos:*
  https://docs.google.com/spreadsheets/d/1ZFq1c0IWbR3prkuZdnbJ_Och-GhxI9iMh56yqYlmAjo/edit?usp=sharing
  
  🔒 _Nota: Los números están censurados para proteger la privacidad de nuestros usuarios de prueba._
  
  ✨ *¿Quieres un bot así para tu negocio?* ✨
  
  📱 Whatsapp: *+56 9 7147 1884*
  📧 Escríbenos: *oficina@superpyme.cl*
  🌐 Más información: *superpyme.cl*
  
  🚀 *¡Lleva tu negocio al siguiente nivel con SuperPyme!* 💼
  
  PD: Puedes volver a probar el bot en 10 minutos, si quieres probarlo de inmediato, escribe desde otro número.`;
  }
}

export default new WhatsAppService();


// utils\errorHandler.js

import logger from './logger.js';

export class CustomError extends Error {
  constructor(name, message, originalError = null) {
    super(message);
    this.name = name;
    this.originalError = originalError;
  }
}

export const errorHandler = async (error, ctx, { flowDynamic, endFlow }) => {
  logger.error(`Error: ${error.name} - ${error.message}`);
  if (error.originalError) {
    logger.error(`Error original: ${error.originalError.message}`);
    logger.error(`Stack trace: ${error.originalError.stack}`);
  }

  let userMessage = 'Lo siento, ha ocurrido un error inesperado. Por favor, inténtalo de nuevo más tarde.';

  switch (error.name) {
    case 'OpenAIError':
      userMessage = 'Estamos experimentando problemas con nuestro servicio de IA. Por favor, inténtalo de nuevo en unos minutos.';
      break;
    case 'SheetServiceError':
      userMessage = 'Hay un problema temporal con nuestro sistema de pedidos. Por favor, inténtalo de nuevo más tarde.';
      break;
    case 'WhatsAppError':
      userMessage = 'Estamos teniendo dificultades para procesar tu mensaje. Por favor, inténtalo de nuevo.';
      break;
    case 'MiddlewareError':
      userMessage = 'Ha ocurrido un error al procesar tu solicitud. Por favor, inténtalo de nuevo.';
      break;
  }

  await flowDynamic(userMessage);
  return endFlow();
};


// utils\helpers.js

// utils/helpers.js

export function formatPrice(price) {
    return price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
  }
  
  export function censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) {
      return phoneNumber;
    }
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    const censoredMiddle = '*'.repeat(middleLength);
    return `${firstTwo}${censoredMiddle}${lastThree}`;
  }


// utils\logger.js

import winston from 'winston';
import config from '../config/config.js';
import moment from 'moment-timezone';

const { combine, timestamp, printf } = winston.format;

const myFormat = printf(({ level, message, timestamp }) => {
  const formattedTimestamp = moment(timestamp).tz('America/Santiago').format('DD-MM-YY - HH:mm:ss a');
  return `${formattedTimestamp} : [${level.toUpperCase()}] ${message}`;
});

const logger = winston.createLogger({
  level: config.logLevel || 'info',
  format: combine(
    timestamp(),
    myFormat
  ),
  defaultMeta: { service: 'chatbot-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: myFormat,
  }));
}

export default logger;


