
// app.js

// app.js

import { createBot, createProvider, createFlow, addKeyword, MemoryDB, EVENTS } from '@builderbot/bot';
import { BaileysProvider } from '@builderbot/provider-baileys';
import { openaiService } from './services/openai-service.js';
import { sheetsService } from './services/sheets-service.js';
import { conversationManager } from './core/conversation-manager.js';
import { commandHandler } from './core/command-handler.js';
import { userSessionManager } from './core/user-session-manager.js';
import { middlewareManager } from './core/middleware-manager.js';
import { messageProcessor } from './middleware/message-processor.js';
import { errorHandler } from './middleware/error-handler.js';
import { quoteCommand } from './commands/quote-command.js';
import { listServicesCommand } from './commands/list-services-command.js';
import { additionalInfoCommand } from './commands/additional-info-command.js';
import { createOrderCommand } from './commands/create-order-command.js';
import { greetingCommand } from './commands/greeting-command.js';
import { defaultCommand } from './commands/default-command.js';
import { selectServiceCommand } from './commands/select-service-command.js';
import { logger } from './utils/logger.js';
import { pluginManager } from './core/plugin-manager.js';
import { examplePlugin } from './plugins/example-plugin.js';
import config from './config/index.js';

const PORT = config.port;

// Registrar plugins
pluginManager.registerPlugin('examplePlugin', examplePlugin);

// Registrar comandos
commandHandler.registerCommand('GREETING', greetingCommand);
commandHandler.registerCommand('QUOTE', quoteCommand);
commandHandler.registerCommand('LIST_SERVICES', listServicesCommand);
commandHandler.registerCommand('ADDITIONAL_INFO', additionalInfoCommand);
commandHandler.registerCommand('CREATE_ORDER', createOrderCommand);
commandHandler.registerCommand('SELECT_SERVICE', selectServiceCommand);
commandHandler.registerDefaultCommand(defaultCommand);



// Configurar middleware
middlewareManager.use(messageProcessor);
middlewareManager.use(errorHandler);

// Configurar estados de conversación
conversationManager.registerState('INITIAL', async (ctx, action, { flowDynamic }) => {
  await flowDynamic('Bienvenido a la imprenta. ¿En qué puedo ayudarte?');
});

conversationManager.registerState('MAIN_MENU', async (ctx, action, { flowDynamic }) => {
  await commandHandler.executeCommand(action, ctx, { flowDynamic });
});

conversationManager.registerState('LISTING_SERVICES', async (ctx, action, { flowDynamic }) => {
  const serviceList = await sheetsService.getFormattedServiceList();
  await flowDynamic(serviceList);
});

conversationManager.registerState('SELECTING_SERVICE', async (ctx, action, { flowDynamic }) => {
    await commandHandler.executeCommand('SELECT_SERVICE', ctx, { flowDynamic });
  });
  

conversationManager.registerState('PROVIDING_ADDITIONAL_INFO', async (ctx, action, { flowDynamic }) => {
  const additionalInfo = await sheetsService.getFormattedAdditionalInfo();
  await flowDynamic(additionalInfo);
});

conversationManager.registerState('QUOTING', async (ctx, action, { flowDynamic }) => {
  await flowDynamic('Por favor, proporciona los detalles del servicio que deseas cotizar.');
});

conversationManager.registerState('CREATING_ORDER', async (ctx, action, { flowDynamic }) => {
  await flowDynamic('Vamos a crear tu pedido. Por favor, proporciona los detalles del servicio que deseas ordenar.');
});

// Configurar transiciones
conversationManager.registerTransition('INITIAL', 'MAIN_MENU', () => true);
conversationManager.registerTransition('MAIN_MENU', 'LISTING_SERVICES', (ctx, action) => action === 'LIST_SERVICES');
conversationManager.registerTransition('MAIN_MENU', 'PROVIDING_ADDITIONAL_INFO', (ctx, action) => action === 'ADDITIONAL_INFO');
conversationManager.registerTransition('MAIN_MENU', 'QUOTING', (ctx, action) => action === 'QUOTE');
conversationManager.registerTransition('MAIN_MENU', 'CREATING_ORDER', (ctx, action) => action === 'CREATE_ORDER');
conversationManager.registerTransition('LISTING_SERVICES', 'SELECTING_SERVICE', () => true);
conversationManager.registerTransition('SELECTING_SERVICE', 'QUOTING', () => true);



// Configurar flujo principal
const mainFlow = addKeyword([EVENTS.WELCOME, 'hola', 'inicio', 'menu'])
  .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
    const userId = ctx.from;
    ctx.userContext = userSessionManager.getSession(userId);

    try {
      await middlewareManager.run(ctx, { flowDynamic, gotoFlow });
      await conversationManager.handleMessage(ctx, { flowDynamic, gotoFlow });
    } catch (error) {
      logger.error(`Error in main flow for user ${userId}`, error);
      await flowDynamic('Lo siento, ha ocurrido un error inesperado. Por favor, intenta de nuevo más tarde.');
    }
  });

// Inicializar bot
const main = async () => {
  try {
    await openaiService.initialize();
    await sheetsService.initialize();

    const adapterDB = new MemoryDB();
    const adapterFlow = createFlow([mainFlow]);
    const adapterProvider = createProvider(BaileysProvider);

    const { httpServer } = await createBot({
      flow: adapterFlow,
      provider: adapterProvider,
      database: adapterDB,
    });

    if (httpServer) {
      httpServer(PORT);
      logger.info(`HTTP Server is running on port ${PORT}`);
    } else {
      logger.warn('HTTP Server is not available in this BuilderBot version');
    }

    logger.info('Bot initialized successfully');
  } catch (error) {
    logger.error('Failed to initialize bot', error);
    process.exit(1);
  }
};

main().catch(error => {
  logger.error('Unhandled error in main function', error);
  process.exit(1);
});


// commands\additional-info-command.js

// src/commands/additional-info-command.js

import { sheetsService } from '../services/sheets-service.js';
import { logger } from '../utils/logger.js';

class AdditionalInfoCommand {
  async execute(ctx, { flowDynamic }) {
    try {
      const additionalInfo = await sheetsService.getFormattedAdditionalInfo();
      await flowDynamic(additionalInfo);
    } catch (error) {
      logger.error('Error executing additional info command', error);
      await flowDynamic('Lo siento, ha ocurrido un error al obtener la información adicional.');
    }
  }
}

export const additionalInfoCommand = new AdditionalInfoCommand();


// commands\analyze-file-command.js

// commands/analyze-file-command.js

import { fileAnalyzer } from '../services/file-analyzer.js';
import { logger } from '../utils/logger.js';
import { validators } from '../utils/validators.js';
import { ValidationError } from '../utils/error-types.js';

class AnalyzeFileCommand {
  async execute(ctx) {
    try {
      await ctx.reply('Por favor, envía el archivo que deseas analizar.');
      ctx.userContext.setState('UPLOADING_FILE');
      
      // La lógica de análisis del archivo se manejará en el estado UPLOADING_FILE de la FSM
    } catch (error) {
      logger.error('Error initiating file analysis command', error);
      await ctx.reply('Lo siento, ha ocurrido un error al iniciar el análisis del archivo.');
    }
  }

  async handleFileUpload(ctx) {
    if (!ctx.attachment) {
      await ctx.reply('No se ha recibido ningún archivo. Por favor, envía un archivo para analizar.');
      return;
    }

    try {
      validators.validateFile(ctx.attachment, {
        allowedFileTypes: ['application/pdf', 'image/jpeg', 'image/png'],
        maxFileSize: 10 * 1024 * 1024 // 10 MB
      });

      const analysis = await fileAnalyzer.analyzeFile(Buffer.from(ctx.attachment.data, 'base64'), ctx.attachment.filename);
      await ctx.reply(analysis);

      // Volver al menú principal después del análisis
      ctx.userContext.setState('MAIN_MENU');
      await ctx.reply('¿En qué más puedo ayudarte?');
    } catch (error) {
      if (error instanceof ValidationError) {
        await ctx.reply(error.message);
      } else {
        logger.error('Error analyzing file', error);
        await ctx.reply('Lo siento, ha ocurrido un error al analizar el archivo.');
      }
      // Mantener el estado en UPLOADING_FILE para permitir otro intento
    }
  }
}

export const analyzeFileCommand = new AnalyzeFileCommand();


// commands\create-order-command.js

// src/commands/create-order-command.js

import { sheetsService } from '../services/sheets-service.js';
import { logger } from '../utils/logger.js';

class CreateOrderCommand {
  async execute(ctx, { flowDynamic }) {
    try {
      await flowDynamic('Vamos a crear tu pedido. Por favor, proporciona los siguientes detalles:');
      await flowDynamic('1. Nombre del servicio\n2. Cantidad\n3. Medidas (si aplica)\n4. Acabados especiales (si deseas)');
      ctx.userContext.setState('CREATING_ORDER');
    } catch (error) {
      logger.error('Error executing create order command', error);
      await flowDynamic('Lo siento, ha ocurrido un error al iniciar el proceso de pedido.');
    }
  }

  async handleOrderDetails(ctx, { flowDynamic }) {
    // Aquí iría la lógica para procesar los detalles del pedido
    // Este método se llamaría desde el estado CREATING_ORDER en conversation-manager.js
  }
}

export const createOrderCommand = new CreateOrderCommand();


// commands\default-command.js

// commands/default-command.js
import { logger } from '../utils/logger.js';

class DefaultCommand {
  async execute(ctx, { flowDynamic }) {
    logger.info(`Executing default command for user ${ctx.from}`);
    await flowDynamic('Lo siento, no he entendido tu solicitud. ¿Podrías reformularla o elegir una de las opciones disponibles?');
  }
}

export const defaultCommand = new DefaultCommand();


// commands\generate-budget-command.js

// commands/generate-budget-command.js

import { openaiService } from '../services/openai-service.js';
import { printingCalculator } from '../services/printing-calculator.js';
import { logger } from '../utils/logger.js';
import { ValidationError } from '../utils/error-types.js';

class GenerateBudgetCommand {
  async execute(ctx) {
    try {
      const cart = ctx.userContext.getCart();
      if (cart.isEmpty()) {
        await ctx.reply('No hay items en el carrito para generar un presupuesto. Por favor, cotiza algunos servicios primero.');
        ctx.userContext.setState('MAIN_MENU');
        return;
      }

      await ctx.reply('Generando presupuesto basado en tu carrito actual...');
      ctx.userContext.setState('CONFIRMING_ORDER');

      const budget = await this.generateBudget(cart);
      await ctx.reply(budget);

      await ctx.reply('¿Deseas confirmar este presupuesto o hacer cambios?');
    } catch (error) {
      logger.error('Error executing generate budget command', error);
      await ctx.reply('Lo siento, ha ocurrido un error al generar el presupuesto.');
      ctx.userContext.setState('MAIN_MENU');
    }
  }

  async generateBudget(cart) {
    try {
      const calculatedOrder = printingCalculator.calculatePrice(cart);
      const formattedBudget = printingCalculator.formatOrderSummary(calculatedOrder);

      const aiPrompt = `Genera un presupuesto detallado basado en la siguiente orden de impresión:\n${formattedBudget}`;
      const aiResponse = await openaiService.getChatCompletion(aiPrompt);

      return `Aquí tienes tu presupuesto detallado:\n\n${aiResponse}`;
    } catch (error) {
      logger.error('Error generating budget', error);
      throw new Error('No se pudo generar el presupuesto');
    }
  }

  async handleConfirmation(ctx, confirmation) {
    if (confirmation.toLowerCase() === 'confirmar') {
      await ctx.reply('¡Gracias por confirmar tu pedido! Nuestro equipo se pondrá en contacto contigo pronto para finalizar los detalles.');
      // Aquí se podría agregar lógica para guardar el pedido en la base de datos o enviar notificaciones
      ctx.userContext.clearCart();
    } else if (confirmation.toLowerCase() === 'cambios') {
      await ctx.reply('Entendido. Volvamos al menú principal para hacer cambios en tu pedido.');
    } else {
      await ctx.reply('No entendí tu respuesta. Por favor, di "confirmar" para aceptar el presupuesto o "cambios" para modificar tu pedido.');
      return; // Mantener el estado actual para esperar una respuesta válida
    }
    
    ctx.userContext.setState('MAIN_MENU');
    await ctx.reply('¿En qué más puedo ayudarte?');
  }
}

export const generateBudgetCommand = new GenerateBudgetCommand();


// commands\greeting-command.js

export const greetingCommand = {
    execute: async (ctx, { flowDynamic }) => {
      await flowDynamic('¡Hola! Bienvenido a la imprenta. ¿En qué puedo ayudarte hoy?');
    }
  };


// commands\list-services-command.js

// src/commands/list-services-command.js

import { sheetsService } from '../services/sheets-service.js';
import { logger } from '../utils/logger.js';

class ListServicesCommand {
  async execute(ctx, { flowDynamic }) {
    try {
      const serviceList = await sheetsService.getFormattedServiceList();
      await flowDynamic(serviceList);
    } catch (error) {
      logger.error('Error executing list services command', error);
      await flowDynamic('Lo siento, ha ocurrido un error al obtener la lista de servicios.');
    }
  }
}

export const listServicesCommand = new ListServicesCommand();


// commands\quote-command.js

// commands/quote-command.js

import { sheetsService } from '../services/sheets-service.js';
import { logger } from '../utils/logger.js';
import { validators } from '../utils/validators.js';
import { ValidationError } from '../utils/error-types.js';

class QuoteCommand {
  async execute(ctx) {
    try {
      const menu = await sheetsService.getMenu();
      ctx.userContext.setMenu(menu);
      await ctx.reply('Por favor, dime qué tipo de impresión necesitas.');
      ctx.userContext.setState('SELECTING_SERVICE');

      // La lógica siguiente se manejará en los estados correspondientes de la FSM
      // Este comando solo inicia el proceso de cotización

    } catch (error) {
      if (error instanceof ValidationError) {
        await ctx.reply(error.message);
      } else {
        logger.error('Error executing quote command', error);
        await ctx.reply('Lo siento, ha ocurrido un error al procesar tu solicitud.');
      }
    }
  }

  async handleServiceSelection(ctx, service) {
    // Esta lógica se moverá al estado SELECTING_SERVICE de la FSM
    try {
      validators.validateServiceSelection(service, ctx.userContext.getMenu());
      ctx.userContext.getCart().addItem(service);
      ctx.userContext.setState('ENTERING_MEASUREMENTS');
      await ctx.reply(`Has seleccionado ${service.name}. Ahora, por favor, proporciona las medidas.`);
    } catch (error) {
      throw new ValidationError(error.message);
    }
  }

  async handleMeasurements(ctx, measurements) {
    // Esta lógica se moverá al estado ENTERING_MEASUREMENTS de la FSM
    try {
      const service = ctx.userContext.getCart().getLastItem();
      validators.validateMeasurements(measurements, service);
      ctx.userContext.getCart().updateLastItem({ measurements });
      ctx.userContext.setState('SELECTING_FINISHES');
      await ctx.reply('Medidas registradas. ¿Deseas algún acabado especial?');
    } catch (error) {
      throw new ValidationError(error.message);
    }
  }

  async handleFinishes(ctx, finishes) {
    // Esta lógica se moverá al estado SELECTING_FINISHES de la FSM
    try {
      const service = ctx.userContext.getCart().getLastItem();
      validators.validateFinishes(finishes, service);
      ctx.userContext.getCart().updateLastItem({ finishes });
      ctx.userContext.setState('UPLOADING_FILE');
      await ctx.reply('Acabados registrados. Por favor, sube tu archivo de diseño.');
    } catch (error) {
      throw new ValidationError(error.message);
    }
  }
}

export const quoteCommand = new QuoteCommand();


// commands\select-service-command.js

// commands/select-service-command.js

import { sheetsService } from '../services/sheets-service.js';
import { logger } from '../utils/logger.js';
import { ValidationError } from '../utils/error-types.js';

class SelectServiceCommand {
  async execute(ctx, { flowDynamic }) {
    try {
      const userInput = ctx.body.toLowerCase();
      const services = await sheetsService.getServices();
      const selectedService = this.findService(services, userInput);

      if (selectedService) {
        ctx.userContext.setSelectedService(selectedService);
        await flowDynamic(`Has seleccionado ${selectedService.nombre}. El precio base es $${selectedService.precio}. ¿Deseas proceder con la cotización?`);
      } else {
        throw new ValidationError('Servicio no encontrado. Por favor, selecciona un servicio válido del menú.');
      }
    } catch (error) {
      if (error instanceof ValidationError) {
        await flowDynamic(error.message);
      } else {
        logger.error('Error executing select service command:', error);
        await flowDynamic('Lo siento, ha ocurrido un error al seleccionar el servicio. Por favor, intenta nuevamente.');
      }
    }
  }

  findService(services, userInput) {
    for (const category of Object.values(services)) {
      const service = category.find(s => s.nombre.toLowerCase().includes(userInput));
      if (service) return service;
    }
    return null;
  }
}

export const selectServiceCommand = new SelectServiceCommand();


// config\index.js

import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

const ENV = process.env.NODE_ENV || 'development';

const createGoogleCredentials = () => ({
  type: "service_account",
  project_id: process.env.GOOGLE_PROJECT_ID,
  private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  client_email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
});

const config = {
  env: ENV,
  port: process.env.PORT || 3000,
  openai: {
    apiKey: process.env.OPENAI_API_KEY,
    model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
  },
  googleSheets: {
    sheetId: process.env.GOOGLE_SHEET_ID,
    credentials: createGoogleCredentials(),
  },
  logging: {
    level: process.env.LOG_LEVEL || 'info',
  },
  sessionTimeout: parseInt(process.env.SESSION_TIMEOUT) || 30 * 60 * 1000, // 30 minutos por defecto
};

export default config;


// core\command-handler.js

import { logger } from '../utils/logger.js';

class CommandHandler {
  constructor() {
    this.commands = new Map();
    this.subcommands = new Map();
    this.dependencies = new Map();
    this.defaultCommand = null;
  }

  registerDefaultCommand(handler) {
    this.defaultCommand = handler;
    logger.info('Default command registered');
  }

  registerCommand(name, handler, dependencies = []) {
    this.commands.set(name, handler);
    this.dependencies.set(name, dependencies);
    logger.info(`Command ${name} registered`);
  }

  registerSubcommand(commandName, subcommandName, handler) {
    if (!this.subcommands.has(commandName)) {
      this.subcommands.set(commandName, new Map());
    }
    this.subcommands.get(commandName).set(subcommandName, handler);
    logger.info(`Subcommand ${subcommandName} registered for command ${commandName}`);
  }

  async executeCommand(name, ctx, { flowDynamic, gotoFlow }, subcommand = null) {
    if (this.commands.has(name)) {
      try {
        await this.executeDependencies(name, ctx, { flowDynamic, gotoFlow });
        if (subcommand && this.subcommands.has(name) && this.subcommands.get(name).has(subcommand)) {
          await this.subcommands.get(name).get(subcommand).execute(ctx, { flowDynamic, gotoFlow });
        } else {
          await this.commands.get(name).execute(ctx, { flowDynamic, gotoFlow });
        }
      } catch (error) {
        logger.error(`Error executing command ${name}`, error);
        throw error;
      }
    } else if (this.defaultCommand) {
      await this.defaultCommand.execute(ctx, { flowDynamic, gotoFlow });
    } else {
      logger.error(`Command ${name} not found and no default command registered`);
      throw new Error(`Command ${name} not found`);
    }
  }

  async executeDependencies(commandName, ctx, { flowDynamic, gotoFlow }) {
    const dependencies = this.dependencies.get(commandName) || [];
    for (const dep of dependencies) {
      await this.executeCommand(dep, ctx, { flowDynamic, gotoFlow });
    }
  }

  getRegisteredCommands() {
    return Array.from(this.commands.keys());
  }

  getSubcommands(commandName) {
    return this.subcommands.get(commandName) ? Array.from(this.subcommands.get(commandName).keys()) : [];
  }
}

export const commandHandler = new CommandHandler();


// core\conversation-manager.js

// core/conversation-manager.js

import { openaiService } from '../services/openai-service.js';
import { sheetsService } from '../services/sheets-service.js';
import { commandHandler } from './command-handler.js';
import { logger } from '../utils/logger.js';

class ConversationManager {
  constructor() {
    this.states = new Map();
    this.transitions = new Map();
  }

  registerState(stateName, handler) {
    this.states.set(stateName, handler);
    logger.info(`State ${stateName} registered`);
  }

  registerTransition(fromState, toState, condition) {
    if (!this.transitions.has(fromState)) {
      this.transitions.set(fromState, new Map());
    }
    this.transitions.get(fromState).set(toState, condition);
    logger.info(`Transition registered: ${fromState} -> ${toState}`);
  }

  async handleMessage(ctx, { flowDynamic, gotoFlow }) {
    const userContext = ctx.userContext;
    const currentState = userContext.getState();

    try {
      userContext.addToHistory('user', ctx.body);

      const intent = await this.determineIntent(ctx.body);
      const action = this.mapIntentToAction(intent);
      
      if (action === 'UNKNOWN') {
        await commandHandler.executeCommand('UNKNOWN', ctx, { flowDynamic, gotoFlow });
        return;
      }

      const nextState = await this.executeStateAndDetermineNext(currentState, ctx, action, { flowDynamic, gotoFlow });

      if (nextState && this.states.has(nextState)) {
        logger.logState(currentState, nextState, { userId: ctx.from, intent, action });
        userContext.setState(nextState);
        await this.executeState(nextState, ctx, action, { flowDynamic, gotoFlow });
      } else {
        await this.handleDefaultResponse(ctx, intent, { flowDynamic });
      }

    } catch (error) {
      logger.logError(`Error handling message for user ${ctx.from}`, error);
      await flowDynamic('Lo siento, ha ocurrido un error. Por favor, intenta de nuevo más tarde.');
      userContext.setState('MAIN_MENU');
    }
  }

  async determineIntent(message) {
    return await openaiService.determineIntent(message);
  }

  mapIntentToAction(intent) {
    const intentActionMap = {
      'saludo': 'GREETING',
      'lista_servicios': 'LIST_SERVICES',
      'informacion_adicional': 'ADDITIONAL_INFO',
      'cotizar': 'QUOTE',
      'realizar_pedido': 'CREATE_ORDER',
      'seleccionar_servicio': 'SELECT_SERVICE',
      'pregunta_general': 'GENERAL_QUESTION',
      'desconocido': 'UNKNOWN'
    };
    return intentActionMap[intent] || 'UNKNOWN';
  }

  async executeStateAndDetermineNext(currentState, ctx, action, { flowDynamic, gotoFlow }) {
    const stateTransitions = this.transitions.get(currentState);
    if (!stateTransitions) {
      throw new Error(`No transitions defined for state: ${currentState}`);
    }

    for (const [nextState, condition] of stateTransitions.entries()) {
      if (await condition(ctx, action)) {
        return nextState;
      }
    }

    return currentState;
  }

  async executeState(state, ctx, action, { flowDynamic, gotoFlow }) {
    const stateHandler = this.states.get(state);
    if (!stateHandler) {
      throw new Error(`No handler found for state: ${state}`);
    }
    await stateHandler(ctx, action, { flowDynamic, gotoFlow });
  }

  async handleDefaultResponse(ctx, intent, { flowDynamic }) {
    const userContext = ctx.userContext;
    const systemPrompt = this.getSystemPrompt(userContext.getState());
    const aiResponse = await openaiService.getChatCompletion(userContext, systemPrompt);
    await flowDynamic(aiResponse);
    userContext.addToHistory('assistant', aiResponse);
  }

  getSystemPrompt(state) {
    const basePrompt = "Eres un asistente virtual para una imprenta. Tu tarea es ayudar a los clientes con sus consultas sobre servicios de impresión.";
    const stateSpecificPrompt = this.getStateSpecificPrompt(state);
    return `${basePrompt} ${stateSpecificPrompt}`;
  }

  getStateSpecificPrompt(state) {
    const prompts = {
      'INITIAL': "Saluda al cliente y pregúntale en qué puedes ayudarle.",
      'MAIN_MENU': "Ayuda al cliente a elegir entre ver la lista de servicios, obtener información adicional, cotizar un servicio o realizar un pedido.",
      'LISTING_SERVICES': "Proporciona la lista de servicios disponibles de manera clara y concisa.",
      'SELECTING_SERVICE': "Ayuda al cliente a seleccionar un servicio específico del menú.",
      'PROVIDING_ADDITIONAL_INFO': "Proporciona información adicional sobre horarios, despacho, métodos de pago, etc.",
      'QUOTING': "Ayuda al cliente a obtener una cotización para un servicio específico.",
      'CREATING_ORDER': "Guía al cliente a través del proceso de creación de un pedido.",
      'GENERAL_QUESTION': "Responde a la pregunta general del cliente de la mejor manera posible.",
    };
    return prompts[state] || "Asiste al cliente con su consulta actual.";
  }
}

export const conversationManager = new ConversationManager();


// core\middleware-manager.js

import { logger } from '../utils/logger.js';

class MiddlewareManager {
  constructor() {
    this.middlewares = [];
  }

  use(middleware) {
    this.middlewares.push(middleware);
    logger.info(`Middleware registered: ${middleware.name}`);
  }

  async run(ctx, next) {
    let index = 0;
    const runner = async () => {
      if (index < this.middlewares.length) {
        await this.middlewares[index++](ctx, runner);
      } else {
        await next();
      }
    };
    await runner();
  }
}

export const middlewareManager = new MiddlewareManager();


// core\plugin-manager.js

import { logger } from '../utils/logger.js';

class PluginManager {
  constructor() {
    this.plugins = new Map();
  }

  registerPlugin(name, plugin) {
    if (this.plugins.has(name)) {
      logger.warn(`Plugin ${name} already registered. Overwriting.`);
    }
    this.plugins.set(name, plugin);
    logger.info(`Plugin ${name} registered successfully.`);
  }

  getPlugin(name) {
    if (!this.plugins.has(name)) {
      logger.error(`Plugin ${name} not found.`);
      return null;
    }
    return this.plugins.get(name);
  }

  async executePluginMethod(pluginName, methodName, ...args) {
    const plugin = this.getPlugin(pluginName);
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found.`);
    }
    if (typeof plugin[methodName] !== 'function') {
      throw new Error(`Method ${methodName} not found in plugin ${pluginName}.`);
    }
    try {
      return await plugin[methodName](...args);
    } catch (error) {
      logger.error(`Error executing method ${methodName} of plugin ${pluginName}:`, error);
      throw error;
    }
  }

  getRegisteredPlugins() {
    return Array.from(this.plugins.keys());
  }
}

export const pluginManager = new PluginManager();


// core\user-session-manager.js

import { UserContext } from '../models/user-context.js';
import { logger } from '../utils/logger.js';

class UserSessionManager {
  constructor() {
    this.sessions = new Map();
    this.sessionTimeout = 30 * 60 * 1000; // 30 minutos
  }

  getSession(userId) {
    let session = this.sessions.get(userId);
    if (!session) {
      session = new UserContext(userId);
      this.sessions.set(userId, session);
      logger.info(`New session created for user ${userId}`);
    } else {
      session.updateLastInteraction();
    }
    return session;
  }

  updateSession(userId, updates) {
    const session = this.getSession(userId);
    Object.assign(session, updates);
    logger.info(`Session updated for user ${userId}`);
  }

  clearSession(userId) {
    this.sessions.delete(userId);
    logger.info(`Session cleared for user ${userId}`);
  }

  cleanupSessions() {
    const now = Date.now();
    for (const [userId, session] of this.sessions.entries()) {
      if (now - session.lastInteraction > this.sessionTimeout) {
        this.clearSession(userId);
      }
    }
  }

  startCleanupInterval() {
    setInterval(() => this.cleanupSessions(), 5 * 60 * 1000); // Limpiar cada 5 minutos
  }
}

export const userSessionManager = new UserSessionManager();
userSessionManager.startCleanupInterval();


// middleware\error-handler.js

import { logger } from '../utils/logger.js';

export async function errorHandler(ctx, next) {
  try {
    await next();
  } catch (error) {
    logger.error('Error in request pipeline', error);
    if (ctx.flowDynamic) {
      await ctx.flowDynamic('Lo siento, ha ocurrido un error. Por favor, intenta nuevamente más tarde.');
    } else {
      logger.error('flowDynamic not available in context');
    }
  }
}


// middleware\message-processor.js

// middleware/message-processor.js
import { openaiService } from '../services/openai-service.js';
import { logger } from '../utils/logger.js';
import { pluginManager } from '../core/plugin-manager.js';

export async function messageProcessor(ctx, { flowDynamic, state }) {
  try {
    // Ejecutar plugins onMessage
    await pluginManager.executePluginMethod('examplePlugin', 'onMessage', ctx);

    if (ctx.message.hasMedia) {
      const media = await ctx.message.downloadMedia();
      if (media.mimetype.startsWith('audio/')) {
        try {
          ctx.transcription = await openaiService.transcribeAudio(Buffer.from(media.data, 'base64'));
          logger.info(`Audio transcribed for user ${ctx.from}`);
        } catch (error) {
          logger.error(`Error transcribing audio for user ${ctx.from}`, error);
        }
      } else {
        ctx.attachment = {
          filename: media.filename,
          data: media.data,
          mimetype: media.mimetype,
        };
      }
    }
  } catch (error) {
    logger.error('Error in message processor', error);
    throw error;
  }
}


// models\print-order.js

class PrintOrder {
    constructor(userId) {
      this.userId = userId;
      this.items = [];
      this.totalPrice = 0;
      this.status = 'PENDING';
    }
  
    addItem(item, quantity, price) {
      this.items.push({ item, quantity, price });
      this.calculateTotal();
    }
  
    removeItem(index) {
      this.items.splice(index, 1);
      this.calculateTotal();
    }
  
    calculateTotal() {
      this.totalPrice = this.items.reduce((total, item) => total + item.quantity * item.price, 0);
    }
  
    setStatus(status) {
      this.status = status;
    }
  
    toJSON() {
      return {
        userId: this.userId,
        items: this.items,
        totalPrice: this.totalPrice,
        status: this.status,
      };
    }
  }
  
  export { PrintOrder };


// models\user-context.js

import { PrintOrder } from './print-order.js';

class UserContext {
  constructor(userId) {
    this.userId = userId;
    this.state = 'INITIAL';
    this.cart = new PrintOrder(userId);
    this.menu = null;
    this.conversationHistory = [];
    this.lastInteraction = Date.now();
    this.selectedService = null;
  }
  addToHistory(role, content) {
    this.conversationHistory.push({ role, content });
    this.trimHistory();
    this.updateLastInteraction();
  }

  trimHistory() {
    let totalWords = 0;
    for (let i = this.conversationHistory.length - 1; i >= 0; i--) {
      totalWords += this.conversationHistory[i].content.split(' ').length;
      if (totalWords > 1500) {
        this.conversationHistory = this.conversationHistory.slice(i + 1);
        break;
      }
    }
  }

  setSelectedService(service) {
    this.selectedService = service;
    this.updateLastInteraction();
  }

  getSelectedService() {
    return this.selectedService;
  }

  getHistory() {
    return this.conversationHistory;
  }

  setState(newState) {
    this.state = newState;
    this.updateLastInteraction();
  }

  getState() {
    return this.state;
  }

  addToCart(item) {
    if (this.cart.items.length >= 5) {
      throw new Error('No se pueden agregar más de 5 servicios al carrito.');
    }
    this.cart.addItem(item);
    this.updateLastInteraction();
  }

  removeFromCart(index) {
    this.cart.removeItem(index);
    this.updateLastInteraction();
  }

  getCart() {
    return this.cart;
  }

  clearCart() {
    this.cart = new PrintOrder(this.userId);
    this.updateLastInteraction();
  }

  setMenu(menu) {
    this.menu = menu;
  }

  getMenu() {
    return this.menu;
  }

  updateLastInteraction() {
    this.lastInteraction = Date.now();
  }

  isSessionExpired(expirationTime) {
    return (Date.now() - this.lastInteraction) > expirationTime;
  }
}

export { UserContext };


// plugins\example-plugin.js

// plugins/example-plugin.js
export const examplePlugin = {
  name: 'ExamplePlugin',
  
  onMessage: async (ctx) => {
    console.log(`Mensaje recibido de ${ctx.from}: ${ctx.body}`);
  },

  onResponse: async (ctx, response) => {
    console.log(`Respuesta a enviar a ${ctx.from}: ${response}`);
  },

  customFunction: async (ctx) => {
    return `Función personalizada ejecutada para ${ctx.from}`;
  }
};


// services\file-analyzer.js

import fs from 'fs/promises';
import pdfParse from 'pdf-parse/lib/pdf-parse.js';
import fileType from 'file-type';
const { fileTypeFromBuffer } = fileType;
import { logger } from '../utils/logger.js';

class FileAnalyzer {
  async analyzeFile(fileBuffer, fileName) {
    try {
      const fileType = await fileTypeFromBuffer(fileBuffer);
      
      if (!fileType) {
        return "No se pudo determinar el tipo de archivo.";
      }

      switch (fileType.mime) {
        case 'application/pdf':
          return await this.analyzePdf(fileBuffer);
        case 'text/plain':
          return await this.analyzeTextFile(fileBuffer);
        case 'image/jpeg':
        case 'image/png':
          return await this.analyzeImage(fileBuffer, fileType.mime);
        default:
          return `Archivo recibido: ${fileName}. Tipo: ${fileType.mime}. No se puede analizar este tipo de archivo.`;
      }
    } catch (error) {
      logger.error('Error analyzing file', error);
      return "Ocurrió un error al analizar el archivo.";
    }
  }

  async analyzePdf(buffer) {
    try {
      const data = await pdfParse(buffer);
      return `PDF analizado. Número de páginas: ${data.numpages}. Texto extraído: ${data.text.substring(0, 200)}...`;
    } catch (error) {
      logger.error('Error analyzing PDF', error);
      return "Ocurrió un error al analizar el archivo PDF.";
    }
  }

  async analyzeTextFile(buffer) {
    const text = buffer.toString('utf-8');
    return `Archivo de texto analizado. Primeros 200 caracteres: ${text.substring(0, 200)}...`;
  }

  async analyzeImage(buffer, mimeType) {
    return `Imagen ${mimeType} recibida. Tamaño: ${buffer.length} bytes.`;
  }
}

export const fileAnalyzer = new FileAnalyzer();


// services\openai-service.js

// services/openai-service.js

import OpenAI from 'openai';
import config from '../config/index.js';
import { logger } from '../utils/logger.js';

class OpenAIService {
  constructor() {
    this.client = new OpenAI({ apiKey: config.openai.apiKey });
  }

  async initialize() {
    logger.info('OpenAI service initialized');
  }

  async getChatCompletion(userContext, newMessage) {
    const messages = [
      { role: 'system', content: this.getSystemPrompt() },
      ...userContext.getHistory(),
      { role: 'user', content: newMessage }
    ];

    try {
      const response = await this.client.chat.completions.create({
        model: config.openai.model,
        messages: messages,
        max_tokens: 150
      });

      const aiResponse = response.choices[0].message.content.trim();
      return aiResponse;
    } catch (error) {
      logger.error('Error getting chat completion from OpenAI', error);
      throw error;
    }
  }

  getSystemPrompt() {
    return `Eres un asistente virtual para una imprenta. Tu tarea es ayudar a los clientes a cotizar servicios de impresión, proporcionar información sobre servicios, y asistir en el proceso de pedidos. Sé amable, profesional y directo en tus respuestas.`;
  }

  async determineIntent(message) {
    const prompt = `Determina la intención del usuario basada en el siguiente mensaje. Las posibles intenciones son: saludo, lista_servicios, informacion_adicional, cotizar, realizar_pedido, seleccionar_servicio, pregunta_general, o desconocido. Responde solo con la intención, sin explicación adicional.

Mensaje del usuario: "${message}"

Intención:`;

    try {
      const response = await this.client.chat.completions.create({
        model: config.openai.model,
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 10,
        temperature: 0.3,
      });

      const intent = response.choices[0].message.content.trim().toLowerCase();
      return ['saludo', 'lista_servicios', 'informacion_adicional', 'cotizar', 'realizar_pedido', 'seleccionar_servicio', 'pregunta_general', 'desconocido'].includes(intent) ? intent : 'desconocido';
    } catch (error) {
      logger.error('Error determining intent with OpenAI:', error);
      return 'desconocido';
    }
  }

  async transcribeAudio(audioBuffer) {
    try {
      const response = await this.client.audio.transcriptions.create({
        file: audioBuffer,
        model: 'whisper-1',
      });
      return response.text;
    } catch (error) {
      logger.error('Error in audio transcription', error);
      throw error;
    }
  }
}

export const openaiService = new OpenAIService();


// services\printing-calculator.js

import { ValidationError } from '../utils/error-types.js';

class PrintingCalculator {
  calculatePrice(order, serviceDetails) {
    let total = 0;
    for (const item of order.items) {
      const itemDetails = serviceDetails.find(s => s.id === item.id);
      if (!itemDetails) {
        throw new ValidationError(`Servicio no encontrado: ${item.id}`);
      }
      
      const basePrice = this.calculateBasePrice(item, itemDetails);
      const finishingsPrice = this.calculateFinishingsPrice(item, itemDetails);
      const quantity = item.quantity || 1;
      
      total += (basePrice + finishingsPrice) * quantity;
    }
    return total;
  }

  calculateBasePrice(item, itemDetails) {
    if (itemDetails.priceType === 'fixed') {
      return itemDetails.basePrice;
    } else if (itemDetails.priceType === 'perSquareMeter') {
      const area = (item.width * item.height) / 10000; // convert cm² to m²
      return itemDetails.basePrice * area;
    }
    throw new ValidationError(`Tipo de precio no soportado: ${itemDetails.priceType}`);
  }

  calculateFinishingsPrice(item, itemDetails) {
    let finishingsPrice = 0;
    if (item.finishings) {
      for (const [finishing, isSelected] of Object.entries(item.finishings)) {
        if (isSelected && itemDetails.finishings[finishing]) {
          finishingsPrice += itemDetails.finishings[finishing];
        }
      }
    }
    return finishingsPrice;
  }

  formatOrderSummary(order, serviceDetails) {
    let summary = "Resumen del pedido:\n";
    let total = 0;

    for (const item of order.items) {
      const itemDetails = serviceDetails.find(s => s.id === item.id);
      if (!itemDetails) {
        throw new ValidationError(`Servicio no encontrado: ${item.id}`);
      }

      const basePrice = this.calculateBasePrice(item, itemDetails);
      const finishingsPrice = this.calculateFinishingsPrice(item, itemDetails);
      const itemTotal = (basePrice + finishingsPrice) * item.quantity;

      summary += `- ${itemDetails.name}: ${item.quantity} x $${basePrice.toFixed(2)}\n`;
      if (finishingsPrice > 0) {
        summary += `  Acabados: $${finishingsPrice.toFixed(2)}\n`;
      }
      summary += `  Subtotal: $${itemTotal.toFixed(2)}\n\n`;

      total += itemTotal;
    }

    summary += `Total: $${total.toFixed(2)}`;
    return summary;
  }
}

export const printingCalculator = new PrintingCalculator();


// services\sheets-service.js

// services/sheets-service.js

import { JWT } from 'google-auth-library';
import { GoogleSpreadsheet } from 'google-spreadsheet';
import moment from 'moment-timezone';
import 'moment/locale/es.js';
import { logger } from '../utils/logger.js';
import config from '../config/index.js';

class SheetsService {
  constructor() {
    this.jwtFromEnv = new JWT({
      email: config.googleSheets.credentials.client_email,
      key: config.googleSheets.credentials.private_key.replace(/\\n/g, "\n"),
      scopes: [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
      ],
    });
    this.doc = new GoogleSpreadsheet(config.googleSheets.sheetId, this.jwtFromEnv);
    moment.locale('es');
  }

  async initialize() {
    try {
      await this.doc.loadInfo();
      logger.info('Google Sheets service initialized');
    } catch (error) {
      logger.error('Error initializing Google Sheets', error);
      throw error;
    }
  }

  async getServices() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[0];
      await sheet.loadCells('A1:Q100');
  
      let services = {};
  
      let currentCategory = null;
      for (let row = 1; row < sheet.rowCount; row++) {
        const id = sheet.getCell(row, 0).value;
        if (!id) break;
        
        const category = sheet.getCell(row, 1).value;
        if (category) currentCategory = category;

        const service = {
          id: id,
          categoria: currentCategory,
          tipo: sheet.getCell(row, 2).value,
          nombre: sheet.getCell(row, 3).value,
          sellado: sheet.getCell(row, 4).value,
          ojetillos: sheet.getCell(row, 5).value,
          bolsillo: sheet.getCell(row, 6).value,
          formato: sheet.getCell(row, 7).value || 'PDF, JPG',
          dpi: 72,
          stock: sheet.getCell(row, 9).value,
          estado: sheet.getCell(row, 10).value,
          precio: sheet.getCell(row, 11).value,
          medidas: sheet.getCell(row, 12).value,
          precioSellado: sheet.getCell(row, 14).value,
          precioBolsillo: sheet.getCell(row, 15).value,
          precioOjetillo: sheet.getCell(row, 16).value
        };

        if (!services[currentCategory]) services[currentCategory] = [];
        services[currentCategory].push(service);
      }
  
      return services;
    } catch (error) {
      logger.error('Error fetching services from Google Sheets', error);
      throw error;
    }
  }

  async getFormattedServiceList() {
    const services = await this.getServices();
    let formattedList = "Lista de servicios disponibles:\n\n";
    
    for (const [category, categoryServices] of Object.entries(services)) {
      formattedList += `*${category}*:\n`;
      categoryServices.forEach(service => {
        formattedList += `- ${service.nombre}: $${service.precio}\n`;
      });
      formattedList += "\n";
    }
    
    return formattedList;
  }

  async saveOrder(order) {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1];
      
      const formattedDate = moment().tz('America/Santiago').format('DD-MM-YYYY HH:mm[hrs] - dddd');
      const censoredPhone = this.censorPhoneNumber(order.telefono);
  
      const rowData = [
        formattedDate,
        censoredPhone,
        order.nombre,
        order.email,
        order.detalles,
        order.archivos,
        order.observaciones,
        order.total,
        "Nuevo pedido"
      ];
  
      const result = await sheet.addRows([rowData]);
      
      if (result && result.length > 0) {
        const rowIndex = result[0].rowIndex || result[0]._rowNumber || sheet.rowCount;
        logger.info(`Order saved successfully. Row ID: ${rowIndex}`);
        return { success: true, message: "Pedido guardado exitosamente", rowIndex: rowIndex };
      } else {
        logger.warn("Could not get information about the added row");
        return { success: true, message: "Pedido guardado exitosamente, pero no se pudo obtener el ID de la fila" };
      }
    } catch (error) {
      logger.error('Error saving order to Google Sheets', error);
      throw error;
    }
  }

  async getAdditionalInfo() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[2];
      await sheet.loadCells('A1:G11');
  
      const additionalInfo = {
        horarios: {},
        comunasDespacho: [],
        direccionRetiro: '',
        promocionDia: '',
        metodosPago: '',
        tiempoPreparacion: ''
      };
  
      ['Lunes a viernes', 'Sábados', 'Domingos'].forEach((dia, index) => {
        const horario = sheet.getCell(index + 1, 0).value;
        additionalInfo.horarios[dia] = horario || 'No disponible';
      });
  
      for (let row = 1; row <= 9; row++) {
        const comuna = sheet.getCell(row, 1).value;
        if (comuna && comuna.trim()) additionalInfo.comunasDespacho.push(comuna.trim());
      }
  
      additionalInfo.direccionRetiro = sheet.getCell(1, 3).value || 'No disponible';
      additionalInfo.promocionDia = sheet.getCell(1, 4).value || 'No hay promociones actualmente';
      additionalInfo.metodosPago = sheet.getCell(1, 5).value || 'No especificado';
      additionalInfo.tiempoPreparacion = sheet.getCell(1, 6).value || 'No especificado';
  
      return additionalInfo;
    } catch (error) {
      logger.error('Error fetching additional info from Google Sheets', error);
      throw error;
    }
  }

  async getFormattedAdditionalInfo() {
    const info = await this.getAdditionalInfo();
    let formattedInfo = "Información adicional:\n\n";
    
    formattedInfo += "*Horarios*:\n";
    for (const [dia, horario] of Object.entries(info.horarios)) {
      formattedInfo += `${dia}: ${horario}\n`;
    }
    
    formattedInfo += "\n*Comunas de despacho*:\n";
    formattedInfo += info.comunasDespacho.join(", ") + "\n";
    
    formattedInfo += `\n*Dirección de retiro*: ${info.direccionRetiro}\n`;
    formattedInfo += `*Promoción del día*: ${info.promocionDia}\n`;
    formattedInfo += `*Métodos de pago*: ${info.metodosPago}\n`;
    formattedInfo += `*Tiempo de preparación*: ${info.tiempoPreparacion}\n`;
    
    return formattedInfo;
  }

  censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) return phoneNumber;
    return phoneNumber.slice(0, 2) + '*'.repeat(phoneNumber.length - 5) + phoneNumber.slice(-3);
  }
}

export const sheetsService = new SheetsService();


// utils\error-types.js

class ApplicationError extends Error {
    constructor(message, status) {
      super(message);
      this.name = this.constructor.name;
      this.status = status || 500;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  class ValidationError extends ApplicationError {
    constructor(message) {
      super(message || 'Validation Error', 400);
    }
  }
  
  class NotFoundError extends ApplicationError {
    constructor(message) {
      super(message || 'Resource Not Found', 404);
    }
  }
  
  class UnauthorizedError extends ApplicationError {
    constructor(message) {
      super(message || 'Unauthorized', 401);
    }
  }
  
  export { ApplicationError, ValidationError, NotFoundError, UnauthorizedError };


// utils\logger.js

// utils/logger.js

import winston from 'winston';
import config from '../config/index.js';
import moment from 'moment-timezone';

// Configurar el formato de fecha para Chile
moment.tz.setDefault("America/Santiago");

const customFormat = winston.format.printf(({ level, message, timestamp, ...metadata }) => {
  const formattedDate = moment(timestamp).format('YYYY-MM-DD HH:mm:ss');
  let msg = `${formattedDate} - ${level.toUpperCase()} - ${message}`;
  
  if (Object.keys(metadata).length > 0 && metadata.service !== 'print-bot') {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  
  return msg;
});

const logger = winston.createLogger({
  level: config.logging.level,
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    customFormat
  ),
  defaultMeta: { service: 'print-bot' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        customFormat
      )
    }),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Sobrescribir los métodos de logging para asegurar el formato correcto
['error', 'warn', 'info', 'debug'].forEach((level) => {
  logger[level] = function (message, metadata) {
    const formattedDate = moment().format('YYYY-MM-DD HH:mm:ss');
    console.log(`${formattedDate} - ${level.toUpperCase()} - ${message}`, metadata);
    winston.log(level, message, metadata);
  };
});

logger.logError = (message, error) => {
  const formattedDate = moment().format('YYYY-MM-DD HH:mm:ss');
  console.error(`${formattedDate} - ERROR - ${message}: ${error.message}`, { 
    stack: error.stack,
    metadata: error
  });
  logger.error(`${message}: ${error.message}`, { 
    stack: error.stack,
    metadata: error
  });
};

logger.logState = (currentState, nextState, context) => {
  const formattedDate = moment().format('YYYY-MM-DD HH:mm:ss');
  console.log(`${formattedDate} - INFO - State transition: ${currentState} -> ${nextState}`, context);
  logger.info(`State transition: ${currentState} -> ${nextState}`, context);
};

export { logger };


// utils\validators.js

import { ValidationError } from './error-types.js';

export const validators = {
  validateMeasurements(width, height, serviceDetails) {
    if (width <= 0 || height <= 0) {
      throw new ValidationError('Las medidas deben ser números positivos.');
    }
    if (serviceDetails.maxWidth && width > serviceDetails.maxWidth) {
      throw new ValidationError(`El ancho máximo permitido es ${serviceDetails.maxWidth}cm.`);
    }
    if (serviceDetails.maxHeight && height > serviceDetails.maxHeight) {
      throw new ValidationError(`El alto máximo permitido es ${serviceDetails.maxHeight}cm.`);
    }
  },

  validateFinishings(finishings, serviceDetails) {
    for (const [finishing, isSelected] of Object.entries(finishings)) {
      if (isSelected && !serviceDetails.finishings[finishing]) {
        throw new ValidationError(`El acabado "${finishing}" no está disponible para este servicio.`);
      }
    }
  },

  validateQuantity(quantity, serviceDetails) {
    if (quantity <= 0 || !Number.isInteger(quantity)) {
      throw new ValidationError('La cantidad debe ser un número entero positivo.');
    }
    if (serviceDetails.maxQuantity && quantity > serviceDetails.maxQuantity) {
      throw new ValidationError(`La cantidad máxima permitida es ${serviceDetails.maxQuantity}.`);
    }
  },

  validateFile(file, serviceDetails) {
    if (!file) {
      throw new ValidationError('Debe proporcionar un archivo.');
    }
    if (!serviceDetails.allowedFileTypes.includes(file.mimetype)) {
      throw new ValidationError(`Tipo de archivo no permitido. Tipos permitidos: ${serviceDetails.allowedFileTypes.join(', ')}`);
    }
    if (file.size > serviceDetails.maxFileSize) {
      throw new ValidationError(`El archivo excede el tamaño máximo permitido de ${serviceDetails.maxFileSize / (1024 * 1024)}MB.`);
    }
  }
};

