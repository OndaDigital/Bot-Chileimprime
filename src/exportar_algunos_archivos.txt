
// Archivo: app.js

import "dotenv/config";
import flowManager from './modules/flowManager.js';
import whatsappService from './services/whatsappService.js';
import sheetService from './services/sheetService.js';
import logger from './utils/logger.js';
import createMiddleware from './core/middleware.js';
import logMiddleware from './core/log-middleware.js';
import userContextManager from './modules/userContext.js';
import config from './config/config.js';
import { errorHandler } from './utils/errorHandler.js';
import fileValidationService from './services/fileValidationService.js';

const middleware = createMiddleware([logMiddleware]);

const initializeServices = async () => {
  let services = null;
  let additionalInfo = null;

  try {
    await sheetService.initialize();

    services = await sheetService.getServices();
    additionalInfo = await sheetService.getAdditionalInfo();
    
    if (services && additionalInfo) {
      userContextManager.setGlobalData(services, additionalInfo);
      logger.info("Servicios e información adicional inicializados correctamente");
    } else {
      throw new Error("No se pudieron obtener los servicios o la información adicional");
    }
  } catch (error) {
    logger.error(`Error al inicializar servicios: ${error.message}`);
    logger.warn("Iniciando con funcionalidad reducida");
  }

  return { services, additionalInfo };
};

const main = async () => {
  try {
    const { services, additionalInfo } = await initializeServices();

    const flows = await flowManager.initializeFlows();

    flows.forEach(flow => {
      flow.addAction(middleware);
    });

    await whatsappService.initialize(flows);

    logger.info('Bot inicializado correctamente');

    if (services && additionalInfo) {
      logger.info('Bot iniciado con todas las funcionalidades');
    } else {
      logger.warn('Bot iniciado con funcionalidad reducida. Algunas características pueden no estar disponibles.');
    }

    // Configurar actualización periódica de los servicios y la información adicional
    setInterval(async () => {
      try {
        await sheetService.reinitialize();
        const updatedServices = await sheetService.getServices();
        const updatedAdditionalInfo = await sheetService.getAdditionalInfo();
        if (updatedServices && updatedAdditionalInfo) {
          userContextManager.setGlobalData(updatedServices, updatedAdditionalInfo);
          logger.info("Servicios e información adicional actualizados correctamente");
        } else {
          logger.warn("No se pudieron actualizar los servicios o la información adicional");
        }
      } catch (error) {
        logger.error(`Error al actualizar servicios e información adicional: ${error.message}`);
      }
    }, config.servicesUpdateInterval);

  } catch (error) {
    logger.error(`Error crítico al inicializar el bot: ${error.message}`);
    process.exit(1);
  }
};

main().catch(err => {
  logger.error('Error fatal en main:', err);
  process.exit(1);
});

// Manejo de errores no capturados
process.on('uncaughtException', (error) => {
  logger.error(`Uncaught Exception: ${error.message}`);
  // Implementar lógica adicional si es necesario (por ejemplo, reiniciar el bot)
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error(`Unhandled Rejection at: ${promise}, reason: ${reason}`);
  // Implementar lógica adicional si es necesario
});


// Archivo: commandProcessor.js

import logger from './utils/logger.js';
import userContextManager from './modules/userContext.js';
import orderManager from './modules/orderManager.js';
import openaiService from './services/openaiService.js';
import config from './config/config.js';
import sheetService from './services/sheetService.js'
import { formatPrice, sendSplitMessages } from './utils/helpers.js';
import { normalizeCommand, findClosestCommand, sanitizeJsonString } from './utils/commandUtils.js';
import { CustomError } from './utils/errorHandler.js';

class CommandProcessor {
  constructor() {}

  async processCommand(command, userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Procesando comando para usuario ${userId}: ${JSON.stringify(command)}`);

      // Normalizar y corregir el comando
      const normalizedCommand = normalizeCommand(command.command);
      const correctedCommand = findClosestCommand(normalizedCommand) || normalizedCommand;
      
      logger.info(`Comando normalizado: ${normalizedCommand}, Comando corregido: ${correctedCommand}`);
      
      if (correctedCommand !== command.command) {
        logger.warn(`Comando corregido de "${command.command}" a "${correctedCommand}"`);
      }

      switch (correctedCommand) {
        case "LIST_ALL_SERVICES":
          return this.handleListAllServices(userId);
        case "SELECT_SERVICE":
          return this.handleSelectService(userId, command.service);
        case "SET_MEASURES":
          return this.handleSetMeasures(userId, command.width, command.height);
        case "SET_QUANTITY":
          return this.handleSetQuantity(userId, command.quantity);
        case "SET_FINISHES":
          return this.handleSetFinishes(userId, command.sellado, command.ojetillos, command.bolsillo);
        case "RESULT_ANALYSIS":
            return this.handleAnalysisResult(userId, command.result);
        case "CONFIRM_ORDER":
          return this.handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow });
        default:
          logger.warn(`Comando desconocido recibido: ${command.command}`);
          return { currentOrderUpdated: false };
      }
    } catch (error) {
      logger.error(`Error al procesar comando: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  // Nuevo método para manejar RESULT_ANALYSIS
  async handleAnalysisResult(userId, result) {
    try {
      const isValid = result === true || result === "true";
      userContextManager.updateCurrentOrder(userId, { fileValidation: isValid });
      logger.info(`Resultado del análisis actualizado para usuario ${userId}: ${isValid}`);
      return { currentOrderUpdated: true };
    } catch (error) {
      logger.error(`Error al actualizar resultado del análisis para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetQuantity(userId, quantity) {
    try {
      const result = await orderManager.handleSetQuantity(userId, quantity);
      logger.info(`Cantidad establecida para usuario ${userId}: ${quantity}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetFinishes(userId, sellado, ojetillos, bolsillo) {
    try {
      const result = await orderManager.setFinishes(userId, sellado, ojetillos, bolsillo);
      logger.info(`Acabados establecidos para usuario ${userId}: sellado=${sellado}, ojetillos=${ojetillos}, bolsillo=${bolsillo}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetMeasures(userId, width, height) {
    try {
      const result = await orderManager.handleSetMeasures(userId, width, height);
      logger.info(`Medidas establecidas para usuario ${userId}: ${width}x${height}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleFileAnalysis(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);
    const fileAnalysis = currentOrder.fileAnalysis;
 
    if (!fileAnalysis) {
      await flowDynamic("Lo siento, parece que no hay un archivo para analizar. Por favor, envía un archivo primero.");
      return;
    }
 
    logger.info(`Iniciando análisis de archivo para usuario ${userId}`);
    let response = "He analizado tu archivo. Aquí están los resultados:\n\n";
    response += `📄 Formato: *${fileAnalysis.format}*\n`;
    response += `📏 Dimensiones en píxeles: *${fileAnalysis.width}x${fileAnalysis.height}*\n`;
   
    const widthM = fileAnalysis.physicalWidth.toFixed(2);
    const heightM = fileAnalysis.physicalHeight.toFixed(2);
    response += `📐 Dimensiones físicas: *${widthM}x${heightM} m* (${(widthM*100).toFixed(2)}x${(heightM*100).toFixed(2)} cm)\n`;
   
    response += `📊 Área del diseño: *${fileAnalysis.area} m²*\n`;
    response += `🔍 Resolución: *${fileAnalysis.dpi} DPI*\n`;
   
    if (fileAnalysis.colorSpace) {
      response += `🎨 Espacio de color: *${fileAnalysis.colorSpace}*\n`;
    }
   
    if (fileAnalysis.fileSize) {
      response += `📦 Tamaño del archivo: *${fileAnalysis.fileSize}*\n`;
    }
 
    logger.info(`Análisis de archivo completado para usuario ${userId}: ${JSON.stringify(fileAnalysis)}`);
    await flowDynamic(response);
    userContextManager.updateFileAnalysisResponded(userId, true);

    // Generar y enviar el segundo mensaje
    await this.handleFileValidationInstruction(ctx, flowDynamic);
  }

  async handleFileValidationInstruction(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);

    // Verificar que el currentOrder está actualizado
    if (!currentOrder.service || (!currentOrder.measures && currentOrder.requiresMeasures())) {
      // Solicitar la información faltante al usuario
      await flowDynamic("Parece que falta información en tu pedido. Por favor, asegúrate de haber proporcionado el servicio y las medidas necesarias.");
      return;
    }

    // Información detallada sobre la importancia del DPI según el área y la distancia de visualización
    // Información detallada sobre la importancia del DPI según el área y la distancia de visualización
    const dpiGuidelines = `
    📏 **Resolución (DPI) según el Área y Distancia de Visualización** 📐

    Ten en cuenta lo siguiente sobre la resolución (DPI) en función del área del servicio *${currentOrder.areaServicio} m²* y la distancia de visualización, aplicando a productos específicos de *Chileimprime*:

    - **Áreas pequeñas (menos de 1.0 m²)** 🖼️:
      - Se recomienda una resolución de *150-300 DPI* para obtener alta calidad.
      - Ideal para productos como *Tarjetas de presentación (1000 unidades)*, *Flyers 15×22 cms*, y *Mini Roller de escritorio papel sintético*, los cuales se observan de cerca (distancia menor a *1.5 metros*).

    - **Áreas medianas (1.5 m² a 5 m²)** 📊:
      - La resolución puede oscilar entre *72 y 150 DPI*.
      - Adecuada para *Pendones Roller 90x200 cms*, *Palomas 2 caras 70x120 cms*, y *PVC 11 Oz mt²*, que se visualizan desde distancias intermedias (*1.5 a 3 metros*).

    - **Áreas grandes (5 m² a 10 m²)** 📢:
      - Se recomienda una resolución entre *35 y 72 DPI*.
      - Ideal para *Back Light Banner*, *Tela Mesh* y *PVC Blackout*, que se verán a distancias de *3 a 5 metros*.

    - **Áreas muy grandes (más de 10 m²)** 🏢:
      - Resoluciones bajas, entre *20 y 35 DPI*, son aceptables debido a que estos gráficos se ven desde distancias mayores a *5 metros*.
      - Ejemplos: *Murales publicitarios*, *Back Light Textil*, o *Windows One Vision* que serán observados a grandes distancias.

    ### 📌 Notas Adicionales:
    1. **Distancia de Visualización** 👀: Es un factor crítico para determinar el DPI correcto. A mayor distancia, menor es la necesidad de alta resolución, ya que el ojo humano no distingue los detalles finos.
    2. **Tamaño del Archivo** 💾: Usar resoluciones demasiado altas en áreas grandes como *PVC Alta Definición* para grandes formatos incrementa significativamente el tamaño del archivo y el tiempo de impresión sin una mejora perceptible en la calidad visual.
    3. **Material Específico** 🧱: Productos como *Adhesivo Empavonado*, *Vinilo Adhesivo Reflectante* y *Rotulación para fundido* requieren considerar el material y su capacidad de impresión, por lo que es recomendable mantener el DPI en el rango medio de *72-150 DPI* para garantizar una buena nitidez.

    ✨ **Emojis y Formateo**:
    - Utiliza emojis relevantes para resaltar puntos importantes.
    - Aplica **formateo con asteriscos** usando un asterisco por lado (*texto*) para resaltar palabras clave.
    - Asegúrate de mantener una estructura clara con saltos de línea para facilitar la lectura en WhatsApp.

    Estas guías te ayudarán a optimizar la calidad y la eficiencia en cada proyecto de impresión según el tipo de producto y su aplicación en el mercado chileno.
    `;

    // Generar la instrucción para la IA con mayor contexto y flexibilidad
    const instruction = `🔄 **Nueva Solicitud de Archivo** 📂

    El usuario acaba de subir un archivo. Ahora eres un **experto en impresión de gran formato** e **ingeniero en color**. Verifica el *currentOrder* y responde según las siguientes condiciones:

    1. 📐 **Análisis del Archivo**:
      - Analiza el archivo proporcionado considerando una tolerancia del *20%* en cuanto a las medidas y el área del diseño comparado con el servicio solicitado.
      - Ten mucho cuidado con el area del servicio con respecto al area del diseño

    2. 📊 **Directrices de DPI**:
      - Ten en cuenta las siguientes directrices para el DPI:
      <dpiGuidelines>${dpiGuidelines}</dpiGuidelines>
      
    3. 🛠️ **Casos Especiales**:
      - Considera que en casos especiales, como areas muy grandes que superan las limitaciones técnicas, como areas que superen los 5m2, es aceptable reducir la exigencia de DPI hasta 30 o menos para adaptar el diseño a las dimensiones fisicas,
      tu eres el experto que decide el DPI correcto que debe tener el diseño en funcion al las guias de <dpiGuidelines>. Y ten cuidado de que para areas muy grandes de impresion, debes pedir que los archivos tambien tengan alta resolucion,
      verifica la resolucion del archivo enviado por el cliente y en caso de que no cumpla con su area de impresion pero si con los DPI darle los pasos para corregir su archivo.
      
    4. 🧐 **Evaluación de Adecuación**:
      - Aplica tu expertise en impresión para evaluar si el archivo es adecuado, incluso si no cumple exactamente con los criterios, pero está dentro de la tolerancia del *20%*.
      
    5. ✅ **Validación del Archivo**:
      - Si el archivo es válido o puede ser aceptado con modificaciones menores, indica que es válido.
      
    6. ❌ **Invalidez del Archivo**:
      - Si el archivo no es válido, proporciona una explicación detallada y consejos específicos para que el cliente pueda corregirlo.

    📋 **Información para la Validación**:
    - **Servicio seleccionado**: *${currentOrder.service}*
    - **Área del servicio solicitado**: *${currentOrder.areaServicio ? currentOrder.areaServicio.toFixed(2) : 'No disponible'} m²*
    - **Área del diseño proporcionado**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.area.toFixed(2) : 'No disponible'} m²*
    - **Resolución del diseño**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.dpi : 'No disponible'} dpi*
    - **Formato del diseño**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.format : 'No disponible'}*
    - **Espacio de color del diseño**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.colorSpace : 'No disponible'}*

    📑 **Criterios de Validación**:
    ${userContextManager.getFileValidationCriteria()}

    ⚠️ **IMPORTANTE**:
    - Al inicio de tu respuesta, incluye un comando JSON indicando el resultado del análisis, en el siguiente formato:
      {"command": "RESULT_ANALYSIS", "result": true/false}
    - Luego, proporciona la respuesta al usuario siguiendo un formato fijo de 3 secciones, separadas por encabezados "### ":
      1. ### 🔍 Criterios de Validación Aplicados:
        - Explica brevemente los criterios que aplicaste en este caso específico.
      2. ### {EMOJI de cruz o check dependiendo del resultado} Resultado de la Validación:
        - Indica si el archivo es válido o no, y proporciona detalles, sobretodo si el resultado es negativo,
          explica y brinda detalladamente lo que debe hacer el cliente para que su archivo sea valido para su impresion en funcion al area de impresion.
      3. ### 👉 Siguiente Paso:
        - Indica al usuario cuál es el siguiente paso en el proceso.

    - Asegúrate de que tu respuesta siga este formato exactamente, para que pueda ser dividida en mensajes separados.
    - **Incluye emojis y utiliza asteriscos para el formateo** en toda tu respuesta para mejorar la interacción en WhatsApp.

    Responde al usuario siguiendo estas indicaciones.
    `;


    // Log para depuración
    logger.info(`Enviando instrucción a la IA para validación de archivo para usuario ${userId}: ${instruction}`);

    const aiResponse = await openaiService.getChatCompletion(
      openaiService.getSystemPrompt(userContextManager.getGlobalServices(), currentOrder, userContextManager.getGlobalAdditionalInfo(), userContextManager.getChatContext(userId)),
      userContextManager.getChatContext(userId).concat({ role: "system", content: instruction })
    );

    // Actualizar el contexto de chat
    userContextManager.updateContext(userId, instruction, "system");
    userContextManager.updateContext(userId, aiResponse, "assistant");

    // Log de la respuesta de la IA
    logger.info(`Respuesta de la IA para validación de archivo para usuario ${userId}: ${aiResponse}`);

    // Procesar comandos en la respuesta de la IA
    const commands = this.processAIResponseCommandProcessor(aiResponse);
    for (const command of commands) {
      await this.processCommand(command, userId, ctx, { flowDynamic });
    }

    // Enviar los mensajes divididos al usuario
    await sendSplitMessages(flowDynamic, aiResponse);
  }

  processAIResponseCommandProcessor(aiResponse) {
    const commandRegex = /{[^}]+}/g;
    const commands = aiResponse.match(commandRegex) || [];
    return commands.map(cmd => {
      try {
        const sanitizedCmd = sanitizeJsonString(cmd);
        logger.debug(`Comando sanitizado: ${sanitizedCmd}`);
        const parsedCmd = JSON.parse(sanitizedCmd);
        logger.info(`Comando parseado correctamente: ${JSON.stringify(parsedCmd)}`);
        return parsedCmd;
      } catch (error) {
        logger.error(`Error al parsear comando JSON: ${error.message}`);
        logger.debug(`Comando problemático: ${cmd}`);
        return null;
      }
    }).filter(cmd => cmd !== null);
  }
  

  async handleListAllServices(userId, actions) {
    const services = sheetService.getServices();
    const formattedServices = this.formatServiceList(services);
    logger.info(`Lista de servicios preparada para usuario ${userId}`);
    
    return { 
      currentOrderUpdated: true, 
      action: 'SHOW_SERVICES',
      data: formattedServices
    };
  }

  formatServiceList(services) {
    let formattedList = "Aquí tienes la lista completa de servicios disponibles:\n\n";

    const categoryEmojis = {
      'Telas PVC': '🖼️',
      'Banderas': '🚩',
      'Adhesivos': '🏷️',
      'Adhesivo Vehicular': '🚗',
      'Back Light': '💡',
      'Otros': '📦',
      'Imprenta': '🖨️',
      'Péndon Roller': '🎞️',
      'Palomas': '🐦',
      'Figuras': '🔺',
      'Extras': '➕'
    };

    for (const [category, categoryServices] of Object.entries(services)) {
      const emojiIcon = categoryEmojis[category] || '';
      formattedList += `${emojiIcon} *${category}:*\n`;

      categoryServices.forEach(service => {
        const serviceName = service.name;
        const priceFormatted = formatPrice(service.precio);
        const priceBold = `*$${
          priceFormatted
        }*`; // Envuelve el precio con asteriscos para negrita
        formattedList += `- ${serviceName}: ${priceBold}\n`;
      });
      formattedList += "\n";
    }

    formattedList += "Para obtener más información sobre un servicio específico, por favor menciona su nombre.";
    return formattedList;
  }

  async handleSelectService(userId, serviceName) {
    if (!serviceName) {
      logger.warn(`Nombre de servicio inválido: ${serviceName}`);
      await flowDynamic('Parece que no has especificado un servicio válido. Por favor, indícanos qué servicio deseas.');
      return { currentOrderUpdated: false, error: 'El nombre del servicio es inválido o no se proporcionó.' };
    }

    try {
      const result = await orderManager.handleSelectService(userId, serviceName);
      logger.info(`Servicio seleccionado para usuario ${userId}: ${serviceName}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      await flowDynamic(`Lo siento, ha ocurrido un error al seleccionar el servicio. ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Iniciando proceso de confirmación de orden para usuario ${userId}`);

      // Modificación: Verificar si la orden ya está confirmada
      if (orderManager.isOrderConfirmed(userId)) {
        logger.warn(`La orden para el usuario ${userId} ya ha sido confirmada. Evitando doble confirmación.`);
        await flowDynamic("✅ Tu pedido ya ha sido confirmado previamente. Si necesitas asistencia adicional, por favor contacta con un representante.");
        return { currentOrderUpdated: false };
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        const missingFields = userContextManager.getIncompleteFields(userId);
        const errorMessage = `La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
        logger.warn(errorMessage);
        throw new CustomError('IncompleteOrderError', errorMessage);
      }
  
      // Añadir información del contexto
      currentOrder.userName = ctx.pushName || 'Cliente';
      currentOrder.userPhone = ctx.from;
  
      // Calcular precios y actualizar la orden
      const calculatedPrices = orderManager.calculatePrice(currentOrder);
      currentOrder.precioTerminaciones = calculatedPrices.precioTerminaciones;
      currentOrder.precioTotalTerminaciones = calculatedPrices.precioTotalTerminaciones;
      currentOrder.total = calculatedPrices.total;
  
      logger.info(`Precios calculados para la orden: ${JSON.stringify(calculatedPrices)}`);
  
      const result = await orderManager.finalizeOrder(userId, currentOrder);
      
      if (result.success) {
        logger.info(`Pedido confirmado para usuario ${userId}. Número de pedido: ${result.orderNumber}`);

        // Modificación: Enviar resumen de la orden
        const orderSummary = orderManager.formatOrderSummary(currentOrder);
        await flowDynamic(`🎉 ¡Gracias por tu pedido! Tu número de cotización es: *WA-${result.orderNumber}*`);
        await flowDynamic(orderSummary);
        await flowDynamic(result.message);

        return { currentOrderUpdated: true, nextFlow: 'promoFlow' };
      } else {
        throw new Error("Error al confirmar el pedido");
      }
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      if (error.name === 'IncompleteOrderError') {
        const systemMessage = `Campos faltantes: ${error.message}`;
        userContextManager.updateContext(userId, systemMessage, "system");
        await flowDynamic("Lo siento, pero parece que falta información en tu pedido. Por favor, completa todos los detalles antes de confirmar.");
        return { currentOrderUpdated: false, error: error.message };
      } else {
        await flowDynamic("Lo siento, ha ocurrido un error al procesar tu pedido. Por favor, intenta nuevamente o contacta con nuestro equipo de soporte.");
        return { currentOrderUpdated: false, error: error.message };
      }
    }
  }


  
}

export default new CommandProcessor();


// Archivo: config\config.js

// config/config.js

import dotenv from 'dotenv';
import { CustomError } from '../utils/errorHandler.js';

dotenv.config();

const requiredEnvVars = [
  'PORT',
  'GOOGLE_SHEET_ID',
  'OPENAI_API_KEY',
  'GOOGLE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_PRIVATE_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable: ${envVar}`);
  }
}

export default {
  port: process.env.PORT,
  googleSheetId: process.env.GOOGLE_SHEET_ID,
  openaiApiKey: process.env.OPENAI_API_KEY,
  googleServiceAccountEmail: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
  googlePrivateKey: process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  blacklistDuration: parseInt(process.env.BLACKLIST_DURATION) || 10 * 60 * 1000,
  humanBlacklistDuration: parseInt(process.env.HUMAN_BLACKLIST_DURATION) || 60 * 60 * 1000,
  abuseBlacklistDuration: parseInt(process.env.ABUSE_BLACKLIST_DURATION) || 24 * 60 * 60 * 1000,
  idleWarningTime: parseInt(process.env.IDLE_WARNING_TIME) || 5 * 60 * 1000,
  idleTimeoutTime: parseInt(process.env.IDLE_TIMEOUT_TIME) || 10 * 60 * 1000,
  maxAudioSize: parseInt(process.env.MAX_AUDIO_SIZE) || 5 * 1024 * 1024,
  languageModel: process.env.LANGUAGE_MODEL || 'ft:gpt-4o-mini-2024-07-18:personal:modelo-chile-imprime:AEWZI9XK',
  timezone: process.env.TIMEZONE || 'America/Santiago',
  logLevel: process.env.LOG_LEVEL || 'info',
  maxTokens: parseInt(process.env.MAX_TOKENS) || 2000,
  temperature: parseFloat(process.env.TEMPERATURE) || 0.5,
  messageQueueGapSeconds: parseInt(process.env.MESSAGE_QUEUE_GAP_SECONDS) || 3000,
  promoMessageDelay: parseInt(process.env.PROMO_MESSAGE_DELAY) || 15000,
  servicesUpdateInterval: parseInt(process.env.SERVICES_UPDATE_INTERVAL) || 60 * 60 * 1000,
};


// Archivo: modules\flowManager.js

import { addKeyword, EVENTS } from '@builderbot/bot';
import logger from '../utils/logger.js';
import userContextManager from './userContext.js';
import orderManager from './orderManager.js';
import openaiService from '../services/openaiService.js';
import whatsappService from '../services/whatsappService.js';
import config from '../config/config.js';
import { CustomError } from '../utils/errorHandler.js';
import inactivityMiddleware from '../core/inactivity-middleware.js';
import blacklistMiddleware from '../core/blacklist-middleware.js';
import MessageQueue from './messageQueue.js';
import fileValidationService from '../services/fileValidationService.js';
import commandProcessor from '../commandProcessor.js';

class FlowManager {
  constructor() {
    this.flows = {
      principalFlow: null,
      confirmedFlow: null,
      restartBotFlow: null,
      documentFlow: null,
      voiceNoteFlow: null,
      catchAllFlow: null,
      idleTimeoutFlow: null,
      promoFlow: null,
      mediaFlow: null
    };
    this.blacklist = new Map();
    this.idleTimers = new Map();
    this.messageQueue = new MessageQueue({ gapSeconds: config.messageQueueGapSeconds });
    this.cooldowns = new Map();
    this.initialMessagePromises = new Map();
    this.initialMessageLocks = new Map(); // Añade esta línea

  }


  async initializeFlows() {
    try {
      // Inicializar los flujos
      this.flows.principalFlow = this.createPrincipalFlow();
      this.flows.confirmedFlow = this.createConfirmedFlow();
      this.flows.restartBotFlow = this.createRestartBotFlow();
      this.flows.documentFlow = this.createDocumentFlow();
      this.flows.voiceNoteFlow = this.createVoiceNoteFlow();
      this.flows.catchAllFlow = this.createCatchAllFlow();
      this.flows.idleTimeoutFlow = this.createIdleTimeoutFlow();
      this.flows.promoFlow = this.createPromoFlow();
      this.flows.mediaFlow = this.createMediaFlow();

      // Agregar middlewares
      Object.values(this.flows).forEach(flow => {
        if (flow && typeof flow.addAction === 'function') {
          flow.addAction(inactivityMiddleware(this));
          flow.addAction(blacklistMiddleware(this));
        } else {
          logger.warn(`Un flujo no tiene el método addAction o es nulo`);
        }
      });

      logger.info('Flujos inicializados correctamente');
      return Object.values(this.flows).filter(flow => flow !== null);
    } catch (error) {
      logger.error(`Error al inicializar flujos: ${error.message}`);
      throw new CustomError('FlowInitializationError', 'Error al inicializar los flujos', error);
    }
  }


  getFlowByName(name) {
    return this.flows[name];
  }

  // Nuevo método centralizado para manejar mensajes iniciales
  async handleInitialMessagesOnce(userId, flowDynamic) {
    logger.info(`Intentando enviar mensajes iniciales para usuario ${userId}`);
    
    if (this.initialMessageLocks.get(userId)) {
      logger.info(`Usuario ${userId} ya tiene mensajes iniciales en proceso. Ignorando nueva solicitud.`);
      return;
    }

    this.initialMessageLocks.set(userId, true);

    if (!this.initialMessagePromises.has(userId)) {
      this.initialMessagePromises.set(userId, (async () => {
        if (!userContextManager.hasUserInteracted(userId)) {
          logger.info(`Iniciando envío de mensajes iniciales para usuario ${userId}`);

          try {
            // Crear una cola de mensajes
            const messageQueue = [
              { type: 'image', content: 'https://chileimprime.cl/wp-content/uploads/2024/10/Camapanas-politicas-chileimprime-el-m2-mas-economico.jpg' },
              { type: 'services', content: await commandProcessor.handleListAllServices(userId) },
              { type: 'text', content: `
👉 Selecciona uno de los servicios enviados para iniciar tu cotización.

También puedes realizar las siguientes acciones:
- 🔍 Ver el estado de tus pedidos anteriores
- 🕒 Consultar horarios de atención
- 🎉 Conocer nuestras promociones actuales
- 🖨️ Resolver dudas sobre procesos de impresión
- 📄 Consultar especificaciones de archivos o parámetros técnicos
- 🎙️ Analizar archivos en tiempo real para evaluar validez.

Si necesitas contactar a un agente, por favor escribe *agente* o *humano.*

Para reiniciar el bot en cualquier momento, simplemente escribe *bot.*` }
            ];

            // Enviar mensajes de la cola con un intervalo
            for (const message of messageQueue) {
              switch (message.type) {
                case 'image':
                  await flowDynamic([{ body: 'Promo campañas políticas', media: message.content }]);
                  break;
                case 'services':
                  if (message.content && message.content.data) {
                    await flowDynamic(message.content.data);
                  }
                  break;
                case 'text':
                  await flowDynamic(message.content);
                  break;
              }
              await new Promise(resolve => setTimeout(resolve, 3000)); // Espera 3 segundos entre mensajes
            }

            userContextManager.setInitialMessagesSent(userId, true);
            userContextManager.setHasInteracted(userId, true);
            logger.info(`Mensajes iniciales enviados y estado actualizado para usuario ${userId}`);
          } catch (error) {
            logger.error(`Error al enviar mensajes iniciales para usuario ${userId}: ${error.message}`);
          } finally {
            this.initialMessageLocks.delete(userId);
          }
        } else {
          logger.info(`Usuario ${userId} ya ha interactuado, omitiendo mensajes iniciales`);
        }
      })());
    }

    await this.initialMessagePromises.get(userId);
    this.initialMessagePromises.delete(userId);
  }


  createPrincipalFlow() {
    return addKeyword(EVENTS.WELCOME)
      .addAction(async (ctx, { flowDynamic, gotoFlow, endFlow }) => {
        const userId = ctx.from;

        if (this.initialMessageLocks.get(userId)) {
          logger.info(`Ignorando mensaje de usuario ${userId} durante el envío de mensajes iniciales`);
          return;
        }

        if (!userContextManager.hasUserInteracted(userId)) {
          // Send initial messages without processing user input
          await this.handleInitialMessagesOnce(userId, flowDynamic);
        } else {
          // Process user input in subsequent interactions
          this.enqueueMessage(userId, ctx.body, async (accumulatedMessage) => {
            await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
          });
        }
      });
  }

  createMediaFlow() {
    return addKeyword(EVENTS.MEDIA)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Imagen recibida de ${userId}. Enviando instrucciones específicas.`);

        userContextManager.setHasInteracted(userId, true);
  
        const messages = [
          '🖼️ *¡Hola!* Hemos recibido tu imagen, pero necesitamos que nos envíes tu diseño como *documento* para preservar la calidad.\n\nLas imágenes enviadas como foto en WhatsApp se comprimen y pierden calidad, lo que afecta el análisis y la impresión.\n\nPor favor, envía el mismo archivo como *documento* en uno de los siguientes formatos de alta calidad: *PDF, AI, PSD* o una imagen en alta resolución.\n\n*Criterios de Validación Resumidos:*\n\n- Resolución mínima: 72 dpi y máxima: 150 dpi.\n- Formato preferente: CMYK para evitar diferencias de color.\n- Tamaño real del diseño acorde al tamaño de impresión.',
          '📱 *Cómo enviar un documento en WhatsApp desde Android o iPhone:*\n\n1️⃣ Abre el chat de *Chileimprime*.\n2️⃣ Toca el ícono de *adjuntar* (📎).\n3️⃣ Selecciona *Documento*.\n4️⃣ Busca y selecciona tu archivo de diseño.\n5️⃣ Presiona *Enviar*.',
          '✨ *Esperamos tu archivo nuevamente como documento para iniciar el análisis.* ¡Gracias!'
        ];
  
        try {
          for (const message of messages) {
            await flowDynamic(message);
            logger.info(`Mensaje enviado a ${userId}: ${message.substring(0, 50)}...`);
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
          logger.info(`Instrucciones para imagen enviadas exitosamente a ${userId}`);
        } catch (error) {
          logger.error(`Error al enviar mensajes en mediaFlow para usuario ${userId}: ${error.message}`);
          await flowDynamic('⚠️ *Ha ocurrido un error al enviar las instrucciones. Por favor, intenta nuevamente más tarde.*');
        }
      });
  }
  

  createDocumentFlow() {
    return addKeyword(EVENTS.DOCUMENT)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Documento recibido de ${userId}. Iniciando análisis.`);
        userContextManager.setHasInteracted(userId, true);

        try {
          const filePath = await whatsappService.saveFile(ctx);
          logger.info(`Archivo guardado para usuario ${userId}: ${filePath}`);
  
          const fileInfo = await fileValidationService.analyzeFile(filePath);
          logger.info(`Análisis completado para archivo de usuario ${userId}: ${JSON.stringify(fileInfo)}`);
          
          await userContextManager.updateCurrentOrder(userId, {
            filePath: filePath,
            fileAnalysis: fileInfo
          });
          
          await flowDynamic('📄 Documento recibido. Analizando...');
  
          await commandProcessor.handleFileAnalysis(ctx, flowDynamic);
          
          logger.info(`Análisis de archivo enviado al usuario ${userId}`);
        } catch (error) {
          logger.error(`Error al procesar el documento para usuario ${userId}: ${error.message}`);
          await flowDynamic('❌ Hubo un error al procesar tu archivo. Por favor, intenta enviarlo nuevamente o contacta con soporte si el problema persiste.');
        }
      });
    }

    createConfirmedFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          // Modificación: Eliminar envío de "SOLICITUD_HUMANO"
          this.addToBlacklist(ctx.from, config.humanBlacklistDuration);
          logger.info(`Cotización ya confirmada para ${ctx.from}. Redirigiendo a atención humana.`);
          return endFlow("Un representante se pondrá en contacto contigo pronto para finalizar tu cotización. Gracias por tu paciencia.");
        });
    }
    
      createRestartBotFlow() {
        return addKeyword(['bot', 'Bot', 'BOT'])
          .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
            const userId = ctx.from;
            logger.info(`Intento de reinicio de bot por usuario ${userId}`);
            this.resetConversation(userId, true); // Reiniciar initialMessagesSent
            logger.info(`Bot reiniciado para usuario ${userId}`);
            await flowDynamic('*¡Bienvenido de nuevo!* 🎉 El bot ha sido reiniciado. *¿En qué puedo ayudarte hoy?* 😊');
            return gotoFlow(this.flows.principalFlow);
          });
      }

    createVoiceNoteFlow() {
      return addKeyword(EVENTS.VOICE_NOTE)
        .addAction(async (ctx, { flowDynamic, state, gotoFlow, endFlow }) => {
          try {
            const audioPath = await whatsappService.saveAudioFile(ctx);
            const transcription = await openaiService.transcribeAudio(audioPath);
            logger.info(`Transcripción del audio: ${transcription}`);
            
            await state.update({ lastTranscription: transcription });
            await flowDynamic(`*📝 Transcripción:*\n${transcription}`);
    
            this.enqueueMessage(ctx.from, transcription, async (accumulatedMessage) => {
              await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
            });
          } catch (error) {
            logger.error(`Error al procesar la nota de voz: ${error.message}`);
            await flowDynamic('Hubo un error al procesar la nota de voz. Por favor, intenta enviar un mensaje de texto.');
          }
        });
    }
  
  
    createCatchAllFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { gotoFlow }) => {
          if (orderManager.isOrderConfirmed(ctx.from)) {
            return gotoFlow(this.flows.confirmedFlow);
          } else {
            return gotoFlow(this.flows.principalFlow);
          }
        });
    }
  
    createIdleTimeoutFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { endFlow }) => {
          logger.info(`Tiempo de espera agotado para usuario ${ctx.from}`);
          this.resetConversation(ctx.from);
          return endFlow('*😴 Lo siento, el tiempo de espera ha expirado. Tu cotización ha sido cancelada. Si deseas hacer una nueva cotización, por favor envía un mensaje.*');
        });
    }
  
    createPromoFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          const promoMessage = whatsappService.getPromoMessage();
          try {
            await flowDynamic(promoMessage);
            logger.info(`Mensaje promocional enviado a ${ctx.from}`);
          } catch (error) {
            logger.error(`Error al enviar mensaje promocional a ${ctx.from}: ${error.message}`);
          }
          return endFlow();
        });
    }
  
    enqueueMessage(userId, message, callback) {
      this.messageQueue.enqueueMessage(userId, message, callback);
    }
  
    async handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, message, instruction = '') {
      const userId = ctx.from;
      logger.info(`Procesando mensaje para usuario ${userId}: ${message}`);
  
      if (this.isBlacklisted(userId)) {
        logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
  
      if (orderManager.isOrderConfirmed(userId)) {
        logger.info(`Cotización ya confirmada para ${userId}. Redirigiendo a atención humana.`);
        return gotoFlow(this.getFlowByName('confirmedFlow'));
      }
  
      this.startIdleTimer(ctx, flowDynamic, gotoFlow);
  
      try {
        const userContext = userContextManager.getUserContext(userId);
        const chatContext = userContextManager.getChatContext(userId);
  
        let aiResponse = await openaiService.getChatCompletion(
          openaiService.getSystemPrompt(userContext.services, userContext.currentOrder, userContext.additionalInfo, chatContext),
          [...chatContext, { role: "user", content: message }],
          instruction
        );
  
        logger.info(`Respuesta inicial de AI para ${userId}: ${aiResponse}`);
  
        // Procesar comandos en la respuesta de la IA
        const commands = this.processAIResponse(aiResponse);
        let currentOrderUpdated = false;
        let missingFields = [];
        let responseHandled = false; // Nueva variable para controlar si la respuesta ya fue manejada
  
        for (const command of commands) {
          // Validar comando antes de procesarlo
          const { validatedCommand, responseSent } = await this.validateCommand(command, userId, aiResponse, message, ctx, flowDynamic);
          if (validatedCommand) {
            if (typeof validatedCommand === 'object') {
              const result = await commandProcessor.processCommand(validatedCommand, userId, ctx, { flowDynamic, gotoFlow, endFlow });
              if (result.currentOrderUpdated) {
                currentOrderUpdated = true;
              }
              if (result.missingFields && result.missingFields.length > 0) {
                missingFields = result.missingFields;
              }
              if (result.messagesSent) {
                logger.info(`Mensajes enviados por comando ${command.command} para ${userId}`);
              }
              if (result.data) {
                await flowDynamic(result.data);
                responseHandled = true;
              }
            }
          }
  
          // Si la respuesta ya fue manejada en validateCommand, establecemos responseHandled en true
          if (responseSent) {
            responseHandled = true;
            break; // Salimos del bucle ya que la respuesta ha sido manejada
          }
        }
  
        // Solo enviar la respuesta original de la IA si no ha sido manejada ya
        if (!responseHandled) {
          const filteredResponse = this.filterJsonCommands(aiResponse);
          if (filteredResponse) {
            await flowDynamic(filteredResponse);
            // Actualizar el contexto con la respuesta enviada
            userContextManager.updateContext(userId, aiResponse, "assistant");
          }
        }
  
        // Actualizar el contexto con el mensaje del usuario
        userContextManager.updateContext(userId, message, "user");
  
        // Manejo de orden completa
        if (userContextManager.isOrderComplete(userId)) {
          logger.info(`Orden completa para ${userId}. Confirmando pedido.`);
          // Enviar comando de confirmación
          await commandProcessor.processCommand({ command: "CONFIRM_ORDER" }, userId, ctx, { flowDynamic, gotoFlow, endFlow });
          return gotoFlow(this.getFlowByName('confirmedFlow'));
        }
  
      } catch (error) {
        logger.error(`Error al procesar respuesta para usuario ${userId}: ${error.message}`);
        logger.error(`Stack trace: ${error.stack}`);
        await flowDynamic("Lo siento, ha ocurrido un error inesperado. Por favor, intenta nuevamente en unos momentos.");
      }
    }


  
    processAIResponse(aiResponse) {
      const commandRegex = /{[^}]+}/g;
      const commands = aiResponse.match(commandRegex) || [];
      return commands.map(cmd => {
        try {
          return JSON.parse(cmd);
        } catch (error) {
          logger.error(`Error al parsear comando JSON: ${error.message}`);
          return null;
        }
      }).filter(cmd => cmd !== null);
    }

    filterJsonCommands(aiResponse) {
      // Eliminar todos los comandos JSON de la respuesta
      return aiResponse.replace(/\{.*?\}/g, '').trim();
    }
  
    setIdleTimers(userId, timers) {
      this.idleTimers.set(userId, timers);
    }
  
    addToBlacklist(userId, duration) {
      this.blacklist.set(userId, Date.now() + duration);
      logger.info(`Usuario ${userId} añadido a la lista negra por ${duration/1000} segundos`);
    }
  
    isBlacklisted(userId) {
      if (this.blacklist.has(userId)) {
        const blacklistExpiry = this.blacklist.get(userId);
        if (Date.now() < blacklistExpiry) {
          logger.info(`Usuario ${userId} está en la lista negra. Tiempo restante: ${(blacklistExpiry - Date.now()) / 1000} segundos`);
          return true;
        } else {
          this.blacklist.delete(userId);
          this.resetConversation(userId);
          logger.info(`Usuario ${userId} removido de la lista negra`);
        }
      }
      return false;
    }
  
    resetConversation(userId, resetInitialMessages = false) {
      userContextManager.resetContext(userId, resetInitialMessages);
      orderManager.resetOrderConfirmation(userId);
      this.blacklist.delete(userId);
      this.clearIdleTimer(userId);
      logger.info(`Conversación reiniciada para usuario ${userId}, resetInitialMessages: ${resetInitialMessages}`);
    }
  
    startIdleTimer(ctx, flowDynamic, gotoFlow) {
      this.clearIdleTimer(ctx.from);
      
      const warningTimer = setTimeout(async () => {
        await flowDynamic('*⏰ ¿Sigues ahí? Si necesitas más tiempo, por favor responde cualquier mensaje.*');
      }, config.idleWarningTime);
  
      const timeoutTimer = setTimeout(() => {
        this.resetConversation(ctx.from);
        gotoFlow(this.getFlowByName('idleTimeoutFlow'));
      }, config.idleTimeoutTime);
  
      this.setIdleTimers(ctx.from, { warningTimer, timeoutTimer });
    }
  
    clearIdleTimer(userId) {
      const timers = this.idleTimers.get(userId);
      if (timers) {
        clearTimeout(timers.warningTimer);
        clearTimeout(timers.timeoutTimer);
        this.idleTimers.delete(userId);
      }
    }
  
    blacklistMiddleware(ctx, { endFlow }) {
      if (this.isBlacklisted(ctx.from)) {
        logger.info(`Usuario ${ctx.from} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
      return false;
    }

    async validateCommand(command, userId, assistantMessage, userMessage, ctx, flowDynamic) {
      if (command.command === "CONFIRM_ORDER") {
        if (!userContextManager.isOrderComplete(userId)) {
          const missingFields = userContextManager.getIncompleteFields(userId);
          logger.warn(`La orden está incompleta para el usuario ${userId}. Campos faltantes: ${missingFields.join(', ')}. Revaluando comando CONFIRM_ORDER.`);
  
          // Llamar primero a extractDataFromUserMessage
          const extractedCommand = await this.extractDataFromUserMessage(userMessage, userId);
  
          if (extractedCommand) {
            logger.info(`Comando extraído de extractDataFromUserMessage para usuario ${userId}: ${JSON.stringify(extractedCommand)}`);
  
            // Procesar el comando extraído
            await commandProcessor.processCommand(extractedCommand, userId, ctx, { flowDynamic });
  
            // Generar una instrucción para getChatCompletion
            const instruction = `
  El cliente acaba de ${this.getActionDescription(extractedCommand)}.
  
  Continúa la conversación con el cliente para avanzar en la cotización.
  
  Importante:
  - No incluyas ningún comando JSON en tu respuesta.
  - No muestres los comandos al cliente.
  - Responde de manera natural y amable, siguiendo las pautas del SystemPrompt.
  
  Responde al cliente:
            `;
  
            // Obtener el SystemPrompt actualizado
            const userContext = userContextManager.getUserContext(userId);
            const systemPrompt = openaiService.getSystemPrompt(
              userContext.services,
              userContext.currentOrder,
              userContext.additionalInfo,
              userContext.chatContext
            );
  
            // Llamar a getChatCompletion con la instrucción
            const aiResponse = await openaiService.getChatCompletion(
              systemPrompt,
              userContext.chatContext,
              instruction
            );
  
            // Actualizar el contexto
            userContextManager.updateContext(userId, aiResponse, "assistant");
  
            // Enviar la respuesta al cliente
            await flowDynamic(aiResponse);
  
            // Indicar que la respuesta ha sido manejada
            return { validatedCommand: null, responseSent: true };
          } else {
            // Si no se extrae un comando válido, proceder a reevaluateCommand
            const newCommandOrResponse = await this.reevaluateCommand(assistantMessage, userMessage, userId, missingFields);
  
            if (newCommandOrResponse) {
              // Procesar el nuevo comando si existe
              if (newCommandOrResponse.command) {
                logger.info(`Nuevo comando obtenido tras revaluación: ${JSON.stringify(newCommandOrResponse.command)}`);
                await commandProcessor.processCommand(newCommandOrResponse.command, userId, ctx, { flowDynamic });
              }
  
              // Enviar la respuesta al usuario si existe
              if (newCommandOrResponse.response) {
                await flowDynamic(newCommandOrResponse.response);
                userContextManager.updateContext(userId, newCommandOrResponse.response, "assistant");
              }
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            } else {
              // Actualizar el contexto del asistente con los campos faltantes
              const systemMessage = `Campos faltantes: La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
              userContextManager.updateContext(userId, systemMessage, "system");
  
              // Informar al usuario
              await flowDynamic("Parece que aún falta información para completar tu pedido. Por favor, proporciónanos los detalles faltantes.");
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            }
          }
        }
      }
      return { validatedCommand: command, responseSent: false };
    }  


    // Nueva función para describir la acción basada en el comando
    getActionDescription(command) {
      switch (command.command) {
        case "SELECT_SERVICE":
          return `seleccionado el servicio: ${command.service}`;
        case "SET_MEASURES":
          return `establecido las medidas: ancho ${command.width} m, alto ${command.height} m`;
        case "SET_QUANTITY":
          return `establecido la cantidad: ${command.quantity}`;
        case "SET_FINISHES":
          return `seleccionado las terminaciones: sellado ${command.sellado}, ojetillos ${command.ojetillos}, bolsillo ${command.bolsillo}`;
        default:
          return `realizado una acción`;
      }
    }




    // Nueva función extractDataFromUserMessage
    async extractDataFromUserMessage(userMessage, userId) {
      logger.info(`Intentando extraer comando del mensaje del usuario ${userId}: "${userMessage}"`);
  
      const chatContext = userContextManager.getChatContext(userId);
      const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');
  
      const currentOrder = userContextManager.getCurrentOrder(userId);
  
      const prompt = `
  Eres un asistente experto en impresión y gestión de pedidos. A partir del siguiente mensaje del usuario y el contexto de la conversación, extrae el comando apropiado para procesar su solicitud.
  
  Historial de la conversación:
  ${lastMessages}
  
  Mensaje del usuario:
  "${userMessage}"
  
  Información actual de la orden:
  ${JSON.stringify(currentOrder)}
  
  Lista de servicios disponibles:
  ${JSON.stringify(userContextManager.getAllServices())}
  
  Tu tarea es analizar el mensaje del usuario y, si es posible, extraer el comando adecuado para avanzar en el procesamiento de su pedido. Solo debes devolver un comando JSON válido si estás seguro de que el mensaje del usuario contiene la información necesaria.
  
  Posibles comandos:
  - {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}
  - {"command": "SET_MEASURES", "width": X, "height": Y}
  - {"command": "SET_QUANTITY", "quantity": Z}
  - {"command": "SET_FINISHES", "sellado": true/false, "ojetillos": true/false, "bolsillo": true/false}
  
  Si no es posible extraer un comando válido, no devuelvas nada.
  
  No debes devolver ninguna explicación ni texto adicional. Solo devuelve el comando JSON si es aplicable.
  `;
  
      try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de extractDataFromUserMessage para usuario ${userId}: ${aiResponse}`);
  
        // Intentar parsear la respuesta como JSON
        try {
          const extractedCommand = JSON.parse(aiResponse);
          return extractedCommand;
        } catch (parseError) {
          logger.warn(`No se pudo parsear el comando extraído para usuario ${userId}: ${parseError.message}`);
          return null;
        }
      } catch (error) {
        logger.error(`Error al extraer comando del mensaje del usuario ${userId}: ${error.message}`);
        return null;
      }
    }


  async reevaluateCommand(assistantMessage, userMessage, userId, missingFields) {
    logger.info(`Reevaluando comando para usuario ${userId}`);

    // Obtener el historial reciente de la conversación
    const chatContext = userContextManager.getChatContext(userId);
    const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');

    // Obtener la lista de servicios disponibles
    const services = userContextManager.getGlobalServices();
    const servicesList = Object.values(services).flat().map(service => service.name).join(', ');
    const currentOrder = userContextManager.getCurrentOrder(userId);

    // Modificación del prompt para evitar que el asistente asuma valores por defecto
    const prompt = `
Eres un asistente experto en impresión y gestión de pedidos. Aquí está la última interacción:

${lastMessages}

Basado en esta interacción y el estado actual de la orden:
${JSON.stringify(userContextManager.getCurrentOrder(userId))}

Presta especial atención a los siguientes detalles del currentOrder:
- Servicio actual: ${currentOrder.service || 'No seleccionado'}
- Categoría: ${currentOrder.category || 'No especificada'}
- Tipo: ${currentOrder.type || 'No especificado'}
- Medidas seleccionadas: 
  * Ancho: ${currentOrder.measures?.width || 'No especificado'} metros
  * Alto: ${currentOrder.measures?.height || 'No especificado'} metros
- Terminaciones elegidas: 
  * Sellado: ${currentOrder.finishes?.sellado ? 'Sí' : 'No'}
  * Ojetillos: ${currentOrder.finishes?.ojetillos ? 'Sí' : 'No'}
  * Bolsillo: ${currentOrder.finishes?.bolsillo ? 'Sí' : 'No'}
- Cantidad: ${currentOrder.quantity || 'No especificada'}
- Archivo de diseño: ${currentOrder.filePath ? 'Subido' : 'No subido'}
- Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
- Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
- Área del servicio: ${currentOrder.areaServicio || 'No calculada'} m²

Lista de servicios disponibles: ${servicesList}

Los campos faltantes en la orden son: ${missingFields.join(', ')}

Tu objetivo es ayudar al usuario a completar la información faltante sin asumir ningún valor por defecto. No debes asignar valores a campos faltantes a menos que el usuario los haya proporcionado explícitamente.

Analiza si el comando 'CONFIRM_ORDER' es apropiado. Si la orden está incompleta, determina la mejor respuesta posible al usuario para ayudarlo a proporcionar la información faltante.

Recuerda:
- No asumas servicios o valores que el usuario no haya mencionado explícitamente.
- Si el usuario está confirmando la selección de un servicio, pero no ha proporcionado el nombre del servicio, pídele amablemente que especifique el servicio que desea.
- Proporciona una respuesta clara y amable que guíe al usuario a proporcionar la información faltante.

No debes devolver ningún comando en este caso. Responde al usuario de manera que continúe la conversación y facilite la obtención de la información necesaria.
    `;

    try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de reevaluación del modelo para usuario ${userId}: ${aiResponse}`);

        // Como hemos instruido al asistente a no devolver comandos, procesamos solo la respuesta
        return { command: null, response: aiResponse.trim() };
    } catch (error) {
        logger.error(`Error al reevaluar comando para usuario ${userId}: ${error.message}`);
        return null;
    }
}




  }
  
  export default new FlowManager();


// Archivo: modules\orderManager.js

import logger from '../utils/logger.js';
import { formatPrice, censorPhoneNumber } from '../utils/helpers.js';
import moment from 'moment-timezone';
import config from '../config/config.js';
import sheetService from '../services/sheetService.js';
import userContextManager from './userContext.js';
import { CustomError } from '../utils/errorHandler.js';

class OrderManager {
  constructor() {
    this.orderConfirmed = new Set();
  }

  async handleSelectService(userId, serviceName) {
    logger.info(`Manejando selección de servicio para usuario ${userId}: ${serviceName}`);
    try {
      const serviceInfo = userContextManager.getServiceInfo(serviceName);
      
      if (!serviceInfo) {
        const similarServices = userContextManager.findSimilarServices(serviceName);
        return {
          action: "INVALID_SERVICE",
          similarServices,
          order: userContextManager.getCurrentOrder(userId)
        };
      }

      userContextManager.updateCurrentOrder(userId, { 
        service: serviceName,
        category: serviceInfo.category,
        availableWidths: serviceInfo.availableWidths,
        availableFinishes: userContextManager.getAvailableFinishes(serviceInfo)
      });
      
      return {
        action: "SELECT_SERVICE",
        order: userContextManager.getCurrentOrder(userId),
        serviceInfo: serviceInfo
      };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      throw new CustomError('ServiceSelectionError', 'Error al seleccionar el servicio', error);
    }
  }

  async handleSetMeasures(userId, width, height) {
    logger.info(`Manejando configuración de medidas para usuario ${userId}: ${width}x${height}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        throw new CustomError('InvalidMeasuresError', 'Este servicio no requiere medidas personalizadas');
      }

      const validWidth = serviceInfo.availableWidths.find(w => w.material === parseFloat(width));
      if (!validWidth) {
        throw new CustomError('InvalidWidthError', 'Ancho no válido para este servicio');
      }

      if (parseFloat(height) < 1) {
        throw new CustomError('InvalidHeightError', 'El alto debe ser mayor o igual a 1 metro');
      }

      const measures = { width: validWidth.material, height: parseFloat(height) };
      const areaServicio = measures.width * measures.height; // Calcular área del servicio
      const { total, area } = this.calculatePrice({ ...currentOrder, measures });

      userContextManager.updateCurrentOrder(userId, { measures, areaServicio, total, area }); // Actualizar areaServicio

      return {
        action: "SET_MEASURES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      throw new CustomError('MeasuresSetupError', 'Error al configurar las medidas', error);
    }
  }

  async handleSetQuantity(userId, quantity) {
    logger.info(`Manejando configuración de cantidad para usuario ${userId}: ${quantity}`);
    try {
      if (quantity <= 0) {
        throw new CustomError('InvalidQuantityError', 'La cantidad debe ser mayor que cero');
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        // Para categorías sin medidas personalizadas, calculamos el precio directamente
        const { total } = this.calculatePrice({ ...currentOrder, quantity });
        userContextManager.updateCurrentOrder(userId, { quantity, total });
      } else {
        userContextManager.updateCurrentOrder(userId, { quantity });
      }

      return {
        action: "SET_QUANTITY",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      throw new CustomError('QuantitySetupError', 'Error al configurar la cantidad', error);
    }
  }

  async setFinishes(userId, sellado, ojetillos, bolsillo) {
    logger.info(`Manejando configuración de acabados para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      const finishes = {
        sellado: sellado && serviceInfo.sellado,
        ojetillos: ojetillos && serviceInfo.ojetillos,
        bolsillo: bolsillo && serviceInfo.bolsillo
      };

      userContextManager.updateCurrentOrder(userId, { finishes: finishes});

      return {
        action: "SET_FINISHES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      throw new CustomError('FinishesSetupError', 'Error al configurar los acabados', error);
    }
  }

  async handleValidateFile(userId, isValid, reason) {
    logger.info(`Manejando validación de archivo para usuario ${userId}`);
    try {
      userContextManager.updateCurrentOrder(userId, {
        fileAnalysis: { isValid, reason }
      });
      
      return {
        action: "VALIDATE_FILE",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al validar archivo para usuario ${userId}: ${error.message}`);
      throw new CustomError('FileValidationError', 'Error al validar el archivo', error);
    }
  }

  async handleConfirmOrder(userId) {
    logger.info(`Manejando confirmación de pedido para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        
         // NUEVO: Lanzar excepción con detalles de campos faltantes
         const missingFields = userContextManager.getIncompleteFields(userId);
         const errorMessage = `La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
         logger.warn(errorMessage);
         throw new CustomError('IncompleteOrderError', errorMessage);
      }

      const total = this.calculatePrice(currentOrder);
      userContextManager.updateCurrentOrder(userId, { total: total });

      const orderSummary = this.formatOrderSummary(currentOrder);
      const result = await this.finalizeOrder(userId, currentOrder);

      this.orderConfirmed.add(userId);

      return {
        action: "CONFIRM_ORDER",
        order: currentOrder,
        summary: orderSummary,
        result: result
      };
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      throw new CustomError(error.name || 'OrderConfirmationError', error.message);
    }
  }

  calculatePrice(order) {
    const serviceInfo = userContextManager.getServiceInfo(order.service);
  
    let total = 0;
    let area = 1;
    let precioM2 = serviceInfo.precio;
    let precioTerminaciones = 0;
    let precioTotalTerminaciones = 0;
  
    logger.info(`Calculando precio para orden: ${JSON.stringify(order)}`);
    logger.info(`Información del servicio: ${JSON.stringify(serviceInfo)}`);
  
    if (['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
      area = order.measures.width * order.measures.height;
      total = area * precioM2 * order.quantity;
  
      // Calcula el precio de las terminaciones por m2
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      // Calcula el precio total de las terminaciones
      precioTotalTerminaciones = precioTerminaciones * area * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por m2: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    } else {
      total = precioM2 * order.quantity;
  
      // Para servicios sin medidas, calculamos las terminaciones por unidad
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      precioTotalTerminaciones = precioTerminaciones * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por unidad: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    }
  
    const precioBase = area * precioM2 * order.quantity;
  
    logger.info(`Precio base: ${precioBase}`);
    logger.info(`Precio total: ${total}`);
  
    return { 
      total, 
      area, 
      precioM2, 
      precioBase, 
      precioTerminaciones, 
      precioTotalTerminaciones
    };
  }

  formatOrderSummary(order) {
    let summary = "📋 *Resumen de tu cotización:*\n\n";

    summary += `🛍️ *Servicio:* ${order.service}\n`;

    if (order.measures) {
      summary += `📐 *Medidas:* ${order.measures.width}m x ${order.measures.height}m\n`;
      summary += `📏 *Área:* ${order.area} m²\n`;
    }

    summary += `🔢 *Cantidad:* ${order.quantity}\n`;

    if (order.finishes && order.finishes.length > 0) {
      summary += `🎨 *Terminaciones:*\n`;
      order.finishes.forEach(finish => {
        summary += `- ${finish}\n`;
      });
    }

    summary += `💵 *Total:* $${formatPrice(order.total)}\n`;

    return summary;
  }

  async finalizeOrder(userId, order) {
    logger.info(`Finalizando orden para usuario ${userId}`);
    
    const calculatedPrices = this.calculatePrice(order);
    const finalOrder = {
      fecha: moment().tz(config.timezone).format('DD-MM-YYYY HH:mm:ss'),
      telefono: userId,
      nombre: order.userName || 'Cliente',
      servicio: order.service,
      cantidad: order.quantity,
      measures: order.measures,
      area: calculatedPrices.area,
      precioM2: calculatedPrices.precioM2,
      precioBase: calculatedPrices.precioBase,
      terminaciones: Object.entries(order.finishes)
        .filter(([_, value]) => value)
        .map(([key, _]) => key),
      precioTerminaciones: calculatedPrices.precioTerminaciones,
      precioTotalTerminaciones: calculatedPrices.precioTotalTerminaciones,
      total: calculatedPrices.total,
      observaciones: order.observaciones || 'Sin observaciones'
    };
  
    logger.info(`Orden final para usuario ${userId}: ${JSON.stringify(finalOrder)}`);
  
    try {
      const result = await sheetService.saveOrder(finalOrder);
      logger.info(`Resultado de guardado para usuario ${userId}: ${JSON.stringify(result)}`);
  
      if (result.success) {
        this.orderConfirmed.add(userId);
        logger.info(`Cotización finalizada y guardada correctamente para usuario ${userId}`);
        
        // Modificación: Usar el número de pedido correcto
        const orderNumber = result.orderNumber || result.rowIndex;
        return { 
          success: true,
          message: "Tu cotización ha sido registrada. Un representante se pondrá en contacto contigo pronto para confirmar los detalles y coordinar la entrega de los archivos finales.",
          orderNumber: orderNumber // Usar el número de pedido correcto
        };
      } else {
        throw new Error("Error al guardar la cotización");
      }
    } catch (error) {
      logger.error(`Error detallado al finalizar la cotización para usuario ${userId}:`, error);
      throw new CustomError('OrderFinalizationError', 'Error al finalizar la cotización', error);
    }
  }


  formatOrderForSheet(order) {
    let details = `Servicio: ${order.service}\n`;
    
    if (order.measures) {
      details += `Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    
    details += `Cantidad: ${order.quantity}\n`;
    
    if (order.finishes) {
      details += "Terminaciones:\n";
      if (order.finishes.sellado) details += "- Sellado\n";
      if (order.finishes.ojetillos) details += "- Ojetillos\n";
      if (order.finishes.bolsillo) details += "- Bolsillo\n";
    }
    
    return details.trim();
  }

  isOrderConfirmed(userId) {
    return this.orderConfirmed.has(userId);
  }

  resetOrderConfirmation(userId) {
    this.orderConfirmed.delete(userId);
  }
}

export default new OrderManager();


// Archivo: modules\userContext.js

import logger from '../utils/logger.js';
import sheetService from '../services/sheetService.js';

class UserContextManager {
  constructor() {
    this.userContexts = new Map();
  }

  // Método existente para obtener el contexto del usuario
  getUserContext(userId) {
    if (!this.userContexts.has(userId)) {
      this.userContexts.set(userId, {
        context: "",
        chatContext: [],
        currentOrder: this.getEmptyOrder(),
        services: sheetService.getServices(),
        additionalInfo: sheetService.getAdditionalInfo(),
        initialMessagesSent: false,
        hasInteracted: false  // Nuevo estado para rastrear cualquier interacción
      });
      logger.info(`Nuevo contexto creado para usuario ${userId}`);
    }
    return this.userContexts.get(userId);
  }

  getEmptyOrder() {
    return {
      service: null,
      category: null,
      type: null,
      measures: null,
      finishes: {
        sellado: false,
        ojetillos: false,
        bolsillo: false
      },
      quantity: null,
      filePath: null,
      fileAnalysis: null,
      fileAnalysisResponded: false,
      fileAnalysisHandled: false,
      fileValidation: null,
      availableWidths: [],
      availableFinishes: [],
      price: 0,
      areaServicio: null,
    };
  }

  setInitialMessagesSent(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.initialMessagesSent = value;
    userContext.hasInteracted = true;
    logger.info(`Estado de mensajes iniciales y interacción actualizados para usuario ${userId}: ${value}`);
  }

  setHasInteracted(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.hasInteracted = value;
    logger.info(`Estado de interacción actualizado para usuario ${userId}: ${value}`);
  }

  hasUserInteracted(userId) {
    return this.getUserContext(userId).hasInteracted;
  }

  updateContext(userId, message, role) {
    const userContext = this.getUserContext(userId);
    userContext.context += `${role}: ${message}\n`;
    userContext.chatContext.push({ role, content: message });
    this.limitContextSize(userId);
    logger.info(`Contexto actualizado para usuario ${userId}. Mensajes en contexto: ${userContext.chatContext.length}`);
  }

  limitContextSize(userId) {
    const userContext = this.getUserContext(userId);
    if (userContext.chatContext.length > 30) {
      userContext.chatContext = userContext.chatContext.slice(-10);
    }
    const words = userContext.context.split(/\s+/);
    if (words.length > 1500) {
      userContext.context = words.slice(-1500).join(" ");
    }
    logger.info(`Contexto limitado para usuario ${userId}`);
  }

  setGlobalData(services, additionalInfo) {
    this.services = services;
    this.additionalInfo = additionalInfo;
    logger.info('Datos globales actualizados en UserContextManager');
    logger.info(`Menú global: ${JSON.stringify(this.services)}`);
    logger.info(`Información adicional global: ${JSON.stringify(this.additionalInfo)}`);
  }

  updateCurrentOrder(userId, updates) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder = { ...userContext.currentOrder, ...updates };
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
    
    if (updates.service) {
      const serviceInfo = sheetService.getServiceInfo(updates.service);
      if (serviceInfo) {
        userContext.currentOrder.category = serviceInfo.category;
        userContext.currentOrder.type = serviceInfo.type;
        userContext.currentOrder.availableWidths = serviceInfo.availableWidths;
        userContext.currentOrder.availableFinishes = {
          sellado: serviceInfo.sellado,
          ojetillos: serviceInfo.ojetillos,
          bolsillo: serviceInfo.bolsillo
        };
        userContext.currentOrder.fileValidationCriteria = {
          format: serviceInfo.format,
          minDPI: serviceInfo.minDPI,
        };
        logger.info(`Servicio seleccionado para usuario ${userId}: ${JSON.stringify(serviceInfo)}`);
      } else {
        logger.warn(`Servicio no encontrado: ${updates.service}`);
      }
    }

    if (updates.fileAnalysis) {
      userContext.currentOrder.fileAnalysisResponded = false;
    }

    if (updates.fileValidation) {
      userContext.currentOrder.fileValidation = updates.fileValidation;
    }
    
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
  }

  updateFileAnalysisResponded(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisResponded = value;
    logger.info(`FileAnalysisResponded actualizado para usuario ${userId}: ${value}`);
  }

  updateFileAnalysisHandled(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisHandled = value;
    logger.info(`FileAnalysisHandled actualizado para usuario ${userId}: ${value}`);
  }

  hasFileAnalysisBeenResponded(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisResponded;
  }

  hasFileAnalysisBeenHandled(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisHandled;
  }

  getCurrentOrder(userId) {
    const userContext = this.getUserContext(userId);
    const currentOrder = userContext.currentOrder;
    currentOrder.requiresMeasures = () => this.isServiceRequiringMeasures(currentOrder.category);
    logger.info(`Obteniendo orden actual para usuario ${userId}: ${JSON.stringify(currentOrder)}`);
    return currentOrder;
  }

  resetContext(userId, resetInitialMessages = false) {
    const userContext = this.getUserContext(userId);
    const initialMessagesSent = resetInitialMessages ? false : userContext.initialMessagesSent;
    this.userContexts.set(userId, {
      context: "",
      chatContext: [],
      currentOrder: this.getEmptyOrder(),
      services: sheetService.getServices(),
      additionalInfo: sheetService.getAdditionalInfo(),
      initialMessagesSent: initialMessagesSent,
      hasInteracted: false  // Reiniciar hasInteracted
    });
    logger.info(`Contexto reiniciado para usuario ${userId}, initialMessagesSent preserved: ${!resetInitialMessages}, hasInteracted reset`);
  }

  getGlobalServices() {
    return sheetService.getServices();
  }

  getGlobalAdditionalInfo() {
    return sheetService.getAdditionalInfo();
  }

  getServiceInfo(serviceName) {
    return sheetService.getServiceInfo(serviceName);
  }

  getAllServices() {
    return sheetService.getAllServices();
  }

  findSimilarServices(serviceName) {
    return sheetService.findSimilarServices(serviceName);
  }

  getServicesInCategory(category) {
    return sheetService.getServicesInCategory(category);
  }

  getFileValidationCriteria() {
    return sheetService.getFileValidationCriteria();
  }

  getAvailableFinishes(serviceInfo) {
    const finishes = [];
    if (serviceInfo.sellado) finishes.push("sellado");
    if (serviceInfo.ojetillos) finishes.push("ojetillos");
    if (serviceInfo.bolsillo) finishes.push("bolsillo");
    return finishes;
  }

  // NUEVO: Función para obtener los campos faltantes en la orden actual
  getIncompleteFields(userId) {
    const order = this.getCurrentOrder(userId);
    const missingFields = [];

    // Verificar campos obligatorios
    if (!order.service) missingFields.push('service');
    if (!order.quantity) missingFields.push('quantity');
    if (!order.filePath) missingFields.push('filePath');
    if (!order.fileAnalysis) missingFields.push('fileAnalysis');
    if (!order.fileAnalysisResponded) missingFields.push('fileAnalysisResponded');
    if (!order.fileValidation) missingFields.push('fileValidation');

    // Verificar si el servicio requiere medidas
    if (this.isServiceRequiringMeasures(order.category)) {
      if (!order.measures || !order.measures.width) missingFields.push('width');
      if (!order.measures || !order.measures.height) missingFields.push('height');
      if (!order.areaServicio) missingFields.push('areaServicio');
    }

    logger.info(`Campos faltantes para usuario ${userId}: ${missingFields.join(', ')}`);

    return missingFields;
  }

  // MODIFICADO: isOrderComplete ahora utiliza getIncompleteFields
  isOrderComplete(userId) {
    const missingFields = this.getIncompleteFields(userId);
    return missingFields.length === 0;
  }


    // Método para determinar si el servicio requiere medidas
    isServiceRequiringMeasures(serviceCategory) {
      return ['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceCategory);
    }
  
  
  getChatContext(userId) {
    return this.getUserContext(userId).chatContext;
  }
}

export default new UserContextManager();


// Archivo: services\sheetService.js

import { JWT } from "google-auth-library";
import { GoogleSpreadsheet } from "google-spreadsheet";
import moment from 'moment-timezone';
import 'moment/locale/es.js';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';

class GoogleSheetService {
  constructor() {
    this.jwtFromEnv = new JWT({
      email: config.googleServiceAccountEmail,
      key: config.googlePrivateKey,
      scopes: [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
      ],
    });
    this.doc = new GoogleSpreadsheet(config.googleSheetId, this.jwtFromEnv);
    moment.locale('es');
    moment.tz.setDefault(config.timezone);
    this.services = null;
    this.additionalInfo = null;
    this.isInitialized = false;
    this.lastFetchTime = null;
    this.cacheDuration = 60 * 60 * 1000; // 1 hour
  }

  async initialize() {
    try {
      logger.info("Iniciando inicialización de SheetService");
      await this.doc.loadInfo();
      logger.info("Documento de Google Sheets cargado correctamente");
      
      await this.loadServices();
      logger.info("Servicios cargados correctamente");
      await this.loadAdditionalInfo();
      logger.info("Información adicional cargada correctamente");
      
      this.isInitialized = true;
      this.lastFetchTime = Date.now();
      logger.info("SheetService inicializado completamente");
    } catch (error) {
      logger.error(`Error al inicializar SheetService: ${error.message}`);
      throw new CustomError('SheetServiceInitError', 'Error al inicializar el servicio de Google Sheets', error);
    }
  }

  async loadServices() {
    logger.info("Iniciando carga de servicios");
    this.services = await this.fetchServices();
    logger.info(`Servicios cargados: ${Object.keys(this.services).length} categorías`);
  }

  async loadAdditionalInfo() {
    logger.info("Iniciando carga de información adicional");
    this.additionalInfo = await this.fetchAdditionalInfo();
    logger.info("Información adicional cargada");
  }

  getServices() {
    if (!this.services || this.shouldRefreshCache()) {
      this.loadServices();
    }
    return this.services;
  }

  getAdditionalInfo() {
    if (!this.additionalInfo || this.shouldRefreshCache()) {
      this.loadAdditionalInfo();
    }
    return this.additionalInfo;
  }

  shouldRefreshCache() {
    return !this.lastFetchTime || (Date.now() - this.lastFetchTime > this.cacheDuration);
  }

  getServiceInfo(serviceName) {
    if (!serviceName || typeof serviceName !== 'string') {
      logger.warn(`Nombre de servicio inválido: ${serviceName}`);
      return null;
    }

    const services = this.getServices();
    const lowerServiceName = serviceName.toLowerCase();
    for (const category in services) {
      const service = services[category].find(s => s.name.toLowerCase() === lowerServiceName);
      if (service) {
        return service;
      }
    }
    logger.warn(`Servicio no encontrado: ${serviceName}`);
    return null;
  }

  getAllServices() {
    const services = this.getServices();
    return Object.values(services).flat();
  }

  getServicesInCategory(category) {
    const services = this.getServices();
    return services[category] || [];
  }

  getFileValidationCriteria() {
    const additionalInfo = this.getAdditionalInfo();
    return additionalInfo.criteriosValidacion;
  }

  findSimilarServices(serviceName) {
    const allServices = this.getAllServices();
    return allServices
      .filter(service => 
        service.name.toLowerCase().includes(serviceName.toLowerCase()) || 
        serviceName.toLowerCase().includes(service.name.toLowerCase())
      )
      .map(service => ({
        name: service.name,
        category: service.category
      }));
  }

  async fetchServices() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[0]; // La hoja "Control" es la primera hoja
      await sheet.loadCells('A1:Q1000');
  
      // Obtener los precios globales de las terminaciones
      const precioSellado = sheet.getCell(1, 14).value; // Celda O2
      const precioBolsillo = sheet.getCell(1, 15).value; // Celda P2
      const precioOjetillos = sheet.getCell(1, 16).value; // Celda Q2
  
      logger.info(`Precios globales de terminaciones: Sellado: ${precioSellado}, Bolsillo: ${precioBolsillo}, Ojetillos: ${precioOjetillos}`);
  
      const services = {};
      for (let i = 1; i < sheet.rowCount; i++) {
        const id = sheet.getCell(i, 0).value;
        if (!id) break;
  
        const service = this.extractServiceData(sheet, i, { precioSellado, precioBolsillo, precioOjetillos });
        if (service) {
          if (!services[service.category]) {
            services[service.category] = [];
          }
          services[service.category].push(service);
        }
      }
  
      logger.info(`Servicios cargados: ${Object.keys(services).length} categorías`);
      return services;
    } catch (err) {
      logger.error("Error al obtener los servicios:", err);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('ServicesFetchError', 'Error al obtener los servicios desde Google Sheets', err);
    }
  }

  extractServiceData(sheet, row, globalPrices) {
    try {
      const widthsString = sheet.getCell(row, 12).value;
      const availableWidths = widthsString ? this.parseAvailableWidths(widthsString) : [];
  
      const sellado = sheet.getCell(row, 4).value.toLowerCase();
      const ojetillos = sheet.getCell(row, 5).value.toLowerCase();
      const bolsillo = sheet.getCell(row, 6).value.toLowerCase();
  
      logger.info(`Valores leídos para el servicio en la fila ${row}:`);
      logger.info(`Sellado: ${sellado}, Ojetillos: ${ojetillos}, Bolsillo: ${bolsillo}`);
  
      const service = {
        id: sheet.getCell(row, 0).value,
        category: sheet.getCell(row, 1).value,
        type: sheet.getCell(row, 2).value,
        name: sheet.getCell(row, 3).value,
        sellado: sellado === 'sí' || sellado === 'si',
        ojetillos: ojetillos === 'sí' || ojetillos === 'si',
        bolsillo: bolsillo === 'sí' || bolsillo === 'si',
        format: sheet.getCell(row, 7).value,
        minDPI: parseInt(sheet.getCell(row, 8).value) || 0,
        stock: parseInt(sheet.getCell(row, 9).value) || 0,
        status: sheet.getCell(row, 10).value,
        precio: parseFloat(sheet.getCell(row, 11).value) || 0,
        availableWidths: availableWidths,
        precioSellado: globalPrices.precioSellado,
        precioBolsillo: globalPrices.precioBolsillo,
        precioOjetillos: globalPrices.precioOjetillos
      };
  
      logger.info(`Servicio extraído: ${JSON.stringify(service)}`);
  
      return service;
    } catch (error) {
      logger.error(`Error al extraer datos del servicio en la fila ${row}: ${error.message}`);
      return null;
    }
  }

  parseAvailableWidths(widthsString) {
    if (!widthsString || widthsString.toLowerCase().includes('no tiene rollos')) {
      return [];
    }
    
    logger.info(`Procesando medidas: ${widthsString}`);
    
    const lines = widthsString.split('\n').filter(line => !line.includes('Ancho material'));
    
    return lines.map(line => {
      const [material, imprimible] = line.split('-').map(part => part.trim());
      
      const parseMeasure = (measure) => {
        if (typeof measure !== 'string') {
          logger.warn(`Medida no es un string: ${measure}`);
          return 0;
        }
        return parseFloat(measure.replace('m', '').replace(',', '.')) || 0;
      };
      
      const parsedMaterial = parseMeasure(material);
      const parsedImprimible = parseMeasure(imprimible);
      
      if (parsedMaterial && parsedImprimible) {
        logger.info(`Medida procesada: material ${parsedMaterial}m, imprimible ${parsedImprimible}m`);
        return {
          material: parsedMaterial,
          imprimible: parsedImprimible
        };
      } else {
        logger.warn(`No se pudo procesar la medida: ${line}`);
        return null;
      }
    }).filter(w => w !== null);
  }

  async fetchAdditionalInfo() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[2];
      await sheet.loadCells();
  
      logger.info("Cargando información adicional de la hoja 'Informacion'");
  
      const additionalInfo = {
        horarios: {},
        zonasDespacho: [],
        direccionRetiro: '',
        promocionDia: '',
        metodosPago: '',
        tiempoPreparacion: '',
        criteriosValidacion: '',
        estadoBot: ''
      };
  
      this.extractAdditionalInfo(sheet, additionalInfo);
  
      logger.info("Información adicional cargada completamente");
      logger.debug(`Información adicional: ${JSON.stringify(additionalInfo)}`);
  
      return additionalInfo;
    } catch (err) {
      logger.error("Error al obtener información adicional:", err);
      throw new CustomError('AdditionalInfoError', 'Error al obtener información adicional desde Google Sheets', err);
    }
  }

  extractAdditionalInfo(sheet, additionalInfo) {
    const safeGetCellValue = (row, col) => {
      try {
        const cell = sheet.getCell(row, col);
        return cell.value || '';
      } catch (error) {
        logger.warn(`No se pudo obtener el valor de la celda (${row}, ${col}): ${error.message}`);
        return '';
      }
    };

    ['Lunes a viernes', 'Sábados', 'Domingos'].forEach((dia, index) => {
      additionalInfo.horarios[dia] = `${safeGetCellValue(index + 1, 0)} ${safeGetCellValue(index + 1, 1)}`.trim() || 'No disponible';
    });
  
    for (let row = 1; row <= 9; row++) {
      const zona = safeGetCellValue(row, 2);
      if (zona && zona.trim()) additionalInfo.zonasDespacho.push(zona.trim());
    }
  
    additionalInfo.direccionRetiro = safeGetCellValue(1, 4) || 'No disponible';
    additionalInfo.promocionDia = safeGetCellValue(1, 5) || 'No hay promociones actualmente';
    additionalInfo.metodosPago = safeGetCellValue(1, 6) || 'No especificado';
    additionalInfo.tiempoPreparacion = safeGetCellValue(1, 7) || 'No especificado';
    additionalInfo.criteriosValidacion = safeGetCellValue(1, 8) || 'No especificado';
    additionalInfo.estadoBot = safeGetCellValue(1, 9) || 'No especificado';
  
    logger.info(`Criterios de validación extraídos: ${additionalInfo.criteriosValidacion}`);
    logger.info(`Estado del bot: ${additionalInfo.estadoBot}`);
  }

  async saveOrder(data) {
    logger.info(`Iniciando guardado de cotización en Google Sheets: ${JSON.stringify(data)}`);
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      await sheet.loadCells();
  
      const orderNumber = await this.getNextOrderNumber();
      const rowData = this.prepareRowData(data, orderNumber);
      const result = await sheet.addRows([rowData]);
  
      return this.processAddRowResult(result, sheet);
    } catch (err) {
      logger.error("Error detallado al guardar la cotización en Google Sheets:", err.message);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('OrderSaveError', `Error al guardar la cotización: ${err.message}`, err);
    }
  }

  prepareRowData(data, orderNumber) {
    const now = moment().tz(config.timezone);
    const formattedDate = now.format('DD-MM-YYYY HH:mm:ss');
    
    const neto = data.total / 1.19; // Cálculo del neto (sin IVA)
    const iva = data.total - neto; // Cálculo del IVA
  
    logger.info(`Preparando datos para guardar en la hoja. Orden número: ${orderNumber}`);
  
    const rowData = [
      orderNumber,
      1, // Número de servicios (por ahora siempre 1)
      "Efectivo/transferencia",
      formattedDate,
      formattedDate, // Fecha de modificación (igual a la fecha de ingreso por ahora)
      "Sara - agente virtual",
      data.servicio,
      data.cantidad,
      `${data.measures.width} x ${data.measures.height}`,
      data.area,
      data.precioM2,
      data.precioBase,
      data.terminaciones.join(", ") || "No",
      data.precioTerminaciones, // Columna N: Precio de Terminación/m2
      data.precioTotalTerminaciones, // Columna O: Precio Total con Terminación
      "Boleta",
      neto,
      data.total,
      data.nombre,
      "contacto@chileimprime.cl", // Correo por defecto
      "66.666.666-6", // RUT por defecto
      data.telefono,
      '', '', '', '', '', '', '', '', '', '', '', '', // Columnas vacías
      "Pendiente", // Estado de pago
      "chileimprime.cl", // URL del diseño por defecto
      "Pendiente", // Estado del proyecto
      "sin nota", // Anotaciones
      "COTIZACIÓN" // Extras
    ];
  
    logger.info(`Datos preparados para la fila: ${JSON.stringify(rowData)}`);
  
    return rowData;
  }

  processAddRowResult(result, sheet) {
    if (Array.isArray(result) && result.length > 0) {
      const firstRow = result[0];
      const rowIndex = firstRow.rowIndex || firstRow._rowNumber || sheet.rowCount;
      logger.info(`Fila añadida exitosamente. ID de la nueva fila: ${rowIndex}`);
      return { success: true, message: "Cotización guardada exitosamente", rowIndex: rowIndex };
    } else {
      logger.warn("No se pudo obtener información de la fila añadida");
      return { success: true, message: "Cotización guardada exitosamente, pero no se pudo obtener el ID de la fila" };
    }
  }

  async getNextOrderNumber() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      await sheet.loadCells('A:A');
      
      let lastOrderNumber = 0;
      for (let i = sheet.rowCount - 1; i >= 2; i--) {
        const cell = sheet.getCell(i, 0);
        if (cell.value) {
          const match = cell.value.match(/WA-(\d+)/);
          if (match) {
            lastOrderNumber = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      const newOrderNumber = lastOrderNumber + 1;
      return `WA-${newOrderNumber}`;
    } catch (error) {
      logger.error("Error al generar número de pedido:", error);
      throw new CustomError('OrderNumberGenerationError', 'Error al generar número de pedido', error);
    }
  }

  censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) return phoneNumber;
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    return `${firstTwo}${'*'.repeat(middleLength)}${lastThree}`;
  }
}

export default new GoogleSheetService();

