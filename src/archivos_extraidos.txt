
// app.js

import "dotenv/config";
import flowManager from './modules/flowManager.js';
import whatsappService from './services/whatsappService.js';
import sheetService from './services/sheetService.js';
import logger from './utils/logger.js';
import createMiddleware from './core/middleware.js';
import logMiddleware from './core/log-middleware.js';
import userContextManager from './modules/userContext.js';
import config from './config/config.js';
import { errorHandler } from './utils/errorHandler.js';
import fileValidationService from './services/fileValidationService.js';

const middleware = createMiddleware([logMiddleware]);

const initializeServices = async () => {
  let services = null;
  let additionalInfo = null;

  try {
    await sheetService.initialize();

    services = await sheetService.getServices();
    additionalInfo = await sheetService.getAdditionalInfo();
    
    if (services && additionalInfo) {
      userContextManager.setGlobalData(services, additionalInfo);
      logger.info("Servicios e información adicional inicializados correctamente");
    } else {
      throw new Error("No se pudieron obtener los servicios o la información adicional");
    }
  } catch (error) {
    logger.error(`Error al inicializar servicios: ${error.message}`);
    logger.warn("Iniciando con funcionalidad reducida");
  }

  return { services, additionalInfo };
};

const main = async () => {
  try {
    const { services, additionalInfo } = await initializeServices();

    const flows = await flowManager.initializeFlows();

    flows.forEach(flow => {
      flow.addAction(middleware);
    });

    await whatsappService.initialize(flows);

    logger.info('Bot inicializado correctamente');

    if (services && additionalInfo) {
      logger.info('Bot iniciado con todas las funcionalidades');
    } else {
      logger.warn('Bot iniciado con funcionalidad reducida. Algunas características pueden no estar disponibles.');
    }

    // Configurar actualización periódica de los servicios y la información adicional
    setInterval(async () => {
      try {
        //await sheetService.reinitialize(); //Funcion eliminada, ahora el dockerfile se encarga de reiniciarse.
        const updatedServices = await sheetService.getServices();
        const updatedAdditionalInfo = await sheetService.getAdditionalInfo();
        if (updatedServices && updatedAdditionalInfo) {
          userContextManager.setGlobalData(updatedServices, updatedAdditionalInfo);
          logger.info("Servicios e información adicional actualizados correctamente");
        } else {
          logger.warn("No se pudieron actualizar los servicios o la información adicional");
        }
      } catch (error) {
        logger.error(`Error al actualizar servicios e información adicional: ${error.message}`);
      }
    }, config.servicesUpdateInterval);

  } catch (error) {
    logger.error(`Error crítico al inicializar el bot: ${error.message}`);
    process.exit(1);
  }
};

main().catch(err => {
  logger.error('Error fatal en main:', err);
  process.exit(1);
});

// Manejo de errores no capturados
process.on('uncaughtException', (error) => {
  logger.error(`Uncaught Exception: ${error.message}`);
  // Implementar lógica adicional si es necesario (por ejemplo, reiniciar el bot)
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error(`Unhandled Rejection at: ${promise}, reason: ${reason}`);
  // Implementar lógica adicional si es necesario
});


// commandProcessor.js

import logger from './utils/logger.js';
import userContextManager from './modules/userContext.js';
import orderManager from './modules/orderManager.js';
import openaiService from './services/openaiService.js';
import config from './config/config.js';
import sheetService from './services/sheetService.js'
import { formatPrice, sendSplitMessages } from './utils/helpers.js';
import { normalizeCommand, findClosestCommand, sanitizeJsonString } from './utils/commandUtils.js';
import { CustomError } from './utils/errorHandler.js';
import fileOptimizationService from './services/fileOptimizationService.js';

class CommandProcessor {
  constructor() {}

  async processCommand(command, userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Procesando comando para usuario ${userId}: ${JSON.stringify(command)}`);

      // Normalizar y corregir el comando
      const normalizedCommand = normalizeCommand(command.command);
      const correctedCommand = findClosestCommand(normalizedCommand) || normalizedCommand;
      
      logger.info(`Comando normalizado: ${normalizedCommand}, Comando corregido: ${correctedCommand}`);
      
      if (correctedCommand !== command.command) {
        logger.warn(`Comando corregido de "${command.command}" a "${correctedCommand}"`);
      }

      switch (correctedCommand) {
        case "LIST_ALL_SERVICES":
          return this.handleListAllServices(userId);
        case "SELECT_SERVICE":
          return this.handleSelectService(userId, command.service);
        case "SET_MEASURES":
          return this.handleSetMeasures(userId, command.width, command.height);
        case "SET_QUANTITY":
          return this.handleSetQuantity(userId, command.quantity);
        case "SET_FINISHES":
          return this.handleSetFinishes(userId, command.sellado, command.ojetillos, command.bolsillo);
        case "RESULT_ANALYSIS":
            return this.handleAnalysisResult(userId, command.result);
        case "CONFIRM_ORDER":
          return this.handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow });
        case "LIST_LAST_ORDERS":
          return this.handleListLastOrders(userId, flowDynamic);
        default:
          logger.warn(`Comando desconocido recibido: ${command.command}`);
          return { currentOrderUpdated: false };
      }
    } catch (error) {
      logger.error(`Error al procesar comando: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  // Nuevo método para manejar RESULT_ANALYSIS
  async handleAnalysisResult(userId, result) {
    try {
      const isValid = result === true || result === "true";
      userContextManager.updateCurrentOrder(userId, { fileValidation: isValid });
      logger.info(`Resultado del análisis actualizado para usuario ${userId}: ${isValid}`);
      return { currentOrderUpdated: true };
    } catch (error) {
      logger.error(`Error al actualizar resultado del análisis para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetQuantity(userId, quantity) {
    try {
      const result = await orderManager.handleSetQuantity(userId, quantity);
      logger.info(`Cantidad establecida para usuario ${userId}: ${quantity}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetFinishes(userId, sellado, ojetillos, bolsillo) {
    try {
      const result = await orderManager.setFinishes(userId, sellado, ojetillos, bolsillo);
      logger.info(`Acabados establecidos para usuario ${userId}: sellado=${sellado}, ojetillos=${ojetillos}, bolsillo=${bolsillo}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetMeasures(userId, width, height) {
    try {
      const result = await orderManager.handleSetMeasures(userId, width, height);
      logger.info(`Medidas establecidas para usuario ${userId}: ${width}x${height}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleFileAnalysis(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);
    const fileAnalysis = currentOrder.fileAnalysis;
 
    if (!fileAnalysis) {
      await flowDynamic("Lo siento, parece que no hay un archivo para analizar. Por favor, envía un archivo primero.");
      return;
    }
 
    logger.info(`Iniciando análisis de archivo para usuario ${userId}`);
    let response = "He analizado tu archivo. Aquí están los resultados:\n\n";
    response += `📄 Formato: *${fileAnalysis.format}*\n`;
    response += `📏 Dimensiones en píxeles: *${fileAnalysis.width}x${fileAnalysis.height}*\n`;
   
    const widthM = fileAnalysis.physicalWidth.toFixed(2);
    const heightM = fileAnalysis.physicalHeight.toFixed(2);
    response += `📐 Dimensiones físicas: *${widthM}x${heightM} m* (${(widthM*100).toFixed(2)}x${(heightM*100).toFixed(2)} cm)\n`;
   
    response += `📊 Área del diseño: *${fileAnalysis.area} m²*\n`;
    response += `🔍 Resolución: *${fileAnalysis.dpi} DPI*\n`;
   
    if (fileAnalysis.colorSpace) {
      response += `🎨 Espacio de color: *${fileAnalysis.colorSpace}*\n`;
    }
   
    if (fileAnalysis.fileSize) {
      response += `📦 Tamaño del archivo: *${fileAnalysis.fileSize}*\n`;
    }
 
    logger.info(`Análisis de archivo completado para usuario ${userId}: ${JSON.stringify(fileAnalysis)}`);
    await flowDynamic(response);
    userContextManager.updateFileAnalysisResponded(userId, true);

    // Generar y enviar el segundo mensaje
    await this.handleFileValidationInstruction(ctx, flowDynamic);
  }


async handleFileValidationInstruction(ctx, flowDynamic) {
  const userId = ctx.from;
  const currentOrder = userContextManager.getCurrentOrder(userId);

  logger.info(`Iniciando validación de archivo para usuario ${userId}`);

  // Verificar que el currentOrder está actualizado
  if (!currentOrder.service || (!currentOrder.measures && currentOrder.requiresMeasures())) {
      await flowDynamic("Parece que falta información en tu pedido. Por favor, asegúrate de haber proporcionado el servicio y las medidas necesarias.");
      return;
  }

  try {
      // Obtener optimización del archivo
      const fileInfo = currentOrder.fileAnalysis;
      if (!fileInfo) {
          throw new Error('No se encontró análisis del archivo');
      }

      // Calcular optimización usando el nuevo servicio
      const optimizationResult = fileOptimizationService.calculateOptimalDPI(
          currentOrder.areaServicio,
          fileInfo.fileSize,
          fileInfo.dpi
      );

      // Generar reporte técnico
      const technicalReport = fileOptimizationService.generateOptimizationReport(optimizationResult);
      logger.info("Reporte tecnico"),
      logger.info(technicalReport);
      // Mantener las guías DPI originales para contexto
      const dpiGuidelines = `
      📏 **Resolución (DPI) según el Área y Distancia de Visualización** 📐
  
      Ten en cuenta lo siguiente sobre la resolución (DPI) en función del área del servicio *${currentOrder.areaServicio} m²* y la distancia de visualización, aplicando a productos específicos de *Chileimprime*:
  
      - **Áreas pequeñas (menos de 1.0 m²)** 🖼️:
        - Se recomienda una resolución de *150-300 DPI* para obtener alta calidad.
        - Ideal para productos como *Tarjetas de presentación (1000 unidades)*, *Flyers 15×22 cms*, y *Mini Roller de escritorio papel sintético*, los cuales se observan de cerca (distancia menor a *1.5 metros*).
  
      - **Áreas medianas (1.5 m² a 5 m²)** 📊:
        - La resolución puede oscilar entre *72 y 150 DPI*.
        - Adecuada para *Pendones Roller 90x200 cms*, *Palomas 2 caras 70x120 cms*, y *PVC 11 Oz mt²*, que se visualizan desde distancias intermedias (*1.5 a 3 metros*).
  
      - **Áreas grandes (5 m² a 10 m²)** 📢:
        - Se recomienda una resolución entre *35 y 72 DPI*.
        - Ideal para *Back Light Banner*, *Tela Mesh* y *PVC Blackout*, que se verán a distancias de *3 a 5 metros*.
  
      - **Áreas muy grandes (más de 10 m²)** 🏢:
        - Resoluciones bajas, entre *20 y 35 DPI*, son aceptables debido a que estos gráficos se ven desde distancias mayores a *5 metros*.
        - Ejemplos: *Murales publicitarios*, *Back Light Textil*, o *Windows One Vision* que serán observados a grandes distancias.
  
      ### 📌 Notas Adicionales:
      1. **Distancia de Visualización** 👀: Es un factor crítico para determinar el DPI correcto. A mayor distancia, menor es la necesidad de alta resolución, ya que el ojo humano no distingue los detalles finos.
      2. **Tamaño del Archivo** 💾: Usar resoluciones demasiado altas en áreas grandes como *PVC Alta Definición* para grandes formatos incrementa significativamente el tamaño del archivo y el tiempo de impresión sin una mejora perceptible en la calidad visual.
      3. **Material Específico** 🧱: Productos como *Adhesivo Empavonado*, *Vinilo Adhesivo Reflectante* y *Rotulación para fundido* requieren considerar el material y su capacidad de impresión, por lo que es recomendable mantener el DPI en el rango medio de *72-150 DPI* para garantizar una buena nitidez.
  
      ✨ **Emojis y Formateo**:
      - Utiliza emojis relevantes para resaltar puntos importantes.
      - Aplica **formateo con asteriscos** usando un asterisco por lado (*texto*) para resaltar palabras clave.
      - Asegúrate de mantener una estructura clara con saltos de línea para facilitar la lectura en WhatsApp.
  
      Estas guías te ayudarán a optimizar la calidad y la eficiencia en cada proyecto de impresión según el tipo de producto y su aplicación en el mercado chileno.
      `;

      // Generar la instrucción para la IA combinando la información técnica
      const instruction = `🔄 **Nueva Solicitud de Archivo** 📂

      El usuario acaba de subir un archivo. Ahora eres un **experto en impresión de gran formato** e **ingeniero en color**. 
      
      Análisis Técnico del Archivo:
      ${technicalReport}

      Información del Pedido:
      - Servicio: *${currentOrder.service}*
      - Área: *${currentOrder.areaServicio} m²*
      - Medidas solicitadas: *${currentOrder.measures ? `${currentOrder.measures.width}x${currentOrder.measures.height} m` : 'No especificadas'}*
      
      Análisis del Archivo:
      - Formato: *${fileInfo.format}*
      - DPI actual: *${fileInfo.dpi}*
      - Área del diseño: *${fileInfo.area} m²*
      - Espacio de color: *${fileInfo.colorSpace}*
      
      Directrices DPI:
      ${dpiGuidelines}

      Criterios de Validación:
      ${userContextManager.getFileValidationCriteria()}

    ⚠️ **IMPORTANTE**:
    - Al inicio de tu respuesta, incluye el comando JSON:
      {"command": "RESULT_ANALYSIS", "result": true/false}
    
    - Estructura tu respuesta en 3 secciones:
      1. ### 🔍 Criterios de Validación Aplicados:
         - Solo mencionar los criterios relevantes para el archivo del cliente
         - NO incluir información sobre resolución de máquinas de impresión

      2. ### ✅/❌ Resultado de la Validación:
         Si el resultado es positivo:
         - Confirmar que el archivo es válido
         - Invitar al cliente a confirmar el pedido
         - Mencionar cualquier recomendación menor si aplica

         Si el resultado es negativo:
         - Explicar claramente por qué el archivo no es válido
         - Proporcionar recomendaciones específicas para corregir el archivo
         - Ofrecer la opción de aceptar el archivo bajo responsabilidad del cliente con el siguiente texto:
           "Si aún deseas proceder con este archivo a pesar de las observaciones mencionadas, puedes confirmar que aceptas 
           la impresión bajo tu responsabilidad, entendiendo que la calidad final podría verse afectada."

      3. ### 👉 Siguiente Paso:
         Si es válido:
         - Indicar que puede proceder a confirmar el pedido
         
         Si no es válido:
         - Indicar que puede subir un nuevo archivo corregido
         - O confirmar que acepta proceder bajo su responsabilidad
         - En caso de dudas, sugerir contactar con un agente.
      `;

      // Log para depuración
      logger.info(`Enviando instrucción a la IA para validación de archivo para usuario ${userId}`);
      logger.debug(`Instrucción completa: ${instruction}`);

      // Obtener respuesta de la IA
      const aiResponse = await openaiService.getChatCompletion(
          openaiService.getSystemPrompt(
              userContextManager.getGlobalServices(),
              currentOrder,
              userContextManager.getGlobalAdditionalInfo(),
              userContextManager.getChatContext(userId)
          ),
          userContextManager.getChatContext(userId).concat([
              { role: "system", content: instruction }
          ])
      );

      // Actualizar contexto
      userContextManager.updateContext(userId, instruction, "system");
      userContextManager.updateContext(userId, aiResponse, "assistant");

      // Actualizar optimización en el contexto
      userContextManager.updateCurrentOrder(userId, {
          fileOptimization: optimizationResult
      });

      // Procesar comandos en la respuesta
      const commands = this.processAIResponseCommandProcessor(aiResponse);
      for (const command of commands) {
          await this.processCommand(command, userId, ctx, { flowDynamic });
      }

      // Enviar respuesta al usuario
      await sendSplitMessages(flowDynamic, aiResponse);

      logger.info(`Validación de archivo completada para usuario ${userId}`);

  } catch (error) {
      logger.error(`Error en validación de archivo para usuario ${userId}: ${error.message}`);
      await flowDynamic("❌ Ha ocurrido un error al analizar tu archivo. Por favor, intenta nuevamente o contacta con soporte.");
  }
}

  processAIResponseCommandProcessor(aiResponse) {
    const commandRegex = /{[^}]+}/g;
    const commands = aiResponse.match(commandRegex) || [];
    return commands.map(cmd => {
      try {
        const sanitizedCmd = sanitizeJsonString(cmd);
        logger.debug(`Comando sanitizado: ${sanitizedCmd}`);
        const parsedCmd = JSON.parse(sanitizedCmd);
        logger.info(`Comando parseado correctamente: ${JSON.stringify(parsedCmd)}`);
        return parsedCmd;
      } catch (error) {
        logger.error(`Error al parsear comando JSON: ${error.message}`);
        logger.debug(`Comando problemático: ${cmd}`);
        return null;
      }
    }).filter(cmd => cmd !== null);
  }
  

  async handleListAllServices(userId, actions) {
    const services = sheetService.getServices();
    const formattedServices = this.formatServiceList(services);
    logger.info(`Lista de servicios preparada para usuario ${userId}`);
    
    return { 
      currentOrderUpdated: true, 
      action: 'SHOW_SERVICES',
      data: formattedServices
    };
  }

  formatServiceList(services) {
    let formattedList = "Aquí tienes la lista completa de servicios disponibles:\n\n";

    const categoryEmojis = {
      'Telas PVC': '🖼️',
      'Banderas': '🚩',
      'Adhesivos': '🏷️',
      'Adhesivo Vehicular': '🚗',
      'Back Light': '💡',
      'Otros': '📦',
      'Imprenta': '🖨️',
      'Péndon Roller': '🎞️',
      'Palomas': '🐦',
      'Figuras': '🔺',
      'Extras': '➕'
    };

    for (const [category, categoryServices] of Object.entries(services)) {
      const emojiIcon = categoryEmojis[category] || '';
      formattedList += `${emojiIcon} *${category}:*\n`;

      categoryServices.forEach(service => {
        const serviceName = service.name;
        const priceFormatted = formatPrice(service.precio);
        const priceBold = `*$${
          priceFormatted
        }*`; // Envuelve el precio con asteriscos para negrita
        formattedList += `- ${serviceName}: ${priceBold}\n`;
      });
      formattedList += "\n";
    }

    formattedList += "Para obtener más información sobre un servicio específico, por favor menciona su nombre.";
    return formattedList;
  }

  async handleSelectService(userId, serviceName) {
    if (!serviceName) {
      logger.warn(`Nombre de servicio inválido: ${serviceName}`);
      await flowDynamic('Parece que no has especificado un servicio válido. Por favor, indícanos qué servicio deseas.');
      return { currentOrderUpdated: false, error: 'El nombre del servicio es inválido o no se proporcionó.' };
    }

    try {
      const result = await orderManager.handleSelectService(userId, serviceName);
      logger.info(`Servicio seleccionado para usuario ${userId}: ${serviceName}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      await flowDynamic(`Lo siento, ha ocurrido un error al seleccionar el servicio. ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Iniciando proceso de confirmación de orden para usuario ${userId}`);

      // Verificar si la orden ya está confirmada
      if (orderManager.isOrderConfirmed(userId)) {
        logger.warn(`La orden para el usuario ${userId} ya ha sido confirmada. Evitando doble confirmación.`);
        await flowDynamic("✅ Tu pedido ya ha sido confirmado previamente. Si necesitas asistencia adicional, por favor contacta con un representante.");
        return { currentOrderUpdated: false };
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);

      // **Check if we're waiting for email confirmation**
      if (currentOrder.esperandoConfirmacionCorreo) {
        logger.info(`Esperando confirmación de correo para usuario ${userId}. Redirigiendo al flujo de confirmación de correo.`);
        return { currentOrderUpdated: false, nextFlow: 'emailConfirmationFlow' };
      }

      // **Check if email has been confirmed**
      if (!currentOrder.correoConfirmed) {
        logger.info(`Correo electrónico no confirmado para usuario ${userId}. Iniciando flujo de confirmación de correo.`);
        currentOrder.esperandoConfirmacionCorreo = true;
        return { currentOrderUpdated: false, nextFlow: 'emailConfirmationFlow' };
      }
      
      if (!userContextManager.isOrderComplete(userId)) {
        const missingFields = userContextManager.getIncompleteFields(userId);
        const errorMessage = `La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
        logger.warn(errorMessage);
        throw new CustomError('IncompleteOrderError', errorMessage);
      }

      // Añadir información del contexto
      currentOrder.userName = ctx.pushName || 'Cliente';
      currentOrder.userPhone = ctx.from;

      // **Modificación: Verificar si el correo ha sido confirmado**
      if (!currentOrder.correoConfirmed) {
        logger.info(`El correo electrónico no ha sido confirmado para el usuario ${userId}. Iniciando flujo de confirmación de correo.`);
        // Establecer bandera indicando que estamos esperando confirmación de correo
        currentOrder.esperandoConfirmacionCorreo = true;
        // Retornar indicando que se debe ir al flujo de confirmación de correo
        return { currentOrderUpdated: false, nextFlow: 'emailConfirmationFlow' };
      }

      // Calcular precios y actualizar la orden
      const calculatedPrices = orderManager.calculatePrice(currentOrder);
      currentOrder.precioTerminaciones = calculatedPrices.precioTerminaciones;
      currentOrder.precioTotalTerminaciones = calculatedPrices.precioTotalTerminaciones;
      currentOrder.total = calculatedPrices.total;

      logger.info(`Precios calculados para la orden: ${JSON.stringify(calculatedPrices)}`);

      const result = await orderManager.finalizeOrder(userId, currentOrder);
      
      if (result.success) {
        logger.info(`Pedido confirmado para usuario ${userId}. Número de pedido: ${result.orderNumber}`);

        // Enviar resumen de la orden
        const orderSummary = orderManager.formatOrderSummary(currentOrder);
        await flowDynamic(`🎉 ¡Gracias por tu pedido! Tu número de cotización es: *${result.orderNumber}*`);
        await flowDynamic(orderSummary);
        await flowDynamic(result.message);

        //return { currentOrderUpdated: true, nextFlow: 'promoFlow' }; //Legacy, ya no enviamos la promo
        return { currentOrderUpdated: true };
      } else {
        throw new Error("Error al confirmar el pedido");
      }
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      if (error.name === 'IncompleteOrderError') {
        const systemMessage = `Campos faltantes: ${error.message}`;
        userContextManager.updateContext(userId, systemMessage, "system");
        await flowDynamic("Lo siento, pero parece que falta información en tu pedido. Por favor, completa todos los detalles antes de confirmar.");
        return { currentOrderUpdated: false, error: error.message };
      } else {
        await flowDynamic("Lo siento, ha ocurrido un error al procesar tu pedido. Por favor, intenta nuevamente o contacta con nuestro equipo de soporte.");
        return { currentOrderUpdated: false, error: error.message };
      }
    }
  }



  async handleListLastOrders(userId, flowDynamic) {
    try {
        logger.info(`Solicitando últimos 10 pedidos para usuario ${userId}`);
        
        const orders = await sheetService.searchOrdersHistory(userId);
        
        if (!orders || orders.length === 0) {
            await flowDynamic("No se encontraron pedidos previos para tu número. ¿Te gustaría realizar tu primer pedido? 😊");
            logger.info(`No se encontraron pedidos para usuario ${userId}`);
            return { currentOrderUpdated: false };
        }

        // Crear mensaje formateado para WhatsApp
        let message = "*📋 Tus últimos pedidos:*\n\n";
        
        orders.forEach((order, index) => {
            message += `*${index + 1}.* Pedido: *${order.pedido}*\n`;
            message += `   📅 Fecha: ${order.fechaOriginal}\n`;
            if (order.servicio) {
                message += `   🖨️ Servicio: ${order.servicio}\n`;
            }
            if (order.estado) {
                message += `   📊 Estado: ${order.estado}\n`;
            }
            if (order.total) {
                try {
                    // Convertir el total a número y manejar diferentes formatos
                    let totalNumber;
                    if (typeof order.total === 'string') {
                        // Remover el símbolo de peso y cualquier punto de miles si existe
                        totalNumber = parseFloat(order.total.replace(/[$\.]/g, '').replace(',', '.'));
                    } else {
                        totalNumber = parseFloat(order.total);
                    }

                    if (!isNaN(totalNumber)) {
                        message += `   💰 Total: $${formatPrice(totalNumber)}\n`;
                    }
                    
                    logger.debug(`Total procesado para pedido ${order.pedido}: ${totalNumber}`);
                } catch (error) {
                    logger.warn(`Error al formatear precio para pedido ${order.pedido}: ${error.message}`);
                    // Si hay error en el formateo, mostrar el total sin formato
                    message += `   💰 Total: ${order.total}\n`;
                }
            }
            message += "\n";
        });

        message += "_Para consultar detalles específicos de un pedido o realizar un nuevo pedido, estoy aquí para ayudarte. 😊_";

        await flowDynamic(message);
        logger.info(`Lista de últimos pedidos enviada a usuario ${userId}`);
        
        return { currentOrderUpdated: false };
    } catch (error) {
        logger.error(`Error al obtener últimos pedidos para usuario ${userId}: ${error.message}`);
        logger.error(`Stack trace: ${error.stack}`); // Agregado para mejor debugging
        await flowDynamic("Lo siento, hubo un error al obtener tus pedidos anteriores. Por favor, intenta nuevamente más tarde. 😔");
        return { currentOrderUpdated: false, error: error.message };
    }
}



  
}

export default new CommandProcessor();


// config\config.js

// config/config.js

import dotenv from 'dotenv';
import { CustomError } from '../utils/errorHandler.js';

dotenv.config();

const requiredEnvVars = [
  'PORT',
  'GOOGLE_SHEET_ID',
  'OPENAI_API_KEY',
  'GOOGLE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_PRIVATE_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Google Drive: ${envVar}`);
  }
}

// variables de entorno para Google Drive
const requiredDriveEnvVars = [
  'GOOGLE_DRIVE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_DRIVE_PRIVATE_KEY',
  'GOOGLE_DRIVE_FOLDER_ID',
];

for (const envVar of requiredDriveEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Google Drive: ${envVar}`);
  }
}

//Variables gmail
const requiredGmailEnvVars = [
  'GMAIL_USER_EMAIL',
  'GMAIL_APP_PASSWORD',
];

for (const envVar of requiredGmailEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Gmail API: ${envVar}`);
  }
}

export default {
  port: process.env.PORT,
  googleSheetId: process.env.GOOGLE_SHEET_ID,
  openaiApiKey: process.env.OPENAI_API_KEY,
  googleServiceAccountEmail: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
  googlePrivateKey: process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  blacklistDuration: parseInt(process.env.BLACKLIST_DURATION) || 10 * 60 * 1000,
  humanBlacklistDuration: parseInt(process.env.HUMAN_BLACKLIST_DURATION) || 60 * 60 * 1000,
  abuseBlacklistDuration: parseInt(process.env.ABUSE_BLACKLIST_DURATION) || 24 * 60 * 60 * 1000,
  idleWarningTime: parseInt(process.env.IDLE_WARNING_TIME) || 5 * 60 * 1000,
  idleTimeoutTime: parseInt(process.env.IDLE_TIMEOUT_TIME) || 10 * 60 * 1000,
  maxAudioSize: parseInt(process.env.MAX_AUDIO_SIZE) || 5 * 1024 * 1024,
  languageModel: process.env.LANGUAGE_MODEL || 'ft:gpt-4o-mini-2024-07-18:personal:modelo-chile-imprime:AEWZI9XK',
  timezone: process.env.TIMEZONE || 'America/Santiago',
  logLevel: process.env.LOG_LEVEL || 'info',
  maxTokens: parseInt(process.env.MAX_TOKENS) || 2000,
  temperature: parseFloat(process.env.TEMPERATURE) || 0.5,
  messageQueueGapSeconds: parseInt(process.env.MESSAGE_QUEUE_GAP_SECONDS) || 3000,
  promoMessageDelay: parseInt(process.env.PROMO_MESSAGE_DELAY) || 15000,
  servicesUpdateInterval: parseInt(process.env.SERVICES_UPDATE_INTERVAL) || 60 * 60 * 1000,
   // Credenciales para Google Drive
   googleDriveServiceAccountEmail: process.env.GOOGLE_DRIVE_SERVICE_ACCOUNT_EMAIL,
   googleDrivePrivateKey: process.env.GOOGLE_DRIVE_PRIVATE_KEY.replace(/\\n/g, "\n"),
   googleDriveFolderId: process.env.GOOGLE_DRIVE_FOLDER_ID,
   // Credenciales para Gmail
   gmailAppPassword: process.env.GMAIL_APP_PASSWORD,
   gmailUserEmail: process.env.GMAIL_USER_EMAIL,
};


// core\blacklist-middleware.js

// core/blacklist-middleware.js

import logger from '../utils/logger.js';

const blacklistMiddleware = (flowManager) => async (ctx, { endFlow }) => {
  const userId = ctx.from;

  if (flowManager.isBlacklisted(userId)) {
    logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
    return endFlow();
  }

  return false; // Continuar con el flujo normal
};

export default blacklistMiddleware;


// core\inactivity-middleware.js

// core/inactivity-middleware.js

import logger from '../utils/logger.js';
import config from '../config/config.js';

const inactivityMiddleware = (flowManager) => async (ctx, { flowDynamic, gotoFlow }) => {
  const userId = ctx.from;

  // Verificar blacklist
  if (flowManager.isBlacklisted(userId)) {
    logger.info(`Usuario ${userId} en blacklist - omitiendo timers de inactividad`);
    return false;
  }

  flowManager.clearIdleTimer(userId);
  
  // Función auxiliar para verificar blacklist antes de ejecutar una acción
  const executeIfNotBlacklisted = async (action) => {
    if (!flowManager.isBlacklisted(userId)) {
      await action();
    }
  };

  const warningTimer = setTimeout(
    () => executeIfNotBlacklisted(async () => {
      await flowDynamic('*⏰ ¿Sigues ahí? Si necesitas más tiempo, por favor responde cualquier mensaje.*');
    }), 
    config.idleWarningTime
  );

  const timeoutTimer = setTimeout(
    () => executeIfNotBlacklisted(() => {
      flowManager.resetConversation(userId);
      gotoFlow(flowManager.getIdleTimeoutFlow());
    }), 
    config.idleTimeoutTime
  );

  flowManager.setIdleTimers(userId, { warningTimer, timeoutTimer });
  return false;
};

export default inactivityMiddleware;


// core\log-middleware.js

import logger from '../utils/logger.js';

const logMiddleware = async (ctx) => {
  const { from, body } = ctx;
  logger.info(`Mensaje recibido de ${from}: ${body}`);
  return false; // Continuar con el flujo normal
};

export default logMiddleware;


// core\middleware.js

// core/middleware.js

import logger from '../utils/logger.js';

const createMiddleware = (middlewares) => {
  return async (ctx, { flowDynamic, endFlow }) => {
    for (const middleware of middlewares) {
      try {
        const result = await middleware(ctx, { flowDynamic, endFlow });
        if (result === true) {
          return true; // Middleware ha manejado la solicitud, detener el flujo
        }
      } catch (error) {
        logger.error(`Error en middleware: ${error.message}`);
        await flowDynamic('Lo siento, ha ocurrido un error. Por favor, inténtalo de nuevo más tarde.');
        return endFlow();
      }
    }
    return false; // Continuar con el flujo normal
  };
};

export default createMiddleware;



// modules\flowManager.js

import { addKeyword, EVENTS } from '@builderbot/bot';
import logger from '../utils/logger.js';
import userContextManager from './userContext.js';
import orderManager from './orderManager.js';
import openaiService from '../services/openaiService.js';
import whatsappService from '../services/whatsappService.js';
import config from '../config/config.js';
import { CustomError } from '../utils/errorHandler.js';
import inactivityMiddleware from '../core/inactivity-middleware.js';
import blacklistMiddleware from '../core/blacklist-middleware.js';
import MessageQueue from './messageQueue.js';
import fileValidationService from '../services/fileValidationService.js';
import commandProcessor from '../commandProcessor.js';
import sheetService from '../services/sheetService.js';

class FlowManager {
  constructor() {
    this.flows = {
      principalFlow: null,
      confirmedFlow: null,
      restartBotFlow: null,
      documentFlow: null,
      voiceNoteFlow: null,
      catchAllFlow: null,
      idleTimeoutFlow: null,
      promoFlow: null,
      mediaFlow: null,
      emailConfirmationFlow: null, // Añadido para registrar el nuevo flujo

    };
    this.blacklist = new Map();
    this.idleTimers = new Map();
    this.messageQueue = new MessageQueue({ gapSeconds: config.messageQueueGapSeconds });
    this.cooldowns = new Map();
    this.initialMessagePromises = new Map();
    this.initialMessageLocks = new Map(); // Añade esta línea

  }


  async initializeFlows() {
    try {
      // Inicializar los flujos
      this.flows.principalFlow = this.createPrincipalFlow();
      this.flows.confirmedFlow = this.createConfirmedFlow();
      this.flows.restartBotFlow = this.createRestartBotFlow();
      this.flows.documentFlow = this.createDocumentFlow();
      this.flows.voiceNoteFlow = this.createVoiceNoteFlow();
      this.flows.catchAllFlow = this.createCatchAllFlow();
      this.flows.idleTimeoutFlow = this.createIdleTimeoutFlow();
      this.flows.promoFlow = this.createPromoFlow();
      this.flows.mediaFlow = this.createMediaFlow();
      this.flows.emailConfirmationFlow = this.createEmailConfirmationFlow(); // Inicializar el nuevo flujo


      // Agregar middlewares
      Object.values(this.flows).forEach(flow => {
        if (flow && typeof flow.addAction === 'function') {
          flow.addAction(inactivityMiddleware(this));
          flow.addAction(blacklistMiddleware(this));
        } else {
          logger.warn(`Un flujo no tiene el método addAction o es nulo`);
        }
      });

      logger.info('Flujos inicializados correctamente');
      return Object.values(this.flows).filter(flow => flow !== null);
    } catch (error) {
      logger.error(`Error al inicializar flujos: ${error.message}`);
      throw new CustomError('FlowInitializationError', 'Error al inicializar los flujos', error);
    }
  }


  getFlowByName(name) {
    return this.flows[name];
  }

  // Nuevo método centralizado para manejar mensajes iniciales
  async handleInitialMessagesOnce(userId, flowDynamic) {
    logger.info(`Intentando enviar mensajes iniciales para usuario ${userId}`);
    
    if (this.initialMessageLocks.get(userId)) {
      logger.info(`Usuario ${userId} ya tiene mensajes iniciales en proceso. Ignorando nueva solicitud.`);
      return;
    }

    this.initialMessageLocks.set(userId, true);

    if (!this.initialMessagePromises.has(userId)) {
      this.initialMessagePromises.set(userId, (async () => {
        if (!userContextManager.hasUserInteracted(userId)) {
          logger.info(`Iniciando envío de mensajes iniciales para usuario ${userId}`);

          try {
            // Crear una cola de mensajes
            const messageQueue = [
              { type: 'image', content: 'https://chileimprime.cl/wp-content/uploads/2024/10/Catalogo-marzo.jpg' },
              //{ type: 'services', content: await commandProcessor.handleListAllServices(userId) },
              { type: 'text', content: `👉 Selecciona uno de los servicios enviados para iniciar tu cotización.

También puedes realizar las siguientes acciones:
- 🔍 Ver tus últimos 10 pedidos.
- 🕒 Consultar horarios de atención
- 🎉 Conocer nuestras promociones actuales
- 🖨️ Resolver dudas sobre procesos de impresión
- 📄 Consultar especificaciones de archivos o parámetros técnicos
- 🎙️ Analizar archivos en tiempo real para evaluar validez.

Si necesitas contactar a un agente, por favor escribe *agente* o *humano.*

Para reiniciar el bot en cualquier momento, simplemente escribe *bot.*` }
            ];

            // Enviar mensajes de la cola con un intervalo
            for (const message of messageQueue) {
              switch (message.type) {
                case 'image':
                  await flowDynamic([{ body: 'Catalogo marzo 2024', media: message.content }]);
                  break;
                case 'services':
                  if (message.content && message.content.data) {
                    await flowDynamic(message.content.data);
                  }
                  break;
                case 'text':
                  await new Promise(resolve => setTimeout(resolve, 1000)); // Espera 1 segundo antes de enviar este mensaje
                  await flowDynamic(message.content);
                  break;
              }
              
            }

            userContextManager.setInitialMessagesSent(userId, true);
            userContextManager.setHasInteracted(userId, true);
            logger.info(`Mensajes iniciales enviados y estado actualizado para usuario ${userId}`);
          } catch (error) {
            logger.error(`Error al enviar mensajes iniciales para usuario ${userId}: ${error.message}`);
          } finally {
            this.initialMessageLocks.delete(userId);
          }
        } else {
          logger.info(`Usuario ${userId} ya ha interactuado, omitiendo mensajes iniciales`);
        }
      })());
    }

    await this.initialMessagePromises.get(userId);
    this.initialMessagePromises.delete(userId);
  }


  createEmailConfirmationFlow() {
    return addKeyword(EVENTS.WELCOME)
      .addAction(async (ctx, { flowDynamic, endFlow, gotoFlow }) => {
        const userId = ctx.from;
        const userContext = userContextManager.getUserContext(userId);
        
        logger.info(`Iniciando flujo de confirmación de correo para usuario ${userId}`);
        
        // **Check if we're waiting for a new email input**
        if (userContext.currentOrder.esperandoNuevoCorreo) {
          logger.info(`Esperando nuevo correo de usuario ${userId}: ${ctx.body}`);
          
          // **Validate the email**
          if (this.validateEmail(ctx.body.trim())) {
            logger.info(`Nuevo correo válido ingresado por usuario ${userId}: ${ctx.body.trim()}`);
            userContextManager.updateCorreo(userId, ctx.body.trim());
            userContext.currentOrder.correoConfirmed = true;
            userContext.currentOrder.esperandoNuevoCorreo = false;
            userContext.currentOrder.messageProcessed = true;
            await flowDynamic('✅ ¡Gracias! Continuaremos con el proceso.');

            // **Call handleConfirmOrder again to finalize the order**
            const result = await commandProcessor.handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow });
            if (result.nextFlow) {
              return gotoFlow(this.getFlowByName(result.nextFlow));
            } else {
              return;
            }

          } else {
            logger.warn(`Correo inválido ingresado por usuario ${userId}: ${ctx.body}`);
            userContext.currentOrder.messageProcessed = true;
            await flowDynamic('❌ El correo electrónico ingresado no es válido. Por favor, intenta nuevamente:');
            return;
          }
        } else {
          // **If not waiting for a new email, prompt the user**
          logger.info(`Solicitando correo electrónico al usuario ${userId}`);
          userContext.currentOrder.esperandoNuevoCorreo = true;
          await flowDynamic('Por favor, ingresa tu correo electrónico para continuar:');
          return;
        }
      });
  }

  // Método para validar el correo electrónico
  validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }




  // **Modificación: Remover redirección al flujo de correo al inicio**
  createPrincipalFlow() {
    return addKeyword(EVENTS.WELCOME)
      .addAction(async (ctx, { flowDynamic, gotoFlow, endFlow }) => {
        const userId = ctx.from;
        const userContext = userContextManager.getUserContext(userId);
  
        if (this.initialMessageLocks.get(userId)) {
          logger.info(`Ignorando mensaje de usuario ${userId} durante el envío de mensajes iniciales`);
          return;
        }
  
        // Removido: No redirigir al flujo de confirmación de correo al inicio

        if (!userContextManager.hasUserInteracted(userId)) {
          await this.handleInitialMessagesOnce(userId, flowDynamic);
        } else {
          this.enqueueMessage(userId, ctx.body, async (accumulatedMessage) => {
            await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
          });
        }
      });
  }

  createMediaFlow() {
    return addKeyword(EVENTS.MEDIA)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Imagen recibida de ${userId}. Enviando instrucciones específicas.`);

        userContextManager.setHasInteracted(userId, true);
  
        const messages = [
          '🖼️ *¡Hola!* Hemos recibido tu imagen, pero necesitamos que nos envíes tu diseño como *documento* para preservar la calidad.\n\nLas imágenes enviadas como foto en WhatsApp se comprimen y pierden calidad, lo que afecta el análisis y la impresión.\n\nPor favor, envía el mismo archivo como *documento* en uno de los siguientes formatos de alta calidad: *PDF, AI, PSD* o una imagen en alta resolución.\n\n*Criterios de Validación Resumidos:*\n\n- Resolución mínima: 72 dpi y máxima: 150 dpi.\n- Formato preferente: CMYK para evitar diferencias de color.\n- Tamaño real del diseño acorde al tamaño de impresión.',
          '📱 *Cómo enviar un documento en WhatsApp desde Android o iPhone:*\n\n1️⃣ Abre el chat de *Chileimprime*.\n2️⃣ Toca el ícono de *adjuntar* (📎).\n3️⃣ Selecciona *Documento*.\n4️⃣ Busca y selecciona tu archivo de diseño.\n5️⃣ Presiona *Enviar*.',
          '✨ *Esperamos tu archivo nuevamente como documento para iniciar el análisis.* ¡Gracias!'
        ];
  
        try {
          for (const message of messages) {
            await flowDynamic(message);
            logger.info(`Mensaje enviado a ${userId}: ${message.substring(0, 50)}...`);
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
          logger.info(`Instrucciones para imagen enviadas exitosamente a ${userId}`);
        } catch (error) {
          logger.error(`Error al enviar mensajes en mediaFlow para usuario ${userId}: ${error.message}`);
          await flowDynamic('⚠️ *Ha ocurrido un error al enviar las instrucciones. Por favor, intenta nuevamente más tarde.*');
        }
      });
  }
  

  createDocumentFlow() {
    return addKeyword(EVENTS.DOCUMENT)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Documento recibido de ${userId}. Iniciando análisis.`);
        userContextManager.setHasInteracted(userId, true);

        try {
          const filePath = await whatsappService.saveFile(ctx);
          logger.info(`Archivo guardado para usuario ${userId}: ${filePath}`);
  
          const fileInfo = await fileValidationService.analyzeFile(filePath);
          logger.info(`Análisis completado para archivo de usuario ${userId}: ${JSON.stringify(fileInfo)}`);
          
          await userContextManager.updateCurrentOrder(userId, {
            filePath: filePath,
            fileAnalysis: fileInfo
          });
          
          await flowDynamic('📄 Documento recibido. Analizando...');
  
          await commandProcessor.handleFileAnalysis(ctx, flowDynamic);
          
          logger.info(`Análisis de archivo enviado al usuario ${userId}`);
        } catch (error) {
          logger.error(`Error al procesar el documento para usuario ${userId}: ${error.message}`);
          await flowDynamic('❌ Hubo un error al procesar tu archivo. Por favor, intenta enviarlo nuevamente o contacta con soporte si el problema persiste.');
        }
      });
    }

    createConfirmedFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          // Modificación: Eliminar envío de "SOLICITUD_HUMANO"
          this.addToBlacklist(ctx.from, config.humanBlacklistDuration);
          logger.info(`Cotización ya confirmada para ${ctx.from}. Redirigiendo a atención humana.`);
          return endFlow();
        });
    }
    
      createRestartBotFlow() {
        return addKeyword(['bot', 'Bot', 'BOT'])
          .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
            const userId = ctx.from;
            logger.info(`Intento de reinicio de bot por usuario ${userId}`);
            this.resetConversation(userId, true); // Reiniciar initialMessagesSent
            logger.info(`Bot reiniciado para usuario ${userId}`);
            await flowDynamic('*¡Bienvenido de nuevo!* 🎉 El bot ha sido reiniciado. *¿En qué puedo ayudarte hoy?* 😊');
            return gotoFlow(this.flows.principalFlow);
          });
      }

    createVoiceNoteFlow() {
      return addKeyword(EVENTS.VOICE_NOTE)
        .addAction(async (ctx, { flowDynamic, state, gotoFlow, endFlow }) => {
          try {
            const audioPath = await whatsappService.saveAudioFile(ctx);
            const transcription = await openaiService.transcribeAudio(audioPath);
            logger.info(`Transcripción del audio: ${transcription}`);
            
            await state.update({ lastTranscription: transcription });
            await flowDynamic(`*📝 Transcripción:*\n${transcription}`);
    
            this.enqueueMessage(ctx.from, transcription, async (accumulatedMessage) => {
              await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
            });
          } catch (error) {
            logger.error(`Error al procesar la nota de voz: ${error.message}`);
            await flowDynamic('Hubo un error al procesar la nota de voz. Por favor, intenta enviar un mensaje de texto.');
          }
        });
    }
  
  
    createCatchAllFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { gotoFlow }) => {
          if (orderManager.isOrderConfirmed(ctx.from)) {
            return gotoFlow(this.flows.confirmedFlow);
          } else {
            return gotoFlow(this.flows.principalFlow);
          }
        });
    }
  
    createIdleTimeoutFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { endFlow }) => {
          logger.info(`Tiempo de espera agotado para usuario ${ctx.from}`);
          this.resetConversation(ctx.from);
          return endFlow('*😴 Lo siento, el tiempo de espera ha expirado. Tu cotización ha sido cancelada. Si deseas hacer una nueva cotización, por favor envía un mensaje.*');
        });
    }
  
    createPromoFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          const promoMessage = whatsappService.getPromoMessage();
          try {
            await flowDynamic(promoMessage);
            logger.info(`Mensaje promocional enviado a ${ctx.from}`);
          } catch (error) {
            logger.error(`Error al enviar mensaje promocional a ${ctx.from}: ${error.message}`);
          }
          return endFlow();
        });
    }
  
    enqueueMessage(userId, message, callback) {
      this.messageQueue.enqueueMessage(userId, message, callback);
    }
  
    async handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, message, instruction = '') {
      const userId = ctx.from;
      logger.info(`Procesando mensaje para usuario ${userId}: ${message}`);
  
      if (this.isBlacklisted(userId)) {
        logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }

      // Verificar palabras clave para atención humana
      const normalizedMessage = message.toLowerCase().trim();
      if (normalizedMessage === 'agente' || normalizedMessage === 'humano') {
        const result = await this.handleHumanAssistanceRequest(userId, flowDynamic);
        if (result.shouldEnd) {
          return endFlow();
        }
      }
  
      if (orderManager.isOrderConfirmed(userId)) {
        logger.info(`Cotización ya confirmada para ${userId}. Redirigiendo a atención humana.`);
        return gotoFlow(this.getFlowByName('confirmedFlow'));
      }
  
      this.startIdleTimer(ctx, flowDynamic, gotoFlow);
  
      try {
        const userContext = userContextManager.getUserContext(userId);
        const chatContext = userContextManager.getChatContext(userId);

        if (userContext.currentOrder.esperandoNuevoCorreo) {
          logger.info(`Usuario ${userId} está en el flujo de confirmación de correo. Redirigiendo a createEmailConfirmationFlow.`);
          return gotoFlow(this.getFlowByName('emailConfirmationFlow'));
        }
  
        let aiResponse = await openaiService.getChatCompletion(
          openaiService.getSystemPrompt(userContext.services, userContext.currentOrder, userContext.additionalInfo, chatContext),
          [...chatContext, { role: "user", content: message }],
          instruction
        );
  
        logger.info(`Respuesta inicial de AI para ${userId}: ${aiResponse}`);
  
        // Procesar comandos en la respuesta de la IA
        const commands = this.processAIResponse(aiResponse);
        let currentOrderUpdated = false;
        let missingFields = [];
        let responseHandled = false; // Nueva variable para controlar si la respuesta ya fue manejada
  
        for (const command of commands) {
          // Validar comando antes de procesarlo
          const { validatedCommand, responseSent } = await this.validateCommand(command, userId, aiResponse, message, ctx, flowDynamic);
          if (validatedCommand) {
            if (typeof validatedCommand === 'object') {
              const result = await commandProcessor.processCommand(validatedCommand, userId, ctx, { flowDynamic, gotoFlow, endFlow });
              if (result.currentOrderUpdated) {
                currentOrderUpdated = true;
              }
              if (result.missingFields && result.missingFields.length > 0) {
                missingFields = result.missingFields;
              }
              if (result.messagesSent) {
                logger.info(`Mensajes enviados por comando ${command.command} para ${userId}`);
              }
              if (result.data) {
                await flowDynamic(result.data);
                responseHandled = true;
              }

              if (result.nextFlow) {
                logger.info(`Redirigiendo al flujo ${result.nextFlow} para usuario ${userId}`);
                return gotoFlow(this.getFlowByName(result.nextFlow));
              }


            }
          }
  
          // Si la respuesta ya fue manejada en validateCommand, establecemos responseHandled en true
          if (responseSent) {
            responseHandled = true;
            break; // Salimos del bucle ya que la respuesta ha sido manejada
          }
        }
  
        // Solo enviar la respuesta original de la IA si no ha sido manejada ya
        if (!responseHandled) {
          const filteredResponse = this.filterJsonCommands(aiResponse);
          if (filteredResponse) {
            await flowDynamic(filteredResponse);
            // Actualizar el contexto con la respuesta enviada
            userContextManager.updateContext(userId, aiResponse, "assistant");
          }
        }
  
        // Actualizar el contexto con el mensaje del usuario
        userContextManager.updateContext(userId, message, "user");
  
        // Manejo de orden completa
        if (userContextManager.isOrderComplete(userId)) {
          logger.info(`Orden completa para ${userId}. Confirmando pedido.`);
          // Enviar comando de confirmación
          await commandProcessor.processCommand({ command: "CONFIRM_ORDER" }, userId, ctx, { flowDynamic, gotoFlow, endFlow });
          return gotoFlow(this.getFlowByName('confirmedFlow'));
        }
  
      } catch (error) {
        logger.error(`Error al procesar respuesta para usuario ${userId}: ${error.message}`);
        logger.error(`Stack trace: ${error.stack}`);
        await flowDynamic("Lo siento, ha ocurrido un error inesperado. Por favor, intenta nuevamente en unos momentos.");
      }
    }


  
    processAIResponse(aiResponse) {
      const commandRegex = /{[^}]+}/g;
      const commands = aiResponse.match(commandRegex) || [];
      return commands.map(cmd => {
        try {
          return JSON.parse(cmd);
        } catch (error) {
          logger.error(`Error al parsear comando JSON: ${error.message}`);
          return null;
        }
      }).filter(cmd => cmd !== null);
    }

    filterJsonCommands(aiResponse) {
      // Eliminar todos los comandos JSON de la respuesta
      return aiResponse.replace(/\{.*?\}/g, '').trim();
    }
  
    setIdleTimers(userId, timers) {
      this.idleTimers.set(userId, timers);
    }
  
    addToBlacklist(userId, duration) {
      this.blacklist.set(userId, Date.now() + duration);
      logger.info(`Usuario ${userId} añadido a la lista negra por ${duration/1000} segundos`);
    }
  
    isBlacklisted(userId) {
      if (this.blacklist.has(userId)) {
        const blacklistExpiry = this.blacklist.get(userId);
        if (Date.now() < blacklistExpiry) {
          logger.info(`Usuario ${userId} está en la lista negra. Tiempo restante: ${(blacklistExpiry - Date.now()) / 1000} segundos`);
          return true;
        } else {
          this.blacklist.delete(userId);
          this.resetConversation(userId);
          logger.info(`Usuario ${userId} removido de la lista negra`);
        }
      }
      return false;
    }
  
    resetConversation(userId, resetInitialMessages = false) {
      userContextManager.resetContext(userId, resetInitialMessages);
      orderManager.resetOrderConfirmation(userId);
      this.blacklist.delete(userId);
      this.clearIdleTimer(userId);
      logger.info(`Conversación reiniciada para usuario ${userId}, resetInitialMessages: ${resetInitialMessages}`);
    }
  
    startIdleTimer(ctx, flowDynamic, gotoFlow) {
      this.clearIdleTimer(ctx.from);
      
      const warningTimer = setTimeout(async () => {
        await flowDynamic('*⏰ ¿Sigues ahí? Si necesitas más tiempo, por favor responde cualquier mensaje.*');
      }, config.idleWarningTime);
  
      const timeoutTimer = setTimeout(() => {
        this.resetConversation(ctx.from);
        gotoFlow(this.getFlowByName('idleTimeoutFlow'));
      }, config.idleTimeoutTime);
  
      this.setIdleTimers(ctx.from, { warningTimer, timeoutTimer });
    }
  
    clearIdleTimer(userId) {
      const timers = this.idleTimers.get(userId);
      if (timers) {
        clearTimeout(timers.warningTimer);
        clearTimeout(timers.timeoutTimer);
        this.idleTimers.delete(userId);
      }
    }
  
    blacklistMiddleware(ctx, { endFlow }) {
      if (this.isBlacklisted(ctx.from)) {
        logger.info(`Usuario ${ctx.from} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
      return false;
    }

    async validateCommand(command, userId, assistantMessage, userMessage, ctx, flowDynamic) {
      if (command.command === "CONFIRM_ORDER") {
        if (!userContextManager.isOrderComplete(userId)) {
          const missingFields = userContextManager.getIncompleteFields(userId);
          logger.warn(`La orden está incompleta para el usuario ${userId}. Campos faltantes: ${missingFields.join(', ')}. Revaluando comando CONFIRM_ORDER.`);
  
          // Llamar primero a extractDataFromUserMessage
          const extractedCommand = await this.extractDataFromUserMessage(userMessage, userId);
  
          if (extractedCommand) {
            logger.info(`Comando extraído de extractDataFromUserMessage para usuario ${userId}: ${JSON.stringify(extractedCommand)}`);
  
            // Procesar el comando extraído
            await commandProcessor.processCommand(extractedCommand, userId, ctx, { flowDynamic });
  
            // Generar una instrucción para getChatCompletion
            const instruction = `
  El cliente acaba de ${this.getActionDescription(extractedCommand)}.
  
  Continúa la conversación con el cliente para avanzar en la cotización.
  
  Importante:
  - No incluyas ningún comando JSON en tu respuesta.
  - No muestres los comandos al cliente.
  - Responde de manera natural y amable, siguiendo las pautas del SystemPrompt.
  
  Responde al cliente:
            `;
  
            // Obtener el SystemPrompt actualizado
            const userContext = userContextManager.getUserContext(userId);
            const systemPrompt = openaiService.getSystemPrompt(
              userContext.services,
              userContext.currentOrder,
              userContext.additionalInfo,
              userContext.chatContext
            );
  
            // Llamar a getChatCompletion con la instrucción
            const aiResponse = await openaiService.getChatCompletion(
              systemPrompt,
              userContext.chatContext,
              instruction
            );
  
            // Actualizar el contexto
            userContextManager.updateContext(userId, aiResponse, "assistant");
  
            // Enviar la respuesta al cliente
            await flowDynamic(aiResponse);
  
            // Indicar que la respuesta ha sido manejada
            return { validatedCommand: null, responseSent: true };
          } else {
            // Si no se extrae un comando válido, proceder a reevaluateCommand
            const newCommandOrResponse = await this.reevaluateCommand(assistantMessage, userMessage, userId, missingFields);
  
            if (newCommandOrResponse) {
              // Procesar el nuevo comando si existe
              if (newCommandOrResponse.command) {
                logger.info(`Nuevo comando obtenido tras revaluación: ${JSON.stringify(newCommandOrResponse.command)}`);
                await commandProcessor.processCommand(newCommandOrResponse.command, userId, ctx, { flowDynamic });
              }
  
              // Enviar la respuesta al usuario si existe
              if (newCommandOrResponse.response) {
                await flowDynamic(newCommandOrResponse.response);
                userContextManager.updateContext(userId, newCommandOrResponse.response, "assistant");
              }
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            } else {
              // Actualizar el contexto del asistente con los campos faltantes
              const systemMessage = `Campos faltantes: La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
              userContextManager.updateContext(userId, systemMessage, "system");
  
              // Informar al usuario
              await flowDynamic("Parece que aún falta información para completar tu pedido. Por favor, proporciónanos los detalles faltantes.");
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            }
          }
        }
      }
      return { validatedCommand: command, responseSent: false };
    }  


    // Nueva función para describir la acción basada en el comando
    getActionDescription(command) {
      switch (command.command) {
        case "SELECT_SERVICE":
          return `seleccionado el servicio: ${command.service}`;
        case "SET_MEASURES":
          return `establecido las medidas: ancho ${command.width} m, alto ${command.height} m`;
        case "SET_QUANTITY":
          return `establecido la cantidad: ${command.quantity}`;
        case "SET_FINISHES":
          return `seleccionado las terminaciones: sellado ${command.sellado}, ojetillos ${command.ojetillos}, bolsillo ${command.bolsillo}`;
        default:
          return `realizado una acción`;
      }
    }




    // Nueva función extractDataFromUserMessage
    async extractDataFromUserMessage(userMessage, userId) {
      logger.info(`Intentando extraer comando del mensaje del usuario ${userId}: "${userMessage}"`);
  
      const chatContext = userContextManager.getChatContext(userId);
      const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');
  
      const currentOrder = userContextManager.getCurrentOrder(userId);
  
      const prompt = `
  Eres un asistente experto en impresión y gestión de pedidos. A partir del siguiente mensaje del usuario y el contexto de la conversación, extrae el comando apropiado para procesar su solicitud.
  
  Historial de la conversación:
  ${lastMessages}
  
  Mensaje del usuario:
  "${userMessage}"
  
  Información actual de la orden:
  ${JSON.stringify(currentOrder)}
  
  Lista de servicios disponibles:
  ${JSON.stringify(userContextManager.getAllServices())}
  
  Tu tarea es analizar el mensaje del usuario y, si es posible, extraer el comando adecuado para avanzar en el procesamiento de su pedido. Solo debes devolver un comando JSON válido si estás seguro de que el mensaje del usuario contiene la información necesaria.
  
  Posibles comandos:
  - {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}
  - {"command": "SET_MEASURES", "width": X, "height": Y}
  - {"command": "SET_QUANTITY", "quantity": Z}
  - {"command": "SET_FINISHES", "sellado": true/false, "ojetillos": true/false, "bolsillo": true/false}
  
  Si no es posible extraer un comando válido, no devuelvas nada.
  
  No debes devolver ninguna explicación ni texto adicional. Solo devuelve el comando JSON si es aplicable.
  `;
  
      try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de extractDataFromUserMessage para usuario ${userId}: ${aiResponse}`);
  
        // Intentar parsear la respuesta como JSON
        try {
          const extractedCommand = JSON.parse(aiResponse);
          return extractedCommand;
        } catch (parseError) {
          logger.warn(`No se pudo parsear el comando extraído para usuario ${userId}: ${parseError.message}`);
          return null;
        }
      } catch (error) {
        logger.error(`Error al extraer comando del mensaje del usuario ${userId}: ${error.message}`);
        return null;
      }
    }


  async reevaluateCommand(assistantMessage, userMessage, userId, missingFields) {
    logger.info(`Reevaluando comando para usuario ${userId}`);

    // Obtener el historial reciente de la conversación
    const chatContext = userContextManager.getChatContext(userId);
    const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');

    // Obtener la lista de servicios disponibles
    const services = userContextManager.getGlobalServices();
    const servicesList = Object.values(services).flat().map(service => service.name).join(', ');
    const currentOrder = userContextManager.getCurrentOrder(userId);

    // Modificación del prompt para evitar que el asistente asuma valores por defecto
    const prompt = `
Eres un asistente experto en impresión y gestión de pedidos. Aquí está la última interacción:

${lastMessages}

Basado en esta interacción y el estado actual de la orden:
${JSON.stringify(userContextManager.getCurrentOrder(userId))}

Presta especial atención a los siguientes detalles del currentOrder:
- Servicio actual: ${currentOrder.service || 'No seleccionado'}
- Categoría: ${currentOrder.category || 'No especificada'}
- Tipo: ${currentOrder.type || 'No especificado'}
- Medidas seleccionadas: 
  * Ancho: ${currentOrder.measures?.width || 'No especificado'} metros
  * Alto: ${currentOrder.measures?.height || 'No especificado'} metros
- Terminaciones elegidas: 
  * Sellado: ${currentOrder.finishes?.sellado ? 'Sí' : 'No'}
  * Ojetillos: ${currentOrder.finishes?.ojetillos ? 'Sí' : 'No'}
  * Bolsillo: ${currentOrder.finishes?.bolsillo ? 'Sí' : 'No'}
- Cantidad: ${currentOrder.quantity || 'No especificada'}
- Archivo de diseño: ${currentOrder.filePath ? 'Subido' : 'No subido'}
- Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
- Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
- Área del servicio: ${currentOrder.areaServicio || 'No calculada'} m²

Lista de servicios disponibles: ${servicesList}

Los campos faltantes en la orden son: ${missingFields.join(', ')}

Tu objetivo es ayudar al usuario a completar la información faltante sin asumir ningún valor por defecto. No debes asignar valores a campos faltantes a menos que el usuario los haya proporcionado explícitamente.

Analiza si el comando 'CONFIRM_ORDER' es apropiado. Si la orden está incompleta, determina la mejor respuesta posible al usuario para ayudarlo a proporcionar la información faltante.

Recuerda:
- No asumas servicios o valores que el usuario no haya mencionado explícitamente.
- Si el usuario está confirmando la selección de un servicio, pero no ha proporcionado el nombre del servicio, pídele amablemente que especifique el servicio que desea.
- Proporciona una respuesta clara y amable que guíe al usuario a proporcionar la información faltante.

No debes devolver ningún comando en este caso. Responde al usuario de manera que continúe la conversación y facilite la obtención de la información necesaria.
    `;

    try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de reevaluación del modelo para usuario ${userId}: ${aiResponse}`);

        // Como hemos instruido al asistente a no devolver comandos, procesamos solo la respuesta
        return { command: null, response: aiResponse.trim() };
    } catch (error) {
        logger.error(`Error al reevaluar comando para usuario ${userId}: ${error.message}`);
        return null;
    }
  }



   // Nueva función auxiliar para manejar atención humana
   async handleHumanAssistanceRequest(userId, flowDynamic) {
    logger.info(`Procesando solicitud de atención humana para usuario ${userId}`);
    
    try {
      const additionalInfo = userContextManager.getGlobalAdditionalInfo();
      const responseMessage = this.createHumanAssistanceMessage(additionalInfo.horarios);
      
      // Agregar a blacklist y limpiar timers
      this.addToBlacklist(userId, config.humanBlacklistDuration);
      this.clearIdleTimer(userId);
      
      await flowDynamic(responseMessage);
      logger.info(`Usuario ${userId} redirigido exitosamente a atención humana`);
      
      return {
        success: true,
        shouldEnd: true
      };
    } catch (error) {
      logger.error(`Error al procesar solicitud de atención humana para ${userId}: ${error.message}`);
      await flowDynamic('Lo siento, ha ocurrido un error. Un agente se pondrá en contacto contigo pronto.');
      return {
        success: false,
        shouldEnd: true,
        error: error
      };
    }
  }

  // Nueva función auxiliar para crear el mensaje de atención humana
  createHumanAssistanceMessage(horarios = {}) {
    const defaultHorarios = {
      'Lunes a viernes': '9:00 - 18:00 hrs',
      'Sábados': '9:00 - 14:00 hrs'
    };

    const horariosActuales = {
      ...defaultHorarios,
      ...horarios
    };

    return `👋 Entiendo que prefieres hablar con un agente humano.
Un representante de nuestro equipo se pondrá en contacto contigo lo antes posible.

⏰ Horario de atención:
Lunes a Viernes: ${horariosActuales['Lunes a viernes']}
Sábados: ${horariosActuales['Sábados']}

🙏 Gracias por tu paciencia.`;
    }




  }
  
  export default new FlowManager();


// modules\messageQueue.js

// modules/messageQueue.js

import logger from '../utils/logger.js';

class MessageQueue {
  constructor(config) {
    this.queue = new Map();
    this.config = config;
  }

  enqueueMessage(userId, messageText, callback) {
    logger.info(`Encolando mensaje para usuario ${userId}. Mensaje: ${messageText}`);
    
    if (!this.queue.has(userId)) {
      this.queue.set(userId, { messages: [], timer: null });
      logger.info(`Nueva cola creada para usuario ${userId}`);
    }

    const userQueue = this.queue.get(userId);
    userQueue.messages.push(messageText);

    logger.info(`Mensaje añadido a la cola del usuario ${userId}. Mensajes en cola: ${userQueue.messages.length}`);

    clearTimeout(userQueue.timer);

    userQueue.timer = setTimeout(() => {
      logger.info(`Temporizador expirado para usuario ${userId}. Procesando cola...`);
      const messages = userQueue.messages;
      this.queue.delete(userId);
      logger.info(`Cola procesada y eliminada para usuario ${userId}. Mensajes procesados: ${messages.length}`);
      if (typeof callback === 'function') {
        try {
          callback(messages.join(" "));
        } catch (error) {
          logger.error(`Error en el callback para usuario ${userId}: ${error.message}`);
        }
      }
    }, this.config.gapSeconds);
  }

  clearQueue(userId) {
    if (this.queue.has(userId)) {
      const userQueue = this.queue.get(userId);
      clearTimeout(userQueue.timer);
      this.queue.delete(userId);
      logger.info(`Cola eliminada para usuario ${userId}`);
    }
  }

  getQueueSize(userId) {
    if (this.queue.has(userId)) {
      return this.queue.get(userId).messages.length;
    }
    return 0;
  }

  isQueueEmpty(userId) {
    return this.getQueueSize(userId) === 0;
  }
}

export default MessageQueue;


// modules\orderManager.js

import logger from '../utils/logger.js';
import { formatPrice, censorPhoneNumber } from '../utils/helpers.js';
import moment from 'moment-timezone';
import config from '../config/config.js';
import sheetService from '../services/sheetService.js';
import userContextManager from './userContext.js';
import { CustomError } from '../utils/errorHandler.js';
import googleDriveService from '../services/googleDriveService.js';
import emailService from '../services/emailService.js'; // Modificado

class OrderManager {
  constructor() {
    this.orderConfirmed = new Set();
  }

  async handleSelectService(userId, serviceName) {
    logger.info(`Manejando selección de servicio para usuario ${userId}: ${serviceName}`);
    try {
      const serviceInfo = userContextManager.getServiceInfo(serviceName);
      
      if (!serviceInfo) {
        const similarServices = userContextManager.findSimilarServices(serviceName);
        return {
          action: "INVALID_SERVICE",
          similarServices,
          order: userContextManager.getCurrentOrder(userId)
        };
      }

      userContextManager.updateCurrentOrder(userId, { 
        service: serviceName,
        category: serviceInfo.category,
        availableWidths: serviceInfo.availableWidths,
        availableFinishes: userContextManager.getAvailableFinishes(serviceInfo)
      });
      
      return {
        action: "SELECT_SERVICE",
        order: userContextManager.getCurrentOrder(userId),
        serviceInfo: serviceInfo
      };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      throw new CustomError('ServiceSelectionError', 'Error al seleccionar el servicio', error);
    }
  }

  async handleSetMeasures(userId, width, height) {
    logger.info(`Manejando configuración de medidas para usuario ${userId}: ${width}x${height}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        throw new CustomError('InvalidMeasuresError', 'Este servicio no requiere medidas personalizadas');
      }

      const validWidth = serviceInfo.availableWidths.find(w => w.material === parseFloat(width));
      if (!validWidth) {
        throw new CustomError('InvalidWidthError', 'Ancho no válido para este servicio');
      }

      if (parseFloat(height) < 1) {
        throw new CustomError('InvalidHeightError', 'El alto debe ser mayor o igual a 1 metro');
      }

      const measures = { width: validWidth.material, height: parseFloat(height) };
      const areaServicio = measures.width * measures.height; // Calcular área del servicio
      const { total, area } = this.calculatePrice({ ...currentOrder, measures });

      userContextManager.updateCurrentOrder(userId, { measures, areaServicio, total, area }); // Actualizar areaServicio

      return {
        action: "SET_MEASURES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      throw new CustomError('MeasuresSetupError', 'Error al configurar las medidas', error);
    }
  }

  async handleSetQuantity(userId, quantity) {
    logger.info(`Manejando configuración de cantidad para usuario ${userId}: ${quantity}`);
    try {
      if (quantity <= 0) {
        throw new CustomError('InvalidQuantityError', 'La cantidad debe ser mayor que cero');
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        // Para categorías sin medidas personalizadas, calculamos el precio directamente
        const { total } = this.calculatePrice({ ...currentOrder, quantity });
        userContextManager.updateCurrentOrder(userId, { quantity, total });
      } else {
        userContextManager.updateCurrentOrder(userId, { quantity });
      }

      return {
        action: "SET_QUANTITY",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      throw new CustomError('QuantitySetupError', 'Error al configurar la cantidad', error);
    }
  }

  async setFinishes(userId, sellado, ojetillos, bolsillo) {
    logger.info(`Manejando configuración de acabados para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      const finishes = {
        sellado: sellado && serviceInfo.sellado,
        ojetillos: ojetillos && serviceInfo.ojetillos,
        bolsillo: bolsillo && serviceInfo.bolsillo
      };

      userContextManager.updateCurrentOrder(userId, { finishes: finishes});

      return {
        action: "SET_FINISHES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      throw new CustomError('FinishesSetupError', 'Error al configurar los acabados', error);
    }
  }

  async handleValidateFile(userId, isValid, reason) {
    logger.info(`Manejando validación de archivo para usuario ${userId}`);
    try {
      userContextManager.updateCurrentOrder(userId, {
        fileAnalysis: { isValid, reason }
      });
      
      return {
        action: "VALIDATE_FILE",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al validar archivo para usuario ${userId}: ${error.message}`);
      throw new CustomError('FileValidationError', 'Error al validar el archivo', error);
    }
  }

  async handleConfirmOrder(userId) {
    logger.info(`Manejando confirmación de pedido para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        
         // NUEVO: Lanzar excepción con detalles de campos faltantes
         const missingFields = userContextManager.getIncompleteFields(userId);
         const errorMessage = `La orden no está completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
         logger.warn(errorMessage);
         throw new CustomError('IncompleteOrderError', errorMessage);
      }

      const total = this.calculatePrice(currentOrder);
      userContextManager.updateCurrentOrder(userId, { total: total });

      const orderSummary = this.formatOrderSummary(currentOrder);
      const result = await this.finalizeOrder(userId, currentOrder);

      this.orderConfirmed.add(userId);

      return {
        action: "CONFIRM_ORDER",
        order: currentOrder,
        summary: orderSummary,
        result: result
      };
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      throw new CustomError(error.name || 'OrderConfirmationError', error.message);
    }
  }

  calculatePrice(order) {
    const serviceInfo = userContextManager.getServiceInfo(order.service);
  
    let total = 0;
    let area = 1;
    let precioM2 = serviceInfo.precio;
    let precioTerminaciones = 0;
    let precioTotalTerminaciones = 0;
  
    logger.info(`Calculando precio para orden: ${JSON.stringify(order)}`);
    logger.info(`Información del servicio: ${JSON.stringify(serviceInfo)}`);
  
    if (['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
      area = order.measures.width * order.measures.height;
      total = area * precioM2 * order.quantity;
  
      // Calcula el precio de las terminaciones por m2
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      // Calcula el precio total de las terminaciones
      precioTotalTerminaciones = precioTerminaciones * area * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por m2: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    } else {
      total = precioM2 * order.quantity;
  
      // Para servicios sin medidas, calculamos las terminaciones por unidad
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      precioTotalTerminaciones = precioTerminaciones * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por unidad: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    }
  
    const precioBase = area * precioM2 * order.quantity;
  
    logger.info(`Precio base: ${precioBase}`);
    logger.info(`Precio total: ${total}`);
  
    return { 
      total, 
      area, 
      precioM2, 
      precioBase, 
      precioTerminaciones, 
      precioTotalTerminaciones
    };
  }

  formatOrderSummary(order) {
    let summary = "📋 *Resumen de tu cotización:*\n\n";

    summary += `🛍️ *Servicio:* ${order.service}\n`;

    if (order.measures) {
      summary += `📐 *Medidas:* ${order.measures.width}m x ${order.measures.height}m\n`;
      summary += `📏 *Área:* ${order.area} m²\n`;
    }

    summary += `🔢 *Cantidad:* ${order.quantity}\n`;

    if (order.finishes && order.finishes.length > 0) {
      summary += `🎨 *Terminaciones:*\n`;
      order.finishes.forEach(finish => {
        summary += `- ${finish}\n`;
      });
    }

    summary += `💵 *Total:* $${formatPrice(order.total)}\n`;

    return summary;
  }

  async finalizeOrder(userId, order) {
    logger.info(`Finalizando orden para usuario ${userId}`);
    
    const calculatedPrices = this.calculatePrice(order);
    const finalOrder = {
      fecha: moment().tz(config.timezone).format('DD-MM-YYYY HH:mm:ss'),
      telefono: userId,
      nombre: order.userName || 'Cliente',
      servicio: order.service,
      cantidad: order.quantity,
      measures: order.measures,
      area: calculatedPrices.area,
      precioM2: calculatedPrices.precioM2,
      precioBase: calculatedPrices.precioBase,
      terminaciones: Object.entries(order.finishes)
        .filter(([_, value]) => value)
        .map(([key, _]) => key),
      precioTerminaciones: calculatedPrices.precioTerminaciones,
      precioTotalTerminaciones: calculatedPrices.precioTotalTerminaciones,
      total: calculatedPrices.total,
      observaciones: order.observaciones || 'Sin observaciones',
      fileUrl: order.fileUrl,
      correo: order.correo, // Incluir el correo electrónico en el pedido final
    };
  
    logger.info(`Orden final para usuario ${userId}: ${JSON.stringify(finalOrder)}`);
  
    try {
      const result = await sheetService.saveOrder(finalOrder);

      logger.info(`Resultado de guardado para usuario ${userId}: ${JSON.stringify(result)}`);

      if (result.success) {
        this.orderConfirmed.add(userId);
        logger.info(`Cotización finalizada y guardada correctamente para usuario ${userId}`);

        const orderNumber = result.orderNumber;
        
        // Subir archivo y enviar correo electrónico de forma asincrona
        if (order.filePath) {
          this.uploadFileAndSendEmail(order.filePath, userId, orderNumber, finalOrder);
        }

        return {
          success: true,
          message: "Tu cotización ha sido registrada. Un representante se pondrá en contacto contigo pronto para confirmar los detalles y coordinar la entrega de los archivos finales.",
          orderNumber: orderNumber,
        };
      } else {
        throw new Error("Error al guardar la cotización");
      }
    } catch (error) {
      logger.error(`Error detallado al finalizar la cotización para usuario ${userId}:`, error);
      throw new CustomError('OrderFinalizationError', 'Error al finalizar la cotización', error);
    }
  }

  // Nuevo método para manejar la subida del archivo y el envío del correo
  uploadFileAndSendEmail(filePath, userId, orderNumber, finalOrder) {
    // No usamos await aquí para no bloquear
    (async () => {
      try {
        const fileUrl = await this.uploadFileToDrive(filePath, userId, orderNumber);
        finalOrder.fileUrl = fileUrl;
        // Actualizar el pedido en Google Sheets con la URL del archivo
        await sheetService.updateOrderWithFileUrl(orderNumber, fileUrl);
        await emailService.sendEmail(finalOrder, orderNumber);
        logger.info(`Archivo subido y correo enviado para el pedido ${orderNumber}`);
      } catch (error) {
        logger.error(`Error al subir el archivo y enviar el correo para el pedido ${orderNumber}: ${error.message}`);
        // Manejar el error según sea necesario
      }
    })();
  }


  async uploadFileToDrive(filePath, userPhone, orderNumber) {
    try {
      // Formatear la fecha de manera legible
      const dateFormatted = moment().tz(config.timezone).format('DD-MM-YYYY-HH_mm');
      const fileName = `Pedido_${orderNumber}_${userPhone}_${dateFormatted}`;
      const mimeType = 'application/octet-stream'; // Ajustar según el tipo de archivo

      logger.info(`Iniciando subida de archivo para el pedido ${orderNumber}`);

      const fileUrl = await googleDriveService.uploadFile(filePath, fileName, mimeType);

      logger.info(`Archivo subido correctamente. URL: ${fileUrl}`);

      // Actualizar la hoja de cálculo con la URL del archivo
      await sheetService.updateOrderWithFileUrl(orderNumber, fileUrl);

      logger.info(`Hoja de cálculo actualizada con la URL del archivo para el pedido ${orderNumber}`);

      return fileUrl; // Añadido: retornar la URL del archivo
    } catch (error) {
      logger.error(`Error al subir archivo a Google Drive para el pedido ${orderNumber}: ${error.message}`);
      throw error; // Lanzar el error para manejarlo en el llamado
    }
  }




  formatOrderForSheet(order) {
    let details = `Servicio: ${order.service}\n`;
    
    if (order.measures) {
      details += `Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    
    details += `Cantidad: ${order.quantity}\n`;
    
    if (order.finishes) {
      details += "Terminaciones:\n";
      if (order.finishes.sellado) details += "- Sellado\n";
      if (order.finishes.ojetillos) details += "- Ojetillos\n";
      if (order.finishes.bolsillo) details += "- Bolsillo\n";
    }
    
    return details.trim();
  }

  isOrderConfirmed(userId) {
    return this.orderConfirmed.has(userId);
  }

  resetOrderConfirmation(userId) {
    this.orderConfirmed.delete(userId);
  }
}

export default new OrderManager();


// modules\userContext.js

import logger from '../utils/logger.js';
import sheetService from '../services/sheetService.js';

class UserContextManager {
  constructor() {
    this.userContexts = new Map();
  }

  // Método existente para obtener el contexto del usuario
  getUserContext(userId) {
    if (!this.userContexts.has(userId)) {
      this.userContexts.set(userId, {
        context: "",
        chatContext: [],
        currentOrder: this.getEmptyOrder(),
        services: sheetService.getServices(),
        additionalInfo: sheetService.getAdditionalInfo(),
        initialMessagesSent: false,
        hasInteracted: false  // Nuevo estado para rastrear cualquier interacción
      });
      logger.info(`Nuevo contexto creado para usuario ${userId}`);
    }
    return this.userContexts.get(userId);
  }

  getEmptyOrder() {
    return {
      service: null,
      category: null,
      type: null,
      measures: null,
      finishes: {
        sellado: false,
        ojetillos: false,
        bolsillo: false
      },
      quantity: null,
      filePath: null,
      fileAnalysis: null,
      fileAnalysisResponded: false,
      fileAnalysisHandled: false,
      fileValidation: null,
      availableWidths: [],
      availableFinishes: [],
      price: 0,
      areaServicio: null,
      correo: null, // Añadido para almacenar el correo electrónico del usuario
      correoConfirmed: false, // Para indicar si el correo ha sido confirmado
      esperandoConfirmacionCorreo: false, // **Añadido**
      messageProcessed: false, // **Añadido si no estaba ya**
    };
  }

  // **Modificación: Actualizar método updateCorreo**
  updateCorreo(userId, correo) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.correo = correo;
    userContext.currentOrder.correoConfirmed = true;
    userContext.currentOrder.esperandoConfirmacionCorreo = false; // Reset this flag
    logger.info(`Correo electrónico actualizado y confirmado para usuario ${userId}: ${correo}`);
  }

  setInitialMessagesSent(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.initialMessagesSent = value;
    userContext.hasInteracted = true;
    logger.info(`Estado de mensajes iniciales y interacción actualizados para usuario ${userId}: ${value}`);
  }

  setHasInteracted(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.hasInteracted = value;
    logger.info(`Estado de interacción actualizado para usuario ${userId}: ${value}`);
  }

  hasUserInteracted(userId) {
    return this.getUserContext(userId).hasInteracted;
  }

  updateContext(userId, message, role) {
    const userContext = this.getUserContext(userId);
    userContext.context += `${role}: ${message}\n`;
    userContext.chatContext.push({ role, content: message });
    this.limitContextSize(userId);
    logger.info(`Contexto actualizado para usuario ${userId}. Mensajes en contexto: ${userContext.chatContext.length}`);
  }

  limitContextSize(userId) {
    const userContext = this.getUserContext(userId);
    if (userContext.chatContext.length > 30) {
      userContext.chatContext = userContext.chatContext.slice(-10);
    }
    const words = userContext.context.split(/\s+/);
    if (words.length > 1500) {
      userContext.context = words.slice(-1500).join(" ");
    }
    logger.info(`Contexto limitado para usuario ${userId}`);
  }

  setGlobalData(services, additionalInfo) {
    this.services = services;
    this.additionalInfo = additionalInfo;
    logger.info('Datos globales actualizados en UserContextManager');
    logger.info(`Menú global: ${JSON.stringify(this.services)}`);
    logger.info(`Información adicional global: ${JSON.stringify(this.additionalInfo)}`);
  }

  updateCurrentOrder(userId, updates) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder = { ...userContext.currentOrder, ...updates };
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
    
    if (updates.service) {
      const serviceInfo = sheetService.getServiceInfo(updates.service);
      if (serviceInfo) {
        userContext.currentOrder.category = serviceInfo.category;
        userContext.currentOrder.type = serviceInfo.type;
        userContext.currentOrder.availableWidths = serviceInfo.availableWidths;
        userContext.currentOrder.availableFinishes = {
          sellado: serviceInfo.sellado,
          ojetillos: serviceInfo.ojetillos,
          bolsillo: serviceInfo.bolsillo
        };
        userContext.currentOrder.fileValidationCriteria = {
          format: serviceInfo.format,
          minDPI: serviceInfo.minDPI,
        };
        logger.info(`Servicio seleccionado para usuario ${userId}: ${JSON.stringify(serviceInfo)}`);
      } else {
        logger.warn(`Servicio no encontrado: ${updates.service}`);
      }
    }

    if (updates.fileAnalysis) {
      userContext.currentOrder.fileAnalysisResponded = false;
    }

    if (updates.fileValidation) {
      userContext.currentOrder.fileValidation = updates.fileValidation;
    }
    
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
  }

  updateFileAnalysisResponded(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisResponded = value;
    logger.info(`FileAnalysisResponded actualizado para usuario ${userId}: ${value}`);
  }

  updateFileAnalysisHandled(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisHandled = value;
    logger.info(`FileAnalysisHandled actualizado para usuario ${userId}: ${value}`);
  }

  hasFileAnalysisBeenResponded(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisResponded;
  }

  hasFileAnalysisBeenHandled(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisHandled;
  }

  getCurrentOrder(userId) {
    const userContext = this.getUserContext(userId);
    const currentOrder = userContext.currentOrder;
    currentOrder.requiresMeasures = () => this.isServiceRequiringMeasures(currentOrder.category);
    logger.info(`Obteniendo orden actual para usuario ${userId}: ${JSON.stringify(currentOrder)}`);
    return currentOrder;
  }

  resetContext(userId, resetInitialMessages = false) {
    const userContext = this.getUserContext(userId);
    const initialMessagesSent = resetInitialMessages ? false : userContext.initialMessagesSent;
    this.userContexts.set(userId, {
      context: "",
      chatContext: [],
      currentOrder: this.getEmptyOrder(),
      services: sheetService.getServices(),
      additionalInfo: sheetService.getAdditionalInfo(),
      initialMessagesSent: initialMessagesSent,
      hasInteracted: false  // Reiniciar hasInteracted
    });
    logger.info(`Contexto reiniciado para usuario ${userId}, initialMessagesSent preserved: ${!resetInitialMessages}, hasInteracted reset`);
  }

  getGlobalServices() {
    return sheetService.getServices();
  }

  getGlobalAdditionalInfo() {
    return sheetService.getAdditionalInfo();
  }

  getServiceInfo(serviceName) {
    return sheetService.getServiceInfo(serviceName);
  }

  getAllServices() {
    return sheetService.getAllServices();
  }

  findSimilarServices(serviceName) {
    return sheetService.findSimilarServices(serviceName);
  }

  getServicesInCategory(category) {
    return sheetService.getServicesInCategory(category);
  }

  getFileValidationCriteria() {
    return sheetService.getFileValidationCriteria();
  }

  getAvailableFinishes(serviceInfo) {
    const finishes = [];
    if (serviceInfo.sellado) finishes.push("sellado");
    if (serviceInfo.ojetillos) finishes.push("ojetillos");
    if (serviceInfo.bolsillo) finishes.push("bolsillo");
    return finishes;
  }

  // NUEVO: Función para obtener los campos faltantes en la orden actual
  getIncompleteFields(userId) {
    const order = this.getCurrentOrder(userId);
    const missingFields = [];

    // Verificar campos obligatorios
    if (!order.service) missingFields.push('service');
    if (!order.quantity) missingFields.push('quantity');
    if (!order.filePath) missingFields.push('filePath');
    if (!order.fileAnalysis) missingFields.push('fileAnalysis');
    if (!order.fileAnalysisResponded) missingFields.push('fileAnalysisResponded');
    if (!order.fileValidation) missingFields.push('fileValidation');

    // Verificar si el servicio requiere medidas
    if (this.isServiceRequiringMeasures(order.category)) {
      if (!order.measures || !order.measures.width) missingFields.push('width');
      if (!order.measures || !order.measures.height) missingFields.push('height');
      if (!order.areaServicio) missingFields.push('areaServicio');
    }

    logger.info(`Campos faltantes para usuario ${userId}: ${missingFields.join(', ')}`);

    return missingFields;
  }

  // MODIFICADO: isOrderComplete ahora utiliza getIncompleteFields
  isOrderComplete(userId) {
    const missingFields = this.getIncompleteFields(userId);
    return missingFields.length === 0;
  }


    // Método para determinar si el servicio requiere medidas
    isServiceRequiringMeasures(serviceCategory) {
      return ['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceCategory);
    }
  
  
  getChatContext(userId) {
    return this.getUserContext(userId).chatContext;
  }
}

export default new UserContextManager();


// services\emailService.js

// Archivo: services/emailService.js

import nodemailer from 'nodemailer';
import config from '../config/config.js';
import logger from '../utils/logger.js';

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: config.gmailUserEmail,
        pass: config.gmailAppPassword, // Contraseña de aplicación
      },
    });

    logger.info('Servicio de correo electrónico inicializado correctamente con Nodemailer');
  }

  async sendEmail(order, orderNumber) {
    try {
      const emailSubject = `Cotización ${orderNumber} recibida`;
      const emailBody = this.constructEmailBody(order, orderNumber);

      const mailOptions = {
        from: config.gmailUserEmail,
        to: config.gmailUserEmail, // Enviar a tu propia cuenta
        subject: emailSubject,
        text: emailBody,
      };

      logger.info(`Enviando correo electrónico para la cotización ${orderNumber}`);

      await this.transporter.sendMail(mailOptions);

      logger.info(`Correo electrónico enviado correctamente para la cotización ${orderNumber}`);
    } catch (error) {
      logger.error(`Error al enviar correo electrónico para la cotización ${orderNumber}: ${error.message}`);
      // Manejo adicional de errores si es necesario
    }
  }

  constructEmailBody(order, orderNumber) {
    let body = `Estimado equipo,\n\n`;
    body += `Se ha recibido una nueva cotización con el número ${orderNumber}.\n\n`;
    body += `Detalles de la cotización:\n`;
    body += `- Fecha: ${order.fecha}\n`;
    body += `- Cliente: ${order.nombre}\n`;
    body += `- Teléfono: ${order.telefono}\n`;
    body += `- Servicio: ${order.servicio}\n`;
    if (order.measures) {
      body += `- Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    body += `- Cantidad: ${order.cantidad}\n`;
    if (order.area) {
      body += `- Área: ${order.area} m²\n`;
    }
    if (order.terminaciones && order.terminaciones.length > 0) {
      body += `- Terminaciones: ${order.terminaciones.join(', ')}\n`;
    }
    body += `- Precio Total: $${order.total}\n`;
    if (order.observaciones) {
      body += `- Observaciones: ${order.observaciones}\n`;
    }
    if (order.fileUrl) {
      body += `- Enlace al archivo en Google Drive: ${order.fileUrl}\n`;
    }
    body += `\nPor favor, procedan con el seguimiento correspondiente.\n\nSaludos,\nBot de Chileimprime`;

    return body;
  }
}

export default new EmailService();



// services\fileOptimizationService.js

// services/fileOptimizationService.js
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';

class FileOptimizationService {
    constructor() {
        // Constantes del sistema
        this.MACHINE_MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024; // 2GB en bytes
        this.MIN_ACCEPTABLE_FILE_SIZE = 100 * 1024; // 100KB mínimo
        this.MAX_ACCEPTABLE_DPI = 300; // DPI máximo absoluto
        this.BYTES_PER_PIXEL_ESTIMATE = 4; // Estimación de bytes por pixel (CMYK)
        
        // Configuración de DPI por área
        this.DPI_RULES = [
            { maxArea: 1, minDPI: 150, maxDPI: 300, viewDistance: 1, tolerance: 0.2 },
            { maxArea: 3, minDPI: 100, maxDPI: 150, viewDistance: 2, tolerance: 0.25 },
            { maxArea: 5, minDPI: 75, maxDPI: 100, viewDistance: 3, tolerance: 0.3 },
            { maxArea: 10, minDPI: 50, maxDPI: 75, viewDistance: 5, tolerance: 0.35 },
            { maxArea: 15, minDPI: 35, maxDPI: 50, viewDistance: 7, tolerance: 0.4 },
            { maxArea: 20, minDPI: 25, maxDPI: 35, viewDistance: 10, tolerance: 0.45 },
            { maxArea: 30, minDPI: 15, maxDPI: 25, viewDistance: 15, tolerance: 0.5 },
            { maxArea: 50, minDPI: 10, maxDPI: 20, viewDistance: 20, tolerance: 0.55 },
            { maxArea: Infinity, minDPI: 8, maxDPI: 12, viewDistance: 25, tolerance: 0.6 }
        ];

        this.validateConfiguration();
    }

    validateConfiguration() {
        try {
            for (let i = 0; i < this.DPI_RULES.length - 1; i++) {
                if (this.DPI_RULES[i].maxArea >= this.DPI_RULES[i + 1].maxArea) {
                    throw new Error('Las reglas de DPI deben estar ordenadas por maxArea');
                }
            }

            for (const rule of this.DPI_RULES) {
                if (rule.minDPI > rule.maxDPI) {
                    throw new Error('minDPI no puede ser mayor que maxDPI');
                }
                if (rule.tolerance < 0 || rule.tolerance > 1) {
                    throw new Error('La tolerancia debe estar entre 0 y 1');
                }
            }
            
            logger.info('Configuración de FileOptimizationService validada correctamente');
        } catch (error) {
            logger.error(`Error en la configuración de FileOptimizationService: ${error.message}`);
            throw new CustomError('ConfigurationError', 'Error en la configuración del servicio de optimización', error);
        }
    }

    validateInputParameters(area, currentFileSize, currentDPI) {
        if (!area || area <= 0) {
            throw new CustomError('ValidationError', 'El área debe ser un número positivo');
        }
        if (!currentFileSize || currentFileSize < this.MIN_ACCEPTABLE_FILE_SIZE) {
            throw new CustomError('ValidationError', 'Tamaño de archivo inválido');
        }
        if (!currentDPI || currentDPI <= 0 || currentDPI > this.MAX_ACCEPTABLE_DPI) {
            throw new CustomError('ValidationError', 'DPI fuera de rango aceptable');
        }
    }

    calculateOptimalDPI(area, currentFileSize, currentDPI) {
        try {
            this.validateInputParameters(area, currentFileSize, currentDPI);
            
            logger.info(`Calculando DPI óptimo para área: ${area}m², tamaño actual: ${currentFileSize} bytes, DPI actual: ${currentDPI}`);

            const rule = this.DPI_RULES.find(r => area <= r.maxArea);
            if (!rule) {
                throw new CustomError('ValidationError', `No se encontró regla para área: ${area}m²`);
            }

            // Calcular ratio de reducción necesario basado en tamaño de archivo
            const sizeRatio = currentFileSize / this.MACHINE_MAX_FILE_SIZE;
            let targetDPI = currentDPI;

            if (sizeRatio > 1) {
                targetDPI = Math.floor(currentDPI / Math.sqrt(sizeRatio));
                logger.info(`Reducción de DPI necesaria. Ratio: ${sizeRatio}, Nuevo DPI objetivo: ${targetDPI}`);
            }

            // Ajustar dentro de los límites de la regla
            targetDPI = Math.max(rule.minDPI, Math.min(targetDPI, rule.maxDPI));

            // Calcular estimación de nuevo tamaño
            const estimatedNewSize = this.calculateEstimatedFileSize(area, targetDPI);

            const result = {
                originalDPI: currentDPI,
                recommendedDPI: targetDPI,
                minAcceptableDPI: rule.minDPI,
                maxAcceptableDPI: rule.maxDPI,
                tolerance: rule.tolerance,
                viewDistance: rule.viewDistance,
                willReduceFileSize: targetDPI < currentDPI,
                estimatedNewSize: estimatedNewSize,
                originalSize: currentFileSize,
                isWithinLimits: targetDPI >= rule.minDPI && targetDPI <= rule.maxDPI,
                requiresOptimization: sizeRatio > 1,
                area: area,
                sizeReductionRatio: targetDPI < currentDPI ? (estimatedNewSize / currentFileSize) : 1,
                qualityImpact: this.calculateQualityImpact(currentDPI, targetDPI)
            };

            logger.info(`Análisis de optimización completado: ${JSON.stringify(result)}`);
            return result;

        } catch (error) {
            logger.error(`Error en cálculo de DPI óptimo: ${error.message}`);
            throw error;
        }
    }

    calculateEstimatedFileSize(area, dpi) {
        const areaInInches = area * 1550.0031;
        const totalPixels = areaInInches * dpi * dpi;
        return Math.floor(totalPixels * this.BYTES_PER_PIXEL_ESTIMATE);
    }

    calculateQualityImpact(originalDPI, newDPI) {
        const ratio = newDPI / originalDPI;
        if (ratio >= 1) return 'ninguno';
        if (ratio >= 0.8) return 'mínimo';
        if (ratio >= 0.6) return 'moderado';
        if (ratio >= 0.4) return 'significativo';
        return 'alto';
    }

    generateOptimizationReport(optimizationResult) {
        const sizeInGB = (size) => (size / (1024 * 1024 * 1024)).toFixed(2);
        
        return `
### 📊 *Análisis de Optimización*

1. 🎯 *DPI y Resolución*:
   - DPI Actual: *${optimizationResult.originalDPI}*
   - DPI Recomendado: *${optimizationResult.recommendedDPI}*
   - Rango Aceptable: *${optimizationResult.minAcceptableDPI} - ${optimizationResult.maxAcceptableDPI}*
   - Impacto en Calidad: *${optimizationResult.qualityImpact}*

2. 📏 *Distancia de Visualización*:
   - Distancia Óptima: *${optimizationResult.viewDistance} metros*
   - Tolerancia Permitida: *${(optimizationResult.tolerance * 100).toFixed(0)}%*

3. 💾 *Análisis de Archivo*:
   - Tamaño Actual: *${sizeInGB(optimizationResult.originalSize)} GB*
   - Tamaño Estimado Después de Optimización: *${sizeInGB(optimizationResult.estimatedNewSize)} GB*
   ${optimizationResult.requiresOptimization ? 
     `⚠️ *Se requiere optimización para procesamiento*\n   Razón: El archivo excede el límite de ${sizeInGB(this.MACHINE_MAX_FILE_SIZE)} GB` : 
     '✅ *Tamaño dentro de límites aceptables*'}

4. 🔧 *Recomendaciones*:
   ${this.generateRecommendations(optimizationResult)}

5. ℹ️ *Información Adicional*:
   - Área de Impresión: *${optimizationResult.area.toFixed(2)} m²*
   - Categoría de Impresión: *${this.getAreaCategory(optimizationResult.area)}*
   ${this.generateAdditionalNotes(optimizationResult)}
`;
    }

    getAreaCategory(area) {
        if (area <= 1) return "Pequeño formato";
        if (area <= 5) return "Formato mediano";
        if (area <= 20) return "Gran formato";
        return "Formato extra grande";
    }

    generateRecommendations(result) {
        const recommendations = [];

        if (result.requiresOptimization) {
            recommendations.push(`- Reducir el DPI a *${result.recommendedDPI}* para optimizar el procesamiento`);
            recommendations.push(`- Utilizar compresión de imagen preservando la calidad visual`);
            
            if (result.qualityImpact !== 'mínimo') {
                recommendations.push(`- Considerar dividir el diseño en secciones si requiere mayor calidad`);
            }
        }

        if (result.originalDPI > result.maxAcceptableDPI) {
            recommendations.push(`- El DPI actual es excesivo para el área de impresión`);
            recommendations.push(`- Reducir a máximo *${result.maxAcceptableDPI} DPI* para mejor rendimiento`);
        }

        if (result.area > 20) {
            recommendations.push(`- Considerar técnicas de optimización específicas para impresiones de gran formato`);
            recommendations.push(`- Verificar la compatibilidad del diseño con visualización a distancia`);
        }

        // Recomendaciones específicas según el tamaño del archivo
        if (result.originalSize > this.MACHINE_MAX_FILE_SIZE * 0.8) {
            recommendations.push(`- ⚠️ El archivo está cerca o supera el límite máximo de *2GB*`);
            recommendations.push(`- Considerar reducir el DPI o dividir el diseño en secciones`);
        }

        // Recomendaciones de color
        if (result.colorSpace && result.colorSpace !== 'CMYK') {
            recommendations.push(`- Convertir el archivo a modo de color *CMYK* para mejor fidelidad de impresión`);
        }

        if (recommendations.length === 0) {
            recommendations.push(`✅ Archivo óptimo para impresión`);
        }

        return recommendations.join('\n   ');
    }

    generateAdditionalNotes(result) {
        const notes = [];

        // Notas sobre visualización
        if (result.area > 10) {
            notes.push(`- Para este tamaño de impresión, la visualización óptima es desde *${result.viewDistance} metros*`);
        }

        // Notas sobre optimización
        if (result.requiresOptimization) {
            notes.push(`- La optimización sugerida mantendrá la calidad visual apropiada para la distancia de visualización`);
            
            if (result.sizeReductionRatio < 0.5) {
                notes.push(`- La reducción significativa del tamaño del archivo mejorará el tiempo de procesamiento`);
            }
        }

        // Notas sobre calidad
        if (result.qualityImpact !== 'ninguno') {
            notes.push(`- El impacto en la calidad será *${result.qualityImpact}*, pero no será perceptible a la distancia de visualización recomendada`);
            
            if (result.qualityImpact === 'significativo' || result.qualityImpact === 'alto') {
                notes.push(`- Se recomienda realizar una prueba de impresión en un área pequeña antes de proceder con la impresión completa`);
            }
        }

        // Notas sobre el formato de archivo
        if (result.area > 30) {
            notes.push(`- Para impresiones de gran formato, asegúrate de que las marcas de corte y sangrado estén correctamente definidas`);
        }

        return notes.length > 0 ? notes.join('\n   ') : '';
    }

    // Método auxiliar para conversión de bytes a unidad legible
    formatFileSize(bytes) {
        const units = ['B', 'KB', 'MB', 'GB'];
        let size = bytes;
        let unitIndex = 0;
        
        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }
        
        return `${size.toFixed(2)} ${units[unitIndex]}`;
    }

    // Método para validar si un archivo puede ser procesado
    canProcessFile(fileSize) {
        if (fileSize > this.MACHINE_MAX_FILE_SIZE) {
            logger.warn(`Archivo demasiado grande: ${this.formatFileSize(fileSize)}`);
            return false;
        }
        return true;
    }

    // Método para sugerir división de archivo
    suggestFileSplitting(area, currentDPI) {
        const currentPixels = area * 1550.0031 * currentDPI * currentDPI;
        const maxPixels = this.MACHINE_MAX_FILE_SIZE / this.BYTES_PER_PIXEL_ESTIMATE;
        
        if (currentPixels > maxPixels) {
            const recommendedSections = Math.ceil(currentPixels / maxPixels);
            const sectionArea = area / recommendedSections;
            
            return {
                needsSplitting: true,
                recommendedSections,
                sectionArea: sectionArea.toFixed(2),
                recommendation: `Se recomienda dividir el diseño en ${recommendedSections} secciones de aproximadamente ${sectionArea.toFixed(2)} m² cada una`
            };
        }
        
        return { needsSplitting: false };
    }
}

export default new FileOptimizationService();


// services\fileValidationService.js

// services/fileValidationService.js

import fs from 'fs';
import { promisify } from 'util';
import path from 'path';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import sharp from 'sharp';
import fileType from 'file-type';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const pdfParse = require('pdf-parse');

const readFile = promisify(fs.readFile);

class FileValidationService {
  constructor() {
    this.supportedFormats = ['jpg', 'jpeg', 'png', 'pdf', 'ai', 'psd', 'cdr'];
  }

  async analyzeFile(filePath) {
    try {
      if (!fs.existsSync(filePath)) {
        throw new CustomError('FileNotFoundError', `El archivo no existe: ${filePath}`);
      }

      const fileStats = fs.statSync(filePath);
      const fileSize = this.formatFileSize(fileStats.size);

      const buffer = await readFile(filePath);
      const fileTypeResult = await fileType.fromBuffer(buffer);
      const fileExtension = fileTypeResult ? fileTypeResult.ext : path.extname(filePath).toLowerCase().slice(1);

      if (!this.supportedFormats.includes(fileExtension)) {
        return {
          format: fileExtension,
          supported: false,
          reason: `Formato de archivo no soportado: ${fileExtension}`,
          fileSize: fileSize
        };
      }

      let fileInfo;
      if (['jpg', 'jpeg', 'png'].includes(fileExtension)) {
        fileInfo = await this.analyzeImage(buffer);
      } else if (fileExtension === 'pdf') {
        fileInfo = await this.analyzePDF(buffer);
      } else {
        fileInfo = { format: fileExtension };
      }

      fileInfo.mimeType = fileTypeResult ? fileTypeResult.mime : '';
      fileInfo.supported = true;
      fileInfo.fileSize = fileSize;
      return fileInfo;
    } catch (error) {
      logger.error(`Error al analizar el archivo: ${error.message}`);
      throw new CustomError('FileAnalysisError', 'Error al analizar el archivo', error);
    }
  }

  async analyzeImage(buffer) {
    const image = sharp(buffer);
    const metadata = await image.metadata();

    //logger.info(`Metadatos de la imagen: ${JSON.stringify(metadata)}`);

    const { physicalWidth, physicalHeight } = this.calculatePhysicalDimensions(metadata.width, metadata.height, metadata.density || 72);
    const area = this.calculateDesignArea(physicalWidth, physicalHeight);

    const colorSpace = metadata.space || 'desconocido';
    const colorSpaceInfo = colorSpace.toLowerCase() !== 'cmyk' 
      ? `${colorSpace} (Se recomienda encarecidamente usar CMYK para evitar diferencias de color entre lo que se ve en el monitor y lo que realmente se imprime)`
      : colorSpace;

    logger.info(`Análisis de imagen completado: ${physicalWidth}x${physicalHeight} m, ${area} m², ${colorSpaceInfo}`);

    return {
      format: metadata.format,
      width: metadata.width,
      height: metadata.height,
      dpi: metadata.density || 72,
      colorSpace: colorSpaceInfo,
      physicalWidth,
      physicalHeight,
      area
    };
  }

  async analyzePDF(buffer) {
    try {
      const data = await pdfParse(buffer);

      // Asumir dimensiones estándar si no se pueden obtener
      const width = 595; // A4 width in points
      const height = 842; // A4 height in points
      const dpi = 72; // Asumimos 72 DPI para PDFs

      const { physicalWidth, physicalHeight } = this.calculatePhysicalDimensions(width, height, dpi);
      const area = this.calculateDesignArea(physicalWidth, physicalHeight);

      return {
        format: 'pdf',
        pages: data.numpages,
        width,
        height,
        dpi,
        physicalWidth,
        physicalHeight,
        area
      };
    } catch (error) {
      logger.error(`Error al analizar PDF: ${error.message}`);
      throw new CustomError('PDFAnalysisError', 'Error al analizar el archivo PDF', error);
    }
  }

  calculatePhysicalDimensions(widthPixels, heightPixels, dpi) {
    logger.info(`Calculando dimensiones físicas: ${widthPixels}x${heightPixels} píxeles, ${dpi} DPI`);
    
    // Convertir píxeles a pulgadas
    const widthInches = widthPixels / dpi;
    const heightInches = heightPixels / dpi;
    
    // Convertir pulgadas a metros (1 pulgada = 0.0254 metros)
    const widthMeters = widthInches * 0.0254;
    const heightMeters = heightInches * 0.0254;
    
    // Redondear a dos decimales
    const physicalWidth = Number(widthMeters.toFixed(2));
    const physicalHeight = Number(heightMeters.toFixed(2));
    
    logger.info(`Dimensiones físicas calculadas: ${physicalWidth}x${physicalHeight} metros`);
    
    return { physicalWidth, physicalHeight };
  }

  calculateDesignArea(widthM, heightM) {
    const areaM2 = widthM * heightM;
    const roundedArea = Number(areaM2.toFixed(2));
    logger.info(`Área calculada: ${roundedArea} m²`);
    return roundedArea;
  }

  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}

export default new FileValidationService();



// services\googleDriveService.js

// Archivo: services/googleDriveService.js

import { google } from 'googleapis';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import fs from 'fs';

class GoogleDriveService {
  constructor() {
    this.driveClient = null;
    this.initializeDriveClient();
  }

  initializeDriveClient() {
    try {
      const auth = new google.auth.JWT(
        config.googleDriveServiceAccountEmail,
        null,
        config.googleDrivePrivateKey,
        ['https://www.googleapis.com/auth/drive']
      );

      this.driveClient = google.drive({
        version: 'v3',
        auth: auth,
      });

      logger.info('Cliente de Google Drive inicializado correctamente con nuevas credenciales');
    } catch (error) {
      logger.error(`Error al inicializar el cliente de Google Drive: ${error.message}`);
    }
  }

  async uploadFile(filePath, fileName, mimeType) {
    try {
      const fileMetadata = {
        name: fileName,
        parents: [config.googleDriveFolderId], // ID de la carpeta en Google Drive donde se guardarán los archivos
      };

      const media = {
        mimeType: mimeType,
        body: fs.createReadStream(filePath),
      };

      logger.info(`Iniciando subida de archivo a Google Drive: ${fileName}`);

      const response = await this.driveClient.files.create({
        resource: fileMetadata,
        media: media,
        fields: 'id, webViewLink',
      });

      logger.info(`Archivo subido a Google Drive. ID: ${response.data.id}`);

      // Hacer el archivo accesible (opcional)
      await this.driveClient.permissions.create({
        fileId: response.data.id,
        requestBody: {
          role: 'reader',
          type: 'anyone',
        },
      });

      return response.data.webViewLink;
    } catch (error) {
      logger.error(`Error al subir archivo a Google Drive: ${error.message}`);
      throw error;
    }
  }
}

export default new GoogleDriveService();



// services\openaiService.js

// services/openaiService.js

import OpenAI from "openai";
import fs from 'fs';
import { promises as fsPromises } from 'fs';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import userContextManager from '../modules/userContext.js';
import { formatPrice } from '../utils/helpers.js';

class OpenAIService {
  constructor() {
    this.openai = new OpenAI({ apiKey: config.openaiApiKey });
  }

  async getChatCompletion(systemPrompt, context, instruction = '') {
    try {
      const messages = [
        { role: "system", content: systemPrompt },
        ...context
      ];

      if (instruction) {
        messages.push({ role: "system", content: instruction });
      }

      const response = await this.openai.chat.completions.create({
        model: config.languageModel,
        messages: messages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
      });

      return response.choices[0].message.content.trim();
    } catch (error) {
      logger.error("Error al obtener respuesta de OpenAI:", error);
      throw new CustomError('OpenAIError', 'Error al obtener respuesta de OpenAI', error);
    }
  }

  getSystemPrompt(services, currentOrder, additionalInfo, chatContext) {
    const contextStr = chatContext.map(msg => `${msg.role}: ${msg.content}`).join('\n');
    const allServices = this.getAllServicesInfo(services);
    const criteria = userContextManager.getFileValidationCriteria();
    console.log("****historial****");
    console.log(contextStr);
    console.log("****fin historial****");
    //console.log(JSON.stringify(allServices, null, 2));

      // NUEVO: Incluir información sobre campos faltantes
      const missingFieldsMessage = chatContext.find(msg => msg.role === 'system' && msg.content.startsWith('Campos faltantes:'));
      let missingFieldsInfo = '';
      if (missingFieldsMessage) {
        missingFieldsInfo = missingFieldsMessage.content;
      }

    let fileValidationInfo = "";
    if (currentOrder.fileAnalysis) {
      fileValidationInfo = `
      Información detallada del análisis del archivo:
      📄 Formato: ${currentOrder.fileAnalysis.format}
      📏 Dimensiones en píxeles: ${currentOrder.fileAnalysis.width}x${currentOrder.fileAnalysis.height}
      📐 Dimensiones físicas: ${currentOrder.fileAnalysis.physicalWidth.toFixed(2)}x${currentOrder.fileAnalysis.physicalHeight.toFixed(2)} m
      📊 Área del diseño: ${currentOrder.fileAnalysis.area.toFixed(2)} m²
      🔍 Resolución: ${currentOrder.fileAnalysis.dpi} DPI
      🎨 Espacio de color: ${currentOrder.fileAnalysis.colorSpace}
      📦 Tamaño del archivo: ${currentOrder.fileAnalysis.fileSize || 'No disponible'}
      `;
    }

    return `Eres un asistente experto en servicios de imprenta llamada Chileimprime. Tu objetivo es guiar al cliente a través del proceso de cotización para un único servicio de impresión. Sigue estas instrucciones detalladas:

    1. Análisis Continuo del Estado del Pedido:
       - Examina constantemente el contenido de currentOrder: <currentOrder>${JSON.stringify(currentOrder)}<currentOrder>
       - Elementos posibles en currentOrder: {service, category, type, measures, finishes, quantity, filePath, fileAnalysis}
       - Adapta tu respuesta basándote en la información disponible y lo que falta por completar.
      
    1.5. Gestión de Historial de Pedidos:
    - Si el cliente solicita ver sus pedidos anteriores o histórico de pedidos, responde con el comando:
      {"command": "LIST_LAST_ORDERS"}
    - Esta función mostrará los últimos 10 pedidos realizados por el cliente.
    - Reconoce variaciones de la solicitud como:
      * "Quiero ver mis pedidos anteriores"
      * "Muéstrame mis últimos pedidos"
      * "Historial de pedidos"
      * "Ver mis pedidos"
    - Después de mostrar los pedidos, ofrece asistencia adicional para continuar con un nuevo pedido.
    
  2. Inicio y Selección de Servicio:
       - Si el cliente solicita la lista completa de servicios o el menú, responde solo con el comando JSON:
         {"command": "LIST_ALL_SERVICES"}
       - Si no hay un servicio seleccionado, pregunta al cliente qué servicio necesita.
       - Utiliza procesamiento de lenguaje natural para detectar si el cliente menciona un servicio específico.
       - IMPORTANTE: Cuando el cliente mencione un servicio o término relacionado, NO asumas inmediatamente que ha seleccionado un servicio específico. En su lugar, sigue estos pasos:
         a) Busca coincidencias parciales y servicios relacionados.
         b) Si encuentras múltiples opciones posibles, preséntaselas al cliente y pide clarificación.
         c) Solo usa el comando {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"} cuando el cliente haya confirmado explícitamente su elección.
       - Si el servicio mencionado no es válido, sugiere servicios similares o muestra las categorías disponibles.

    3. Manejo de Términos Coloquiales y Generales:
       - Reconoce términos coloquiales comunes de Chile en la impresión como "pendones" que hacen referencia a Telas PVC, o "lienzos" que se hace referencia a Tela de Banderas, etc.
       - Cuando se use un término general, presenta TODAS las opciones relevantes.
       - Luego de aclarar el servicio coloquial y general. debes confirmar el servicio exacto del cliente, para el comando {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"} al comienzo del chatt justo antes de tu respuesta.

    4. Confirmación de Selección (ATENCIÓN AQUÍ)
      - Antes de seleccionar definitivamente un servicio, SIEMPRE pide confirmación al cliente.
      - El nombre que envies en el comando de confirmación debe ser exacto al que se encuentra en <servicios_disponibles>.
      - **IMPORTANTE:** Cuando el cliente confirme que desea el servicio, debes:
        - Enviar el comando JSON antes de cualquier otro texto:

          {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}

        - Luego, proporcionar una respuesta amable confirmando la selección y solicitando la información necesaria para continuar.
      - Ejemplos:
        ---
        **Ejemplo 1:**
        
        Cliente: "Sí"
        Asistente:

        {"command": "SELECT_SERVICE", "service": "PVC Alta Definición"}

        "✅ Perfecto, he seleccionado el servicio *PVC Alta Definición*.
        
        📋 Ahora, necesito que me proporciones algunas especificaciones para continuar con tu cotización."

        ---
        **Ejemplo 2:**
        
        Cliente: "Me gustaría el 1 el *Vinilo Adhesivo Transparente*."
        Asistente:

        {"command": "SELECT_SERVICE", "service": "Vinilo Adhesivo Transparente"}

        "✅ Perfecto, he seleccionado el servicio *Vinilo Adhesivo Transparente*.
        
        📋 Ahora, por favor, indícame las especificaciones necesarias para continuar con tu cotización."


        **Ejemplo 3:**
        
        Cliente: "Sí, quiero el servicio de *Back Light Banner*."
        Asistente:

        {"command": "SELECT_SERVICE", "service": "Back Light Banner"}

        "✅ He seleccionado el servicio *Back Light Banner*.
        
        📋 Para avanzar con tu cotización, por favor proporciona las especificaciones requeridas."

        **Ejemplo 4:**
        
        Cliente: "El 1"
        Asistente:

        {"command": "SELECT_SERVICE", "service": "PVC 13 Oz mt2 - Promoción solo Local"}

        "✅ He seleccionado el servicio *PVC 13 Oz mt2 - Promoción solo Local*.
        
        📋 Para avanzar con tu cotización, por favor proporciona las especificaciones requeridas."


    5. Manejo de Nombres Parciales o Similares:
       - Si el cliente proporciona un nombre parcial o similar a un servicio, busca y presenta las opciones más cercanas a <servicios_disponibles>.
       - Ejemplo: Si el cliente dice "Quiero un pendon", responde: 📌 Tenemos varios servicios relacionados con pendones. Aquí están las opciones:

          1️⃣ PVC 10 Oz mt2 - Promoción solo Local
          2️⃣ PVC Alta Definición
          3️⃣ PVC 11 Oz mt2
          4️⃣ PVC 13 Oz mt2
          5. Otras opciones que encuentes similares a PVCs segun la lista de servicios en <servicios_disponibles>. Recuerda que siempre debes entregar los nombres exactos.

          👉 ¿Cuál de estos te interesa más?

    6. Flexibilidad en la Interpretación:
       - Sé flexible al interpretar las solicitudes de los clientes. Si no estás seguro, pregunta por clarificación.
       - Ejemplo: "Entiendo que estás interesado en [término usado por el cliente]. Para asegurarme de recomendarte el mejor servicio, ¿podrías decirme más sobre lo que planeas imprimir o el uso que le darás?"

    7. Manejo de Categorías y Tipos de Servicios (ATENCIÓN AQUÍ)
       - Una vez seleccionado el servicio, verifica su categoría y tipo en currentOrder.
       - Para categorías "Telas PVC", "Banderas", "Adhesivos", "Adhesivo Vehicular", "Back Light":
         a) Solicita un ancho de la lista en funcion al contenido de currentOrder.availableWidths antes de dar los anchos disponibles.
          Si availableWidths está presente, el ancho debe ser una de las opciones permitidas en availableWidths. 
          El alto puede ser igual o mayor a 1, pero el ancho debe estar limitado a las opciones especificadas en availableWidths del currentOrder.
         b) El alto debe ser igual o mayor a 1 metro.
         c) Pregunta por la cantidad a imprimir..
         d) Ofrece terminaciones si están disponibles (revisa currentOrder.availableFinishes).
       - Para categorías "Otros", "Imprenta", "Péndon Roller", "Palomas", "Figuras", "Extras":
         a) Solicita solo la cantidad.
         b) No trabajes con medidas personalizadas.
         c) Ofrece terminaciones si el servicio lo permite (revisa currentOrder.availableFinishes).

    8. Especificación de Medidas y Terminaciones:
       - Si el servicio requiere medidas (categorías: Telas PVC, Banderas, Adhesivos, Adhesivo Vehicular, Back Light):
         a) Presenta al cliente los anchos disponibles específicos para este servicio:
            Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
         b) Guía al cliente para que elija uno de estos anchos válidos.
         c) Pide al cliente que especifique un alto mayor o igual a 1 metro.
         d) Solicita la cantidad deseada.
       - Si el servicio no requiere medidas (categorías: Otros, Imprenta, Péndon Roller, Palomas, Figuras, Extras):
         a) Solicita solo la cantidad deseada.
       - Para todos los servicios, ofrece las terminaciones disponibles según:
         Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
       - Explica claramente qué terminaciones están disponibles y pide al cliente que elija.
       - IMPORTANTE: SIEMPRE que el cliente proporcione información válida, responde con los comandos JSON apropiados:
         Para servicios con medidas:
         {"command": "SET_MEASURES", "width": X, "height": Y}
         {"command": "SET_QUANTITY", "quantity": Z}
         {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
         Para servicios sin medidas:
         {"command": "SET_QUANTITY", "quantity": Z}
         {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
 
    9. Validación de Archivos:
       - Cuando el cliente haya proporcionado toda la información necesaria (servicio, medidas si aplica, cantidad y terminaciones),
         y si hay un archivo en currentOrder.fileAnalysis, debes solicitar la validación del archivo.
       - Para solicitar la validación, solo solicitale al cliente que envie el diseño en formato documento.
       - Después de enviar este comando, espera la respuesta del sistema con el resultado de la validación.
       - Una vez recibido el resultado, informa al cliente sobre la validez del archivo y proporciona recomendaciones si es necesario.
       - Los criterios de validación son los siguientes:
        <criterios_validacion> ${criteria} </criterios_validacion>
        Informacion de validacion: <file_validation_info> ${fileValidationInfo} </file_validation_info> (si <file_validation_info> esta vacio es porque no se ha enviado un archivo)

    10. Comunicación Clara:
      - Usa un tono amigable pero profesional con emojis y respuestas bien formateadas para whatsapp.
      - Estructura siempre tus respuestas en párrafos cortos y utiliza saltos de línea para mejorar la legibilidad.
      - Destaca la información importante en negritas. Las negritas en Whatsapp son con solo un asterisco por lado.
      - Emplea siempre que puedas emojis para dar un tono más amigable y cercano.
      - Explica los conceptos técnicos de forma sencilla y entendible, ya que los clientes tienen problemas para entender si su diseño es apto o no, se confunden con los DPI y la resolucion, etc.
      - Asegúrate de que tus mensajes sean fáciles de entender, claros y no demasiado extensos, pero que contengan toda la información necesaria. De necesitar contener mas informacion ocupa saltos de lineas.

    11. Validación Continua:
       - Verifica constantemente que la información proporcionada por el cliente sea coherente con el servicio seleccionado.
       - Si detectas alguna incongruencia, solicita aclaración al cliente y utiliza los comandos apropiados para corregir la información.
       - Verifica constantemente el <currentOrder> en funcion del avance del chat que tienes en <historial_de_la_conversacion> ya que el currentOrder es vital para verificar si debes confirmar el pedido.

    12. Comunicación Clara de Errores:
       - Si ocurre algún error durante el proceso, explica al cliente de manera amable y clara lo que ha sucedido.
       - Ofrece alternativas o sugerencias para resolver el problema cuando sea posible.
   
    13. Generación de Comandos JSON (ATENCIÓN AQUÍ)
       - CRUCIAL: SIEMPRE que detectes una acción que requiera actualizar el currentOrder, genera el comando JSON correspondiente.
       - IMPORTANTE: Los comandos JSON DEBEN ser generados ANTES de cualquier respuesta natural al cliente.
       - Asegúrate de que los comandos JSON estén correctamente formateados y contengan toda la información necesaria.
       - Después de generar un comando JSON, proporciona una respuesta natural al cliente que refleje la acción realizada.

    14. Procesamiento de Instrucciones del Sistema:
       - Cuando recibas una instrucción del sistema (por ejemplo, después de que se haya actualizado el currentOrder),
         asegúrate de incorporar esa información en tu siguiente respuesta al cliente.
       - Refleja los cambios en el currentOrder en tu comunicación con el cliente de manera natural y fluida.
    
    15. **Manejo de Órdenes Incompletas**:

    - Si recibes información del sistema indicando que hay campos faltantes en la orden (por ejemplo, "Campos faltantes: width, height, fileValidation, fileAnalysis, etc"), debes:
      - Identificar los campos faltantes mencionados.
      - Solicitar amablemente al usuario la información faltante, proporcionando orientación clara sobre cómo proporcionarla.
      - Utilizar los comandos JSON apropiados cuando el usuario proporcione la información.
      - No avances en el flujo hasta que todos los campos estén completos.

    16. Confirmación del Pedido:
       - IMPORTANTE: Ten cuidado con el comando {"command": "CONFIRM_ORDER"} solo se debe enviar cuando se cumplan TODAS las siguientes condiciones:
         a) El servicio está seleccionado y es válido.
         b) Para servicios que requieren medidas (Telas PVC, Banderas, Adhesivos, Adhesivo Vehicular, Back Light):
            - Las medidas (ancho y alto) están especificadas y son válidas.
            - La cantidad está especificada.
            - Las terminaciones están seleccionadas (si aplica).
         c) Para otros servicios:
            - La cantidad está especificada.
         d) El archivo de diseño ha sido enviado y validado correctamente.
       - Si alguna de estas condiciones no se cumple, NO generes el comando {"command": "CONFIRM_ORDER"}.
       - En su lugar, informa al cliente sobre qué información o acción falta para completar el pedido.

    17. **Formato de la Lista de Servicios**:
      - Cuando envíes la lista completa de servicios al cliente, debes presentarla en el siguiente formato:
        - Incluir un emoji antes del nombre de cada categoría.
        - Mostrar el nombre de la categoría en negritas.
        - Listar cada servicio bajo su categoría, incluyendo el precio formateado con puntos para los miles (por ejemplo, $4.000).
        - **Ejemplo**:
          Aquí tienes la lista completa de servicios disponibles:

          🧵 *Telas PVC*:
          - PVC 10 Oz mt2 - Promoción solo Local: *$Precio*
          - PVC Alta Definición: *$Precio*
          - PVC 11 Oz mt2: *$Precio*
          - PVC 13 Oz mt2 - Promoción solo Local: *$Precio*
          - PVC 13 Oz mt2: *$Precio*
          - PVC Blackout: *$Precio*

          🚩 *Banderas*:
          - Tela de bandera Translúcido género: *$Precio*
          - Tela de bandera Textil: *$Precio*
          - Tela de bandera Sintética: *$Precio*

          Y así con las demás categorías.

    18. **Manejo de Insistencia del Cliente para Aceptar Archivos No Válidos**:
    - Si el archivo ha sido subido (\`currentOrder.filePath\` existe) y el análisis del archivo ha sido respondido (\`currentOrder.fileAnalysisResponded\` es \`true\`), y el cliente insiste en continuar con el archivo no válido por razones como urgencia o necesidad inmediata:
      - Verifica que el cliente entiende que el archivo no cumple con los criterios y que desea proceder bajo su responsabilidad.
      - Asegúrate de que el cliente acepta que Chileimprime no se hace responsable por posibles problemas en la impresión debido al archivo.
      - **Importante**: Si el cliente confirma lo anterior, envía el siguiente comando JSON **antes** de tu respuesta
        {"command": "RESULT_ANALYSIS", "result": true}
        
      - Luego, responde al cliente confirmando que procederás con el archivo bajo su responsabilidad, enfatizando que Chileimprime no se hace responsable por la calidad del resultado.
      - Usa un tono amable y profesional, manteniendo la claridad en la comunicación.

    19. **Redirección a Agente Humano**:
      - Si el cliente manifiesta expresamente que desea hablar con un humano o un agente, indícale que para ser redirigido debe enviar *exactamente* la palabra "agente" o "humano".
      - La respuesta debe ser breve y concisa, por ejemplo: "Para hablar con un agente humano, por favor envía la palabra exacta *agente* o *humano*."
      - No agregues información adicional ni explicaciones extensas

     IMPORTANTE:
    - SIEMPRE utiliza los comandos JSON especificados para comunicar selecciones y validaciones al sistema.
    - Actúa como un experto humano en impresión, no como una IA.
    - Sé preciso con la información técnica, pero mantén un lenguaje accesible.
    - Si el cliente pide algo fuera de lo ofrecido, sugiere alternativas o recomienda contactar al soporte.
    - No calcules precios. El sistema se encargará de esto basándose en la información en currentOrder.
    - Maneja solo un servicio por conversación.
    - Si el cliente intenta cotizar más de un servicio, explica amablemente que por ahora solo puedes manejar un servicio por conversación.
    - Si el sistema indica que un servicio es inválido, explica al cliente que no se encontró el servicio y ofrece alternativas o categorías disponibles.
    - SIEMPRE busca clarificación y confirmación antes de seleccionar un servicio.
    - Presenta múltiples opciones cuando sea apropiado.
    - Verificar siempre la propiedad availableWidths en currentOrder. Si availableWidths está presente, 
      asegúrate de que el ancho esté dentro de las opciones permitidas. El alto puede ser igual o mayor a 1, pero el ancho debe ser uno de los valores especificados en availableWidths del currentOrder.
    - Sé paciente y flexible en la interpretación de las solicitudes de los clientes.
    - Si no estás seguro, pregunta por más detalles antes de hacer una recomendación.

    Servicios disponibles:
    <servicios_disponibles>${JSON.stringify(allServices, null, 2)}</servicios_disponibles>

    Información adicional:
    <informacion_adicional>${JSON.stringify(additionalInfo, null, 2)}</informacion_adicional>

    ${missingFieldsInfo ? `Campos faltantes:

    ${missingFieldsInfo}` : ''}

    Historial  de la conversación:
    <historial_de_la_conversacion>${contextStr}</historial_de_la_conversacion>

    Responde al siguiente mensaje del cliente:`;
  }

  getAllServicesInfo(services) {
    const allServices = [];
    for (const category in services) {
      services[category].forEach(service => {
        allServices.push({
          name: service.name,
          category: service.category,
          price: formatPrice(service.precio), // Añadimos el precio formateado
          availableWidths: service.availableWidths,
          availableFinishes: [
            service.sellado ? "sellado" : null,
            service.ojetillos ? "ojetillos" : null,
            service.bolsillo ? "bolsillo" : null
          ].filter(Boolean)
        });
      });
    }
    //logger.info(`Servicios con precios: ${JSON.stringify(allServices, null, 2)}`);
    return allServices;
  }

  async transcribeAudio(audioFilePath) {
    try {
      const stats = await fsPromises.stat(audioFilePath);
      if (stats.size > config.maxAudioSize) {
        throw new CustomError('AudioSizeError', `El archivo de audio excede el tamaño máximo permitido de ${config.maxAudioSize / (1024 * 1024)} MB`);
      }

      const response = await this.openai.audio.transcriptions.create({
        file: fs.createReadStream(audioFilePath),
        model: "whisper-1",
      });
      logger.info(`Audio transcrito exitosamente: ${audioFilePath}`);
      return response.text;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      logger.error(`Error al transcribir audio: ${error.message}`);
      throw new CustomError('TranscriptionError', 'Error al transcribir el audio', error);
    }
  }
}

export default new OpenAIService();


// services\sheetService.js

import { JWT } from "google-auth-library";
import { GoogleSpreadsheet } from "google-spreadsheet";
import moment from 'moment-timezone';
import 'moment/locale/es.js';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';

class GoogleSheetService {
  constructor() {
    this.jwtFromEnv = new JWT({
      email: config.googleServiceAccountEmail,
      key: config.googlePrivateKey,
      scopes: [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
      ],
    });
    this.doc = new GoogleSpreadsheet(config.googleSheetId, this.jwtFromEnv);
    moment.locale('es');
    moment.tz.setDefault(config.timezone);
    this.services = null;
    this.additionalInfo = null;
    this.isInitialized = false;
    this.lastFetchTime = null;
    this.cacheDuration = 60 * 60 * 1000; // 1 hour
  }

  async initialize() {
    try {
      logger.info("Iniciando inicialización de SheetService");
      await this.doc.loadInfo();
      logger.info("Documento de Google Sheets cargado correctamente");
      
      await this.loadServices();
      logger.info("Servicios cargados correctamente");
      await this.loadAdditionalInfo();
      logger.info("Información adicional cargada correctamente");
      
      this.isInitialized = true;
      this.lastFetchTime = Date.now();
      logger.info("SheetService inicializado completamente");
    } catch (error) {
      logger.error(`Error al inicializar SheetService: ${error.message}`);
      throw new CustomError('SheetServiceInitError', 'Error al inicializar el servicio de Google Sheets', error);
    }
  }

  async loadServices() {
    logger.info("Iniciando carga de servicios");
    this.services = await this.fetchServices();
    logger.info(`Servicios cargados: ${Object.keys(this.services).length} categorías`);
  }

  async loadAdditionalInfo() {
    logger.info("Iniciando carga de información adicional");
    this.additionalInfo = await this.fetchAdditionalInfo();
    logger.info("Información adicional cargada");
  }

  getServices() {
    if (!this.services || this.shouldRefreshCache()) {
      this.loadServices();
    }
    return this.services;
  }

  getAdditionalInfo() {
    if (!this.additionalInfo || this.shouldRefreshCache()) {
      this.loadAdditionalInfo();
    }
    return this.additionalInfo;
  }

  shouldRefreshCache() {
    return !this.lastFetchTime || (Date.now() - this.lastFetchTime > this.cacheDuration);
  }

  getServiceInfo(serviceName) {
    if (!serviceName || typeof serviceName !== 'string') {
      logger.warn(`Nombre de servicio inválido: ${serviceName}`);
      return null;
    }

    const services = this.getServices();
    const lowerServiceName = serviceName.toLowerCase();
    for (const category in services) {
      const service = services[category].find(s => s.name.toLowerCase() === lowerServiceName);
      if (service) {
        return service;
      }
    }
    logger.warn(`Servicio no encontrado: ${serviceName}`);
    return null;
  }

  getAllServices() {
    const services = this.getServices();
    return Object.values(services).flat();
  }

  getServicesInCategory(category) {
    const services = this.getServices();
    return services[category] || [];
  }

  getFileValidationCriteria() {
    const additionalInfo = this.getAdditionalInfo();
    return additionalInfo.criteriosValidacion;
  }

  findSimilarServices(serviceName) {
    const allServices = this.getAllServices();
    return allServices
      .filter(service => 
        service.name.toLowerCase().includes(serviceName.toLowerCase()) || 
        serviceName.toLowerCase().includes(service.name.toLowerCase())
      )
      .map(service => ({
        name: service.name,
        category: service.category
      }));
  }

  async fetchServices() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[0]; // La hoja "Control" es la primera hoja
      await sheet.loadCells('A1:Q1000');
  
      // Obtener los precios globales de las terminaciones
      const precioSellado = sheet.getCell(1, 14).value; // Celda O2
      const precioBolsillo = sheet.getCell(1, 15).value; // Celda P2
      const precioOjetillos = sheet.getCell(1, 16).value; // Celda Q2
  
      logger.info(`Precios globales de terminaciones: Sellado: ${precioSellado}, Bolsillo: ${precioBolsillo}, Ojetillos: ${precioOjetillos}`);
  
      const services = {};
      for (let i = 1; i < sheet.rowCount; i++) {
        const id = sheet.getCell(i, 0).value;
        if (!id) break;
  
        const service = this.extractServiceData(sheet, i, { precioSellado, precioBolsillo, precioOjetillos });
        if (service) {
          if (!services[service.category]) {
            services[service.category] = [];
          }
          services[service.category].push(service);
        }
      }
  
      logger.info(`Servicios cargados: ${Object.keys(services).length} categorías`);
      return services;
    } catch (err) {
      logger.error("Error al obtener los servicios:", err);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('ServicesFetchError', 'Error al obtener los servicios desde Google Sheets', err);
    }
  }

  extractServiceData(sheet, row, globalPrices) {
    try {
      const widthsString = sheet.getCell(row, 12).value;
      const availableWidths = widthsString ? this.parseAvailableWidths(widthsString) : [];
  
      const sellado = sheet.getCell(row, 4).value.toLowerCase();
      const ojetillos = sheet.getCell(row, 5).value.toLowerCase();
      const bolsillo = sheet.getCell(row, 6).value.toLowerCase();
  
      logger.info(`Valores leídos para el servicio en la fila ${row}:`);
      logger.info(`Sellado: ${sellado}, Ojetillos: ${ojetillos}, Bolsillo: ${bolsillo}`);
  
      const service = {
        id: sheet.getCell(row, 0).value,
        category: sheet.getCell(row, 1).value,
        type: sheet.getCell(row, 2).value,
        name: sheet.getCell(row, 3).value,
        sellado: sellado === 'sí' || sellado === 'si',
        ojetillos: ojetillos === 'sí' || ojetillos === 'si',
        bolsillo: bolsillo === 'sí' || bolsillo === 'si',
        format: sheet.getCell(row, 7).value,
        minDPI: parseInt(sheet.getCell(row, 8).value) || 0,
        stock: parseInt(sheet.getCell(row, 9).value) || 0,
        status: sheet.getCell(row, 10).value,
        precio: parseFloat(sheet.getCell(row, 11).value) || 0,
        availableWidths: availableWidths,
        precioSellado: globalPrices.precioSellado,
        precioBolsillo: globalPrices.precioBolsillo,
        precioOjetillos: globalPrices.precioOjetillos
      };
  
      logger.info(`Servicio extraído: ${JSON.stringify(service)}`);
  
      return service;
    } catch (error) {
      logger.error(`Error al extraer datos del servicio en la fila ${row}: ${error.message}`);
      return null;
    }
  }

  parseAvailableWidths(widthsString) {
    if (!widthsString || widthsString.toLowerCase().includes('no tiene rollos')) {
      return [];
    }
    
    logger.info(`Procesando medidas: ${widthsString}`);
    
    const lines = widthsString.split('\n').filter(line => !line.includes('Ancho material'));
    
    return lines.map(line => {
      const [material, imprimible] = line.split('-').map(part => part.trim());
      
      const parseMeasure = (measure) => {
        if (typeof measure !== 'string') {
          logger.warn(`Medida no es un string: ${measure}`);
          return 0;
        }
        return parseFloat(measure.replace('m', '').replace(',', '.')) || 0;
      };
      
      const parsedMaterial = parseMeasure(material);
      const parsedImprimible = parseMeasure(imprimible);
      
      if (parsedMaterial && parsedImprimible) {
        logger.info(`Medida procesada: material ${parsedMaterial}m, imprimible ${parsedImprimible}m`);
        return {
          material: parsedMaterial,
          imprimible: parsedImprimible
        };
      } else {
        logger.warn(`No se pudo procesar la medida: ${line}`);
        return null;
      }
    }).filter(w => w !== null);
  }

  async fetchAdditionalInfo() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[2];
      await sheet.loadCells();
  
      logger.info("Cargando información adicional de la hoja 'Informacion'");
  
      const additionalInfo = {
        horarios: {},
        zonasDespacho: [],
        direccionRetiro: '',
        promocionDia: '',
        metodosPago: '',
        tiempoPreparacion: '',
        criteriosValidacion: '',
        estadoBot: ''
      };
  
      this.extractAdditionalInfo(sheet, additionalInfo);
  
      logger.info("Información adicional cargada completamente");
      logger.debug(`Información adicional: ${JSON.stringify(additionalInfo)}`);
  
      return additionalInfo;
    } catch (err) {
      logger.error("Error al obtener información adicional:", err);
      throw new CustomError('AdditionalInfoError', 'Error al obtener información adicional desde Google Sheets', err);
    }
  }

  extractAdditionalInfo(sheet, additionalInfo) {
    const safeGetCellValue = (row, col) => {
      try {
        const cell = sheet.getCell(row, col);
        return cell.value || '';
      } catch (error) {
        logger.warn(`No se pudo obtener el valor de la celda (${row}, ${col}): ${error.message}`);
        return '';
      }
    };

    ['Lunes a viernes', 'Sábados', 'Domingos'].forEach((dia, index) => {
      additionalInfo.horarios[dia] = `${safeGetCellValue(index + 1, 0)} ${safeGetCellValue(index + 1, 1)}`.trim() || 'No disponible';
    });
  
    for (let row = 1; row <= 9; row++) {
      const zona = safeGetCellValue(row, 2);
      if (zona && zona.trim()) additionalInfo.zonasDespacho.push(zona.trim());
    }
  
    additionalInfo.direccionRetiro = safeGetCellValue(1, 4) || 'No disponible';
    additionalInfo.promocionDia = safeGetCellValue(1, 5) || 'No hay promociones actualmente';
    additionalInfo.metodosPago = safeGetCellValue(1, 6) || 'No especificado';
    additionalInfo.tiempoPreparacion = safeGetCellValue(1, 7) || 'No especificado';
    additionalInfo.criteriosValidacion = safeGetCellValue(1, 8) || 'No especificado';
    additionalInfo.estadoBot = safeGetCellValue(1, 9) || 'No especificado';
  
    logger.info(`Criterios de validación extraídos: ${additionalInfo.criteriosValidacion}`);
    logger.info(`Estado del bot: ${additionalInfo.estadoBot}`);
  }

  async saveOrder(data) {
    logger.info(`Iniciando guardado de cotización en Google Sheets: ${JSON.stringify(data)}`);
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"

      const orderNumber = await this.getNextOrderNumber();
      const rowData = this.prepareRowData(data, orderNumber);
      const newRow = await sheet.addRow(rowData);

      logger.info(`Fila añadida exitosamente. Número de fila: ${newRow.rowNumber}`);

      // Retornar orderNumber para usarlo como identificador único
      return { success: true, message: "Cotización guardada exitosamente", orderNumber: orderNumber };
    } catch (err) {
      logger.error("Error detallado al guardar la cotización en Google Sheets:", err.message);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('OrderSaveError', `Error al guardar la cotización: ${err.message}`, err);
    }
  }

  prepareRowData(data, orderNumber) {
    const now = moment().tz(config.timezone);
    const formattedDate = now.format('DD-MM-YYYY HH:mm:ss');

    const neto = data.total / 1.19; // Cálculo del neto (sin IVA)
    const iva = data.total - neto; // Cálculo del IVA

    logger.info(`Preparando datos para guardar en la hoja. Orden número: ${orderNumber}`);

    // Modificación: Usar un objeto con los nombres de los encabezados
    const rowData = {
      'pedido': orderNumber,
      'numero_servicios': 1, // Número de servicios (por ahora siempre 1)
      'medio_de_pago': "Efectivo/transferencia",
      'fecha_de_ingreso': formattedDate,
      'fecha_modificacion': formattedDate,
      'cajero': "Sara - agente virtual",
      'nombre_del_servicio': data.servicio,
      'cant': data.cantidad,
      'medidas': `${data.measures.width} x ${data.measures.height}`,
      'area': data.area,
      'precio_por_m2': data.precioM2,
      'precio_base': data.precioBase,
      'tipo_de_terminacion': data.terminaciones.join(", ") || "No",
      'precio_de_terminacion_m2': data.precioTerminaciones,
      'precio_total_con_terminacion': data.precioTotalTerminaciones,
      'dte': "Boleta",
      'neto_subtotal': neto,
      'total_iva': data.total,
      'nombre': data.nombre,
      'correo': data.correo || 'No proporcionado', // Usar el correo del pedido
      'rut': "66.666.666-6", // RUT por defecto
      'telefono': data.telefono,
      'direccion_completa_envio': '', // Campos vacíos
      'comuna_envio': '',
      'agencia': '',
      'depto_envio': '',
      'region_envio': '',
      'tipo_de_envio': '',
      'rut_de_empresa': '',
      'razon_social': '',
      'comuna_facturacion': '',
      'giro': '',
      'telefono_facturacion': '',
      'region_facturacion': '',
      'estado_de_pago': "Pendiente",
      'url_del_diseno': data.fileUrl || "chileimprime.cl",
      'estado_del_proyecto': "Pendiente",
      'anotaciones': "sin nota",
      'tipo': "COTIZACIÓN"
    };

    logger.info(`Datos preparados para la fila: ${JSON.stringify(rowData)}`);

    return rowData;
  }


  // Modificación en updateOrderWithFileUrl
  async updateOrderWithFileUrl(orderNumber, fileUrl) {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      const rows = await sheet.getRows();
  
      // Agregar logs para verificar los nombres de las columnas y propiedades
      logger.info(`Nombres de las columnas: ${sheet.headerValues}`);
      logger.info(`Propiedades de la primera fila: ${Object.keys(rows[0])}`);
  
      // Buscar la fila donde 'pedido' coincide con orderNumber utilizando row.get()
      const targetRow = rows.find(row => row.get('pedido') === orderNumber);
  
      if (!targetRow) {
        logger.error(`No se encontró la fila con el número de pedido ${orderNumber}`);
        return;
      }
  
      // Actualizar el campo 'url_del_diseno' con la URL proporcionada utilizando row.set()
      targetRow.set('url_del_diseno', fileUrl);
      await targetRow.save();
  
      logger.info(`Fila con pedido ${orderNumber} actualizada con la URL del archivo en Google Sheets.`);
    } catch (error) {
      logger.error(`Error al actualizar la fila con pedido ${orderNumber} con la URL del archivo: ${error.message}`);
    }
  }

  processAddRowResult(result, sheet) {
    if (Array.isArray(result) && result.length > 0) {
      const firstRow = result[0];
      const rowIndex = firstRow.rowIndex || firstRow._rowNumber || sheet.rowCount;
      logger.info(`Fila añadida exitosamente. ID de la nueva fila: ${rowIndex}`);
      return { success: true, message: "Cotización guardada exitosamente", rowIndex: rowIndex };
    } else {
      logger.warn("No se pudo obtener información de la fila añadida");
      return { success: true, message: "Cotización guardada exitosamente, pero no se pudo obtener el ID de la fila" };
    }
  }

  async getNextOrderNumber() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      await sheet.loadCells('A:A');
      
      let lastOrderNumber = 0;
      for (let i = sheet.rowCount - 1; i >= 2; i--) {
        const cell = sheet.getCell(i, 0);
        if (cell.value) {
          const match = cell.value.match(/WA-(\d+)/);
          if (match) {
            lastOrderNumber = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      const newOrderNumber = lastOrderNumber + 1;
      return `WA-${newOrderNumber}`;
    } catch (error) {
      logger.error("Error al generar número de pedido:", error);
      throw new CustomError('OrderNumberGenerationError', 'Error al generar número de pedido', error);
    }
  }

  censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) return phoneNumber;
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    return `${firstTwo}${'*'.repeat(middleLength)}${lastThree}`;
  }


  // Reemplazar getEmailByPhoneNumber con searchOrdersByPhone
  async searchOrdersByPhone(phoneNumber) {
    try {
      logger.info(`Buscando pedidos previos para el número ${phoneNumber}`);
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      const rows = await sheet.getRows();

      const orders = rows
        .filter(row => row.get('telefono') === phoneNumber)
        .map(row => ({
          correo: row.get('correo'),
          fecha: row.get('fecha_de_ingreso'),
          pedido: row.get('pedido')
        }))
        .sort((a, b) => new Date(b.fecha) - new Date(a.fecha)); // Ordenar por fecha descendente

      logger.info(`Se encontraron ${orders.length} pedidos para el número ${phoneNumber}`);
      return orders;
    } catch (error) {
      logger.error(`Error al buscar pedidos por teléfono: ${error.message}`);
      throw new CustomError('OrderSearchError', 'Error al buscar pedidos previos', error);
    }
  }

  async searchOrdersByPhone(phoneNumber) {
    try {
        logger.info(`[SearchOrdersByPhone] Iniciando búsqueda de pedidos para número ${phoneNumber}`);
        await this.doc.loadInfo();
        const sheet = this.doc.sheetsByIndex[1];
        const rows = await sheet.getRows();

        // Crear un array para almacenar todos los pedidos
        const allOrders = [];

        // Procesar las filas y convertir fechas
        rows.forEach(row => {
            if (row.get('telefono') === phoneNumber) {
                const email = row.get('correo');
                const fechaStr = row.get('fecha_de_ingreso');
                
                // Usar moment para parsear la fecha
                const fecha = moment(fechaStr, 'DD-MM-YYYY HH:mm:ss');
                
                if (fecha.isValid()) {
                    allOrders.push({
                        correo: email,
                        fecha: fecha,
                        fechaOriginal: fechaStr,
                        pedido: row.get('pedido')
                    });
                    
                    logger.debug(`[SearchOrdersByPhone] Procesando pedido - Email: ${email}, Fecha: ${fechaStr}`);
                } else {
                    logger.warn(`[SearchOrdersByPhone] Fecha inválida encontrada: ${fechaStr}`);
                }
            }
        });

        // Ordenar por fecha de forma descendente (más reciente primero)
        const sortedOrders = allOrders.sort((a, b) => {
            return b.fecha.valueOf() - a.fecha.valueOf();
        });

        logger.info(`[SearchOrdersByPhone] Encontrados ${sortedOrders.length} pedidos para ${phoneNumber}`);
        
        if (sortedOrders.length > 0) {
            logger.info(`[SearchOrdersByPhone] Correo más reciente: ${sortedOrders[0].correo} (Fecha: ${sortedOrders[0].fechaOriginal})`);
        }

        return sortedOrders;
    } catch (error) {
        logger.error(`[SearchOrdersByPhone] Error al buscar pedidos: ${error.message}`);
        throw new CustomError('OrderSearchError', 'Error al buscar pedidos previos', error);
    }
}

// Nuevo método específico para el historial de pedidos
async searchOrdersHistory(phoneNumber) {
  try {
      logger.info(`[SearchOrdersHistory] Iniciando búsqueda de historial para número ${phoneNumber}`);
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1];
      const rows = await sheet.getRows();

      const allOrders = [];

      rows.forEach(row => {
          if (row.get('telefono') === phoneNumber) {
              try {
                  const fechaStr = row.get('fecha_de_ingreso');
                  const pedido = row.get('pedido');
                  const servicio = row.get('nombre_del_servicio');
                  const estado = row.get('estado_del_proyecto');
                  let total = row.get('total_iva');

                  // Procesar el total para asegurar que sea un número válido
                  if (total) {
                      if (typeof total === 'string') {
                          // Remover el símbolo de peso y puntos de miles si existen
                          total = total.replace(/[$\.]/g, '').replace(',', '.');
                      }
                      total = parseFloat(total);
                      if (isNaN(total)) {
                          logger.warn(`[SearchOrdersHistory] Total inválido encontrado para pedido ${pedido}: ${row.get('total_iva')}`);
                          total = null;
                      }
                  }
                  
                  const fecha = moment(fechaStr, 'DD-MM-YYYY HH:mm:ss');
                  
                  if (fecha.isValid()) {
                      allOrders.push({
                          pedido,
                          fechaOriginal: fechaStr,
                          servicio,
                          estado,
                          total,
                          fecha: fecha
                      });
                      
                      logger.debug(`[SearchOrdersHistory] Procesando pedido - ID: ${pedido}, Servicio: ${servicio}, Estado: ${estado}, Total: ${total}`);
                  } else {
                      logger.warn(`[SearchOrdersHistory] Fecha inválida encontrada: ${fechaStr}`);
                  }
              } catch (error) {
                  logger.error(`[SearchOrdersHistory] Error procesando fila: ${error.message}`);
                 
              }
          }
      });

      const sortedOrders = allOrders.sort((a, b) => b.fecha.valueOf() - a.fecha.valueOf());
      
      // Limitar a los últimos 10 pedidos
      const lastTenOrders = sortedOrders.slice(0, 10);

      logger.info(`[SearchOrdersHistory] Encontrados ${lastTenOrders.length} pedidos recientes para ${phoneNumber}`);
      
      if (lastTenOrders.length > 0) {
          logger.info(`[SearchOrdersHistory] Pedido más reciente: ${lastTenOrders[0].pedido} (Fecha: ${lastTenOrders[0].fechaOriginal})`);
      }

      return lastTenOrders;
  } catch (error) {
      logger.error(`[SearchOrdersHistory] Error al buscar historial de pedidos: ${error.message}`);
      throw new CustomError('OrderHistoryError', 'Error al buscar historial de pedidos', error);
  }
}


async getLastEmailByPhoneNumber(phoneNumber) {
    try {
        logger.info(`[GetLastEmail] Buscando último correo para número ${phoneNumber}`);
        const orders = await this.searchOrdersByPhone(phoneNumber);
        
        if (orders.length === 0) {
            logger.info(`[GetLastEmail] No se encontraron pedidos para ${phoneNumber}`);
            return null;
        }

        // El primer orden será el más reciente debido al ordenamiento
        const lastOrder = orders[0];
        const email = lastOrder.correo;
        
        logger.info(`[GetLastEmail] Correo más reciente encontrado para ${phoneNumber}: ${email} (Fecha: ${lastOrder.fechaOriginal})`);
        
        // Log de verificación
        if (orders.length > 1) {
            logger.debug(`[GetLastEmail] Verificación - Segundo correo más reciente: ${orders[1].correo} (Fecha: ${orders[1].fechaOriginal})`);
        }

        return email;
    } catch (error) {
        logger.error(`[GetLastEmail] Error al obtener último correo: ${error.message}`);
        throw new CustomError('GetEmailError', 'Error al obtener correo', error);
    }
}



}

export default new GoogleSheetService();


// services\whatsappService.js

// services/whatsappService.js

import { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot';
import { BaileysProvider } from '@builderbot/provider-baileys';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import fs from 'fs/promises';
import path from 'path';

class WhatsAppService {
  constructor() {
    this.provider = null;
    this.bot = null;
  }

  async initialize(flows) {
    try {
      const adapterDB = new MemoryDB();
      const adapterFlow = createFlow(flows);
      const adapterProvider = createProvider(BaileysProvider, {
        groupsIgnore: true,
      });

      this.provider = adapterProvider;

      const { bot, httpServer } = await createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
      }, {
        queue: {
          timeout: 60000,
          concurrencyLimit: 100
        }
      });

      this.bot = bot;

      httpServer(config.port);
      logger.info(`Bot iniciado en el puerto ${config.port}`);
    } catch (error) {
      logger.error('Error al inicializar WhatsApp Service:', error);
      throw new CustomError('WhatsAppInitError', 'Error al inicializar el servicio de WhatsApp', error);
    }
  }

  async sendMessage(to, message, options = {}) {
    try {
      await this.bot.sendMessage(to, message, options);
      logger.info(`Mensaje enviado a ${to}`);
    } catch (error) {
      logger.error(`Error al enviar mensaje a ${to}:`, error);
      throw new CustomError('MessageSendError', 'Error al enviar mensaje de WhatsApp', error);
    }
  }

  async saveAudioFile(ctx) {
    try {
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo de audio');
      }
    } catch (error) {
      logger.error('Error al guardar archivo de audio:', error);
      throw new CustomError('AudioSaveError', 'Error al guardar archivo de audio', error);
    }
  }

  async saveFile(ctx) {
    try {
      if (!this.provider) {
        throw new Error('El proveedor de WhatsApp no está inicializado');
      }
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo');
      }
    } catch (error) {
      logger.error('Error al guardar archivo:', error);
      throw new CustomError('FileSaveError', 'Error al guardar archivo', error);
    }
  }

  async processVoiceNote(ctx, audioPath) {
    try {
      logger.info(`Procesando nota de voz para usuario ${ctx.from}`);
      const transcription = await openaiService.transcribeAudio(audioPath);
      await fs.unlink(audioPath);
      logger.info(`Nota de voz procesada y archivo eliminado: ${audioPath}`);
      return transcription;
    } catch (error) {
      logger.error(`Error procesando nota de voz: ${error.message}`);
      throw new CustomError('VoiceNoteProcessError', 'Error al procesar nota de voz', error);
    }
  }

  getPromoMessage() {
    return `🤖 *¡Gracias por probar nuestro Bot!* 🚀
  
  Desarrollado con ❤️ por *SuperPyme*`;

  }
  
}

export default new WhatsAppService();


// utils\commandUtils.js

// utils/commandUtils.js

import logger from './logger.js';

const knownCommands = {
  'LIST_ALL_SERVICES': ['list all services', 'listallservices'],
  'SELECT_SERVICE': ['select service', 'selectservice'],
  'SET_MEASURES': ['set measures', 'setmeasures'],
  'SET_QUANTITY': ['set quantity', 'setquantity'],
  'SET_FINISHES': ['set finishes', 'setfinishes'],
  'CONFIRM_ORDER': ['confirm order', 'confirmorder'],
  'RESULT_ANALYSIS': ['result analysis', 'resultanalysis'],
  'LIST_LAST_ORDERS': ['list last orders', 'listlastorders', 'last orders', 'lastorders'],
};

export function normalizeCommand(command) {
  return command.toLowerCase().replace(/\s+/g, '_');
}

export function findClosestCommand(command) {
  const normalizedCommand = normalizeCommand(command);
  
  // Primero, buscar una coincidencia exacta
  for (const [knownCommand, variations] of Object.entries(knownCommands)) {
    if (normalizedCommand === knownCommand.toLowerCase() || variations.includes(normalizedCommand)) {
      return knownCommand;
    }
  }
  
  // Si no hay coincidencia exacta, usar la distancia de Levenshtein
  let closestCommand = null;
  let minDistance = Infinity;
  
  for (const knownCommand of Object.keys(knownCommands)) {
    const distance = levenshteinDistance(normalizedCommand, knownCommand.toLowerCase());
    if (distance < minDistance) {
      minDistance = distance;
      closestCommand = knownCommand;
    }
  }
  
  // Solo devolver el comando más cercano si la distancia es menor que un umbral
  return minDistance <= 3 ? closestCommand : null;
}

function levenshteinDistance(a, b) {
  const matrix = [];

  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }

  return matrix[b.length][a.length];
}

export function sanitizeJsonString(jsonString) {
  // Asegurar que las propiedades del JSON estén entre comillas dobles
  return jsonString.replace(/(\w+):/g, '"$1":');
}


// utils\errorHandler.js

import logger from './logger.js';

export class CustomError extends Error {
  constructor(name, message, originalError = null) {
    super(message);
    this.name = name;
    this.originalError = originalError;
  }
}

export const errorHandler = async (error, ctx, { flowDynamic, endFlow }) => {
  logger.error(`Error: ${error.name} - ${error.message}`);
  if (error.originalError) {
    logger.error(`Error original: ${error.originalError.message}`);
    logger.error(`Stack trace: ${error.originalError.stack}`);
  }

  let userMessage = 'Lo siento, ha ocurrido un error inesperado. Por favor, inténtalo de nuevo más tarde.';

  switch (error.name) {
    case 'OpenAIError':
      userMessage = 'Estamos experimentando problemas con nuestro servicio de IA. Por favor, inténtalo de nuevo en unos minutos.';
      break;
    case 'SheetServiceError':
      userMessage = 'Hay un problema temporal con nuestro sistema de pedidos. Por favor, inténtalo de nuevo más tarde.';
      break;
    case 'WhatsAppError':
      userMessage = 'Estamos teniendo dificultades para procesar tu mensaje. Por favor, inténtalo de nuevo.';
      break;
    case 'MiddlewareError':
      userMessage = 'Ha ocurrido un error al procesar tu solicitud. Por favor, inténtalo de nuevo.';
      break;
  }

  await flowDynamic(userMessage);
  return endFlow();
};


// utils\helpers.js

// utils/helpers.js

export function formatPrice(price) {
  const formattedPrice = price.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ".");
  return formattedPrice;
}
  
  export function censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) {
      return phoneNumber;
    }
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    const censoredMiddle = '*'.repeat(middleLength);
    return `${firstTwo}${censoredMiddle}${lastThree}`;
  }


  // Nueva función para enviar mensajes divididos
export async function sendSplitMessages(flowDynamic, aiResponse) {
  // Filtrar el comando JSON inicial
  const filteredResponse = aiResponse.replace(/^\s*\{.*?\}\s*/, '').trim();

  // Dividir la respuesta en secciones basadas en los encabezados "### "
  const sections = filteredResponse.split(/(?=### )/).map(s => s.trim()).filter(s => s);

  for (const section of sections) {
    await flowDynamic(section);
    // Espera de 3 segundos antes de enviar el siguiente mensaje
    await new Promise(resolve => setTimeout(resolve, 3000));
  }
}


// utils\logger.js

import winston from 'winston';
import config from '../config/config.js';
import moment from 'moment-timezone';

const { combine, timestamp, printf } = winston.format;

const myFormat = printf(({ level, message, timestamp }) => {
  const formattedTimestamp = moment(timestamp).tz('America/Santiago').format('DD-MM-YY - HH:mm:ss a');
  return `${formattedTimestamp} : [${level.toUpperCase()}] ${message}`;
});

const logger = winston.createLogger({
  level: config.logLevel || 'info',
  format: combine(
    timestamp(),
    myFormat
  ),
  defaultMeta: { service: 'chatbot-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: myFormat,
  }));
}

export default logger;


