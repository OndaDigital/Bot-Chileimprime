
// app.js

import "dotenv/config";
import flowManager from './modules/flowManager.js';
import whatsappService from './services/whatsappService.js';
import sheetService from './services/sheetService.js';
import logger from './utils/logger.js';
import createMiddleware from './core/middleware.js';
import logMiddleware from './core/log-middleware.js';
import userContextManager from './modules/userContext.js';
import config from './config/config.js';
import { errorHandler } from './utils/errorHandler.js';
import fileValidationService from './services/fileValidationService.js';

const middleware = createMiddleware([logMiddleware]);

const initializeServices = async () => {
  let services = null;
  let additionalInfo = null;

  try {
    await sheetService.initialize();

    services = await sheetService.getServices();
    additionalInfo = await sheetService.getAdditionalInfo();
    
    if (services && additionalInfo) {
      userContextManager.setGlobalData(services, additionalInfo);
      logger.info("Servicios e informaci√≥n adicional inicializados correctamente");
    } else {
      throw new Error("No se pudieron obtener los servicios o la informaci√≥n adicional");
    }
  } catch (error) {
    logger.error(`Error al inicializar servicios: ${error.message}`);
    logger.warn("Iniciando con funcionalidad reducida");
  }

  return { services, additionalInfo };
};

const main = async () => {
  try {
    const { services, additionalInfo } = await initializeServices();

    const flows = await flowManager.initializeFlows();

    flows.forEach(flow => {
      flow.addAction(middleware);
    });

    await whatsappService.initialize(flows);

    logger.info('Bot inicializado correctamente');

    if (services && additionalInfo) {
      logger.info('Bot iniciado con todas las funcionalidades');
    } else {
      logger.warn('Bot iniciado con funcionalidad reducida. Algunas caracter√≠sticas pueden no estar disponibles.');
    }

    // Configurar actualizaci√≥n peri√≥dica de los servicios y la informaci√≥n adicional
    setInterval(async () => {
      try {
        await sheetService.reinitialize();
        const updatedServices = await sheetService.getServices();
        const updatedAdditionalInfo = await sheetService.getAdditionalInfo();
        if (updatedServices && updatedAdditionalInfo) {
          userContextManager.setGlobalData(updatedServices, updatedAdditionalInfo);
          logger.info("Servicios e informaci√≥n adicional actualizados correctamente");
        } else {
          logger.warn("No se pudieron actualizar los servicios o la informaci√≥n adicional");
        }
      } catch (error) {
        logger.error(`Error al actualizar servicios e informaci√≥n adicional: ${error.message}`);
      }
    }, config.servicesUpdateInterval);

  } catch (error) {
    logger.error(`Error cr√≠tico al inicializar el bot: ${error.message}`);
    process.exit(1);
  }
};

main().catch(err => {
  logger.error('Error fatal en main:', err);
  process.exit(1);
});

// Manejo de errores no capturados
process.on('uncaughtException', (error) => {
  logger.error(`Uncaught Exception: ${error.message}`);
  // Implementar l√≥gica adicional si es necesario (por ejemplo, reiniciar el bot)
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error(`Unhandled Rejection at: ${promise}, reason: ${reason}`);
  // Implementar l√≥gica adicional si es necesario
});


// commandProcessor.js

import logger from './utils/logger.js';
import userContextManager from './modules/userContext.js';
import orderManager from './modules/orderManager.js';
import openaiService from './services/openaiService.js';
import config from './config/config.js';
import sheetService from './services/sheetService.js'
import { formatPrice, sendSplitMessages } from './utils/helpers.js';
import { normalizeCommand, findClosestCommand, sanitizeJsonString } from './utils/commandUtils.js';
import { CustomError } from './utils/errorHandler.js';

class CommandProcessor {
  constructor() {}

  async processCommand(command, userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Procesando comando para usuario ${userId}: ${JSON.stringify(command)}`);

      // Normalizar y corregir el comando
      const normalizedCommand = normalizeCommand(command.command);
      const correctedCommand = findClosestCommand(normalizedCommand) || normalizedCommand;
      
      logger.info(`Comando normalizado: ${normalizedCommand}, Comando corregido: ${correctedCommand}`);
      
      if (correctedCommand !== command.command) {
        logger.warn(`Comando corregido de "${command.command}" a "${correctedCommand}"`);
      }

      switch (correctedCommand) {
        case "LIST_ALL_SERVICES":
          return this.handleListAllServices(userId);
        case "SELECT_SERVICE":
          return this.handleSelectService(userId, command.service);
        case "SET_MEASURES":
          return this.handleSetMeasures(userId, command.width, command.height);
        case "SET_QUANTITY":
          return this.handleSetQuantity(userId, command.quantity);
        case "SET_FINISHES":
          return this.handleSetFinishes(userId, command.sellado, command.ojetillos, command.bolsillo);
        case "RESULT_ANALYSIS":
            return this.handleAnalysisResult(userId, command.result);
        case "CONFIRM_ORDER":
          return this.handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow });
        default:
          logger.warn(`Comando desconocido recibido: ${command.command}`);
          return { currentOrderUpdated: false };
      }
    } catch (error) {
      logger.error(`Error al procesar comando: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  // Nuevo m√©todo para manejar RESULT_ANALYSIS
  async handleAnalysisResult(userId, result) {
    try {
      const isValid = result === true || result === "true";
      userContextManager.updateCurrentOrder(userId, { fileValidation: isValid });
      logger.info(`Resultado del an√°lisis actualizado para usuario ${userId}: ${isValid}`);
      return { currentOrderUpdated: true };
    } catch (error) {
      logger.error(`Error al actualizar resultado del an√°lisis para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetQuantity(userId, quantity) {
    try {
      const result = await orderManager.handleSetQuantity(userId, quantity);
      logger.info(`Cantidad establecida para usuario ${userId}: ${quantity}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetFinishes(userId, sellado, ojetillos, bolsillo) {
    try {
      const result = await orderManager.setFinishes(userId, sellado, ojetillos, bolsillo);
      logger.info(`Acabados establecidos para usuario ${userId}: sellado=${sellado}, ojetillos=${ojetillos}, bolsillo=${bolsillo}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }

  async handleSetMeasures(userId, width, height) {
    try {
      const result = await orderManager.handleSetMeasures(userId, width, height);
      logger.info(`Medidas establecidas para usuario ${userId}: ${width}x${height}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleFileAnalysis(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);
    const fileAnalysis = currentOrder.fileAnalysis;
 
    if (!fileAnalysis) {
      await flowDynamic("Lo siento, parece que no hay un archivo para analizar. Por favor, env√≠a un archivo primero.");
      return;
    }
 
    logger.info(`Iniciando an√°lisis de archivo para usuario ${userId}`);
    let response = "He analizado tu archivo. Aqu√≠ est√°n los resultados:\n\n";
    response += `üìÑ Formato: *${fileAnalysis.format}*\n`;
    response += `üìè Dimensiones en p√≠xeles: *${fileAnalysis.width}x${fileAnalysis.height}*\n`;
   
    const widthM = fileAnalysis.physicalWidth.toFixed(2);
    const heightM = fileAnalysis.physicalHeight.toFixed(2);
    response += `üìê Dimensiones f√≠sicas: *${widthM}x${heightM} m* (${(widthM*100).toFixed(2)}x${(heightM*100).toFixed(2)} cm)\n`;
   
    response += `üìä √Årea del dise√±o: *${fileAnalysis.area} m¬≤*\n`;
    response += `üîç Resoluci√≥n: *${fileAnalysis.dpi} DPI*\n`;
   
    if (fileAnalysis.colorSpace) {
      response += `üé® Espacio de color: *${fileAnalysis.colorSpace}*\n`;
    }
   
    if (fileAnalysis.fileSize) {
      response += `üì¶ Tama√±o del archivo: *${fileAnalysis.fileSize}*\n`;
    }
 
    logger.info(`An√°lisis de archivo completado para usuario ${userId}: ${JSON.stringify(fileAnalysis)}`);
    await flowDynamic(response);
    userContextManager.updateFileAnalysisResponded(userId, true);

    // Generar y enviar el segundo mensaje
    await this.handleFileValidationInstruction(ctx, flowDynamic);
  }

  async handleFileValidationInstruction(ctx, flowDynamic) {
    const userId = ctx.from;
    const currentOrder = userContextManager.getCurrentOrder(userId);

    // Verificar que el currentOrder est√° actualizado
    if (!currentOrder.service || (!currentOrder.measures && currentOrder.requiresMeasures())) {
      // Solicitar la informaci√≥n faltante al usuario
      await flowDynamic("Parece que falta informaci√≥n en tu pedido. Por favor, aseg√∫rate de haber proporcionado el servicio y las medidas necesarias.");
      return;
    }

    // Informaci√≥n detallada sobre la importancia del DPI seg√∫n el √°rea y la distancia de visualizaci√≥n
    // Informaci√≥n detallada sobre la importancia del DPI seg√∫n el √°rea y la distancia de visualizaci√≥n
    const dpiGuidelines = `
    üìè **Resoluci√≥n (DPI) seg√∫n el √Årea y Distancia de Visualizaci√≥n** üìê

    Ten en cuenta lo siguiente sobre la resoluci√≥n (DPI) en funci√≥n del √°rea del servicio *${currentOrder.areaServicio} m¬≤* y la distancia de visualizaci√≥n, aplicando a productos espec√≠ficos de *Chileimprime*:

    - **√Åreas peque√±as (menos de 1.0 m¬≤)** üñºÔ∏è:
      - Se recomienda una resoluci√≥n de *150-300 DPI* para obtener alta calidad.
      - Ideal para productos como *Tarjetas de presentaci√≥n (1000 unidades)*, *Flyers 15√ó22 cms*, y *Mini Roller de escritorio papel sint√©tico*, los cuales se observan de cerca (distancia menor a *1.5 metros*).

    - **√Åreas medianas (1.5 m¬≤ a 5 m¬≤)** üìä:
      - La resoluci√≥n puede oscilar entre *72 y 150 DPI*.
      - Adecuada para *Pendones Roller 90x200 cms*, *Palomas 2 caras 70x120 cms*, y *PVC 11 Oz mt¬≤*, que se visualizan desde distancias intermedias (*1.5 a 3 metros*).

    - **√Åreas grandes (5 m¬≤ a 10 m¬≤)** üì¢:
      - Se recomienda una resoluci√≥n entre *35 y 72 DPI*.
      - Ideal para *Back Light Banner*, *Tela Mesh* y *PVC Blackout*, que se ver√°n a distancias de *3 a 5 metros*.

    - **√Åreas muy grandes (m√°s de 10 m¬≤)** üè¢:
      - Resoluciones bajas, entre *20 y 35 DPI*, son aceptables debido a que estos gr√°ficos se ven desde distancias mayores a *5 metros*.
      - Ejemplos: *Murales publicitarios*, *Back Light Textil*, o *Windows One Vision* que ser√°n observados a grandes distancias.

    ### üìå Notas Adicionales:
    1. **Distancia de Visualizaci√≥n** üëÄ: Es un factor cr√≠tico para determinar el DPI correcto. A mayor distancia, menor es la necesidad de alta resoluci√≥n, ya que el ojo humano no distingue los detalles finos.
    2. **Tama√±o del Archivo** üíæ: Usar resoluciones demasiado altas en √°reas grandes como *PVC Alta Definici√≥n* para grandes formatos incrementa significativamente el tama√±o del archivo y el tiempo de impresi√≥n sin una mejora perceptible en la calidad visual.
    3. **Material Espec√≠fico** üß±: Productos como *Adhesivo Empavonado*, *Vinilo Adhesivo Reflectante* y *Rotulaci√≥n para fundido* requieren considerar el material y su capacidad de impresi√≥n, por lo que es recomendable mantener el DPI en el rango medio de *72-150 DPI* para garantizar una buena nitidez.

    ‚ú® **Emojis y Formateo**:
    - Utiliza emojis relevantes para resaltar puntos importantes.
    - Aplica **formateo con asteriscos** usando un asterisco por lado (*texto*) para resaltar palabras clave.
    - Aseg√∫rate de mantener una estructura clara con saltos de l√≠nea para facilitar la lectura en WhatsApp.

    Estas gu√≠as te ayudar√°n a optimizar la calidad y la eficiencia en cada proyecto de impresi√≥n seg√∫n el tipo de producto y su aplicaci√≥n en el mercado chileno.
    `;

    // Generar la instrucci√≥n para la IA con mayor contexto y flexibilidad
    const instruction = `üîÑ **Nueva Solicitud de Archivo** üìÇ

    El usuario acaba de subir un archivo. Ahora eres un **experto en impresi√≥n de gran formato** e **ingeniero en color**. Verifica el *currentOrder* y responde seg√∫n las siguientes condiciones:

    1. üìê **An√°lisis del Archivo**:
      - Analiza el archivo proporcionado considerando una tolerancia del *20%* en cuanto a las medidas y el √°rea del dise√±o comparado con el servicio solicitado.
      - Ten mucho cuidado con el area del servicio con respecto al area del dise√±o

    2. üìä **Directrices de DPI**:
      - Ten en cuenta las siguientes directrices para el DPI:
      <dpiGuidelines>${dpiGuidelines}</dpiGuidelines>
      
    3. üõ†Ô∏è **Casos Especiales**:
      - Considera que en casos especiales, como areas muy grandes que superan las limitaciones t√©cnicas, como areas que superen los 5m2, es aceptable reducir la exigencia de DPI hasta 30 o menos para adaptar el dise√±o a las dimensiones fisicas,
      tu eres el experto que decide el DPI correcto que debe tener el dise√±o en funcion al las guias de <dpiGuidelines>. Y ten cuidado de que para areas muy grandes de impresion, debes pedir que los archivos tambien tengan alta resolucion,
      verifica la resolucion del archivo enviado por el cliente y en caso de que no cumpla con su area de impresion pero si con los DPI darle los pasos para corregir su archivo.
      
    4. üßê **Evaluaci√≥n de Adecuaci√≥n**:
      - Aplica tu expertise en impresi√≥n para evaluar si el archivo es adecuado, incluso si no cumple exactamente con los criterios, pero est√° dentro de la tolerancia del *20%*.
      
    5. ‚úÖ **Validaci√≥n del Archivo**:
      - Si el archivo es v√°lido o puede ser aceptado con modificaciones menores, indica que es v√°lido.
      
    6. ‚ùå **Invalidez del Archivo**:
      - Si el archivo no es v√°lido, proporciona una explicaci√≥n detallada y consejos espec√≠ficos para que el cliente pueda corregirlo.

    üìã **Informaci√≥n para la Validaci√≥n**:
    - **Servicio seleccionado**: *${currentOrder.service}*
    - **√Årea del servicio solicitado**: *${currentOrder.areaServicio ? currentOrder.areaServicio.toFixed(2) : 'No disponible'} m¬≤*
    - **√Årea del dise√±o proporcionado**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.area.toFixed(2) : 'No disponible'} m¬≤*
    - **Resoluci√≥n del dise√±o**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.dpi : 'No disponible'} dpi*
    - **Formato del dise√±o**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.format : 'No disponible'}*
    - **Espacio de color del dise√±o**: *${currentOrder.fileAnalysis ? currentOrder.fileAnalysis.colorSpace : 'No disponible'}*

    üìë **Criterios de Validaci√≥n**:
    ${userContextManager.getFileValidationCriteria()}

    ‚ö†Ô∏è **IMPORTANTE**:
    - Al inicio de tu respuesta, incluye un comando JSON indicando el resultado del an√°lisis, en el siguiente formato:
      {"command": "RESULT_ANALYSIS", "result": true/false}
    - Luego, proporciona la respuesta al usuario siguiendo un formato fijo de 3 secciones, separadas por encabezados "### ":
      1. ### üîç Criterios de Validaci√≥n Aplicados:
        - Explica brevemente los criterios que aplicaste en este caso espec√≠fico.
      2. ### {EMOJI de cruz o check dependiendo del resultado} Resultado de la Validaci√≥n:
        - Indica si el archivo es v√°lido o no, y proporciona detalles, sobretodo si el resultado es negativo,
          explica y brinda detalladamente lo que debe hacer el cliente para que su archivo sea valido para su impresion en funcion al area de impresion.
      3. ### üëâ Siguiente Paso:
        - Indica al usuario cu√°l es el siguiente paso en el proceso.

    - Aseg√∫rate de que tu respuesta siga este formato exactamente, para que pueda ser dividida en mensajes separados.
    - **Incluye emojis y utiliza asteriscos para el formateo** en toda tu respuesta para mejorar la interacci√≥n en WhatsApp.

    Responde al usuario siguiendo estas indicaciones.
    `;


    // Log para depuraci√≥n
    logger.info(`Enviando instrucci√≥n a la IA para validaci√≥n de archivo para usuario ${userId}: ${instruction}`);

    const aiResponse = await openaiService.getChatCompletion(
      openaiService.getSystemPrompt(userContextManager.getGlobalServices(), currentOrder, userContextManager.getGlobalAdditionalInfo(), userContextManager.getChatContext(userId)),
      userContextManager.getChatContext(userId).concat({ role: "system", content: instruction })
    );

    // Actualizar el contexto de chat
    userContextManager.updateContext(userId, instruction, "system");
    userContextManager.updateContext(userId, aiResponse, "assistant");

    // Log de la respuesta de la IA
    logger.info(`Respuesta de la IA para validaci√≥n de archivo para usuario ${userId}: ${aiResponse}`);

    // Procesar comandos en la respuesta de la IA
    const commands = this.processAIResponseCommandProcessor(aiResponse);
    for (const command of commands) {
      await this.processCommand(command, userId, ctx, { flowDynamic });
    }

    // Enviar los mensajes divididos al usuario
    await sendSplitMessages(flowDynamic, aiResponse);
  }

  processAIResponseCommandProcessor(aiResponse) {
    const commandRegex = /{[^}]+}/g;
    const commands = aiResponse.match(commandRegex) || [];
    return commands.map(cmd => {
      try {
        const sanitizedCmd = sanitizeJsonString(cmd);
        logger.debug(`Comando sanitizado: ${sanitizedCmd}`);
        const parsedCmd = JSON.parse(sanitizedCmd);
        logger.info(`Comando parseado correctamente: ${JSON.stringify(parsedCmd)}`);
        return parsedCmd;
      } catch (error) {
        logger.error(`Error al parsear comando JSON: ${error.message}`);
        logger.debug(`Comando problem√°tico: ${cmd}`);
        return null;
      }
    }).filter(cmd => cmd !== null);
  }
  

  async handleListAllServices(userId, actions) {
    const services = sheetService.getServices();
    const formattedServices = this.formatServiceList(services);
    logger.info(`Lista de servicios preparada para usuario ${userId}`);
    
    return { 
      currentOrderUpdated: true, 
      action: 'SHOW_SERVICES',
      data: formattedServices
    };
  }

  formatServiceList(services) {
    let formattedList = "Aqu√≠ tienes la lista completa de servicios disponibles:\n\n";

    const categoryEmojis = {
      'Telas PVC': 'üñºÔ∏è',
      'Banderas': 'üö©',
      'Adhesivos': 'üè∑Ô∏è',
      'Adhesivo Vehicular': 'üöó',
      'Back Light': 'üí°',
      'Otros': 'üì¶',
      'Imprenta': 'üñ®Ô∏è',
      'P√©ndon Roller': 'üéûÔ∏è',
      'Palomas': 'üê¶',
      'Figuras': 'üî∫',
      'Extras': '‚ûï'
    };

    for (const [category, categoryServices] of Object.entries(services)) {
      const emojiIcon = categoryEmojis[category] || '';
      formattedList += `${emojiIcon} *${category}:*\n`;

      categoryServices.forEach(service => {
        const serviceName = service.name;
        const priceFormatted = formatPrice(service.precio);
        const priceBold = `*$${
          priceFormatted
        }*`; // Envuelve el precio con asteriscos para negrita
        formattedList += `- ${serviceName}: ${priceBold}\n`;
      });
      formattedList += "\n";
    }

    formattedList += "Para obtener m√°s informaci√≥n sobre un servicio espec√≠fico, por favor menciona su nombre.";
    return formattedList;
  }

  async handleSelectService(userId, serviceName) {
    if (!serviceName) {
      logger.warn(`Nombre de servicio inv√°lido: ${serviceName}`);
      await flowDynamic('Parece que no has especificado un servicio v√°lido. Por favor, ind√≠canos qu√© servicio deseas.');
      return { currentOrderUpdated: false, error: 'El nombre del servicio es inv√°lido o no se proporcion√≥.' };
    }

    try {
      const result = await orderManager.handleSelectService(userId, serviceName);
      logger.info(`Servicio seleccionado para usuario ${userId}: ${serviceName}`);
      return { currentOrderUpdated: true, ...result };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      await flowDynamic(`Lo siento, ha ocurrido un error al seleccionar el servicio. ${error.message}`);
      return { currentOrderUpdated: false, error: error.message };
    }
  }


  async handleConfirmOrder(userId, ctx, { flowDynamic, gotoFlow, endFlow }) {
    try {
      logger.info(`Iniciando proceso de confirmaci√≥n de orden para usuario ${userId}`);

      // Modificaci√≥n: Verificar si la orden ya est√° confirmada
      if (orderManager.isOrderConfirmed(userId)) {
        logger.warn(`La orden para el usuario ${userId} ya ha sido confirmada. Evitando doble confirmaci√≥n.`);
        await flowDynamic("‚úÖ Tu pedido ya ha sido confirmado previamente. Si necesitas asistencia adicional, por favor contacta con un representante.");
        return { currentOrderUpdated: false };
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        const missingFields = userContextManager.getIncompleteFields(userId);
        const errorMessage = `La orden no est√° completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
        logger.warn(errorMessage);
        throw new CustomError('IncompleteOrderError', errorMessage);
      }
  
      // A√±adir informaci√≥n del contexto
      currentOrder.userName = ctx.pushName || 'Cliente';
      currentOrder.userPhone = ctx.from;
  
      // Calcular precios y actualizar la orden
      const calculatedPrices = orderManager.calculatePrice(currentOrder);
      currentOrder.precioTerminaciones = calculatedPrices.precioTerminaciones;
      currentOrder.precioTotalTerminaciones = calculatedPrices.precioTotalTerminaciones;
      currentOrder.total = calculatedPrices.total;
  
      logger.info(`Precios calculados para la orden: ${JSON.stringify(calculatedPrices)}`);
  
      const result = await orderManager.finalizeOrder(userId, currentOrder);
      
      if (result.success) {
        logger.info(`Pedido confirmado para usuario ${userId}. N√∫mero de pedido: ${result.orderNumber}`);

        // Modificaci√≥n: Enviar resumen de la orden
        const orderSummary = orderManager.formatOrderSummary(currentOrder);
        await flowDynamic(`üéâ ¬°Gracias por tu pedido! Tu n√∫mero de cotizaci√≥n es: *${result.orderNumber}*`);
        await flowDynamic(orderSummary);
        await flowDynamic(result.message);

        return { currentOrderUpdated: true, nextFlow: 'promoFlow' };
      } else {
        throw new Error("Error al confirmar el pedido");
      }
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      if (error.name === 'IncompleteOrderError') {
        const systemMessage = `Campos faltantes: ${error.message}`;
        userContextManager.updateContext(userId, systemMessage, "system");
        await flowDynamic("Lo siento, pero parece que falta informaci√≥n en tu pedido. Por favor, completa todos los detalles antes de confirmar.");
        return { currentOrderUpdated: false, error: error.message };
      } else {
        await flowDynamic("Lo siento, ha ocurrido un error al procesar tu pedido. Por favor, intenta nuevamente o contacta con nuestro equipo de soporte.");
        return { currentOrderUpdated: false, error: error.message };
      }
    }
  }


  
}

export default new CommandProcessor();


// config\config.js

// config/config.js

import dotenv from 'dotenv';
import { CustomError } from '../utils/errorHandler.js';

dotenv.config();

const requiredEnvVars = [
  'PORT',
  'GOOGLE_SHEET_ID',
  'OPENAI_API_KEY',
  'GOOGLE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_PRIVATE_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Google Drive: ${envVar}`);
  }
}

// variables de entorno para Google Drive
const requiredDriveEnvVars = [
  'GOOGLE_DRIVE_SERVICE_ACCOUNT_EMAIL',
  'GOOGLE_DRIVE_PRIVATE_KEY',
  'GOOGLE_DRIVE_FOLDER_ID',
];

for (const envVar of requiredDriveEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Google Drive: ${envVar}`);
  }
}

//Variables gmail
const requiredGmailEnvVars = [
  'GMAIL_USER_EMAIL',
  'GMAIL_APP_PASSWORD',
];

for (const envVar of requiredGmailEnvVars) {
  if (!process.env[envVar]) {
    throw new CustomError('ConfigError', `Missing required environment variable for Gmail API: ${envVar}`);
  }
}

export default {
  port: process.env.PORT,
  googleSheetId: process.env.GOOGLE_SHEET_ID,
  openaiApiKey: process.env.OPENAI_API_KEY,
  googleServiceAccountEmail: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
  googlePrivateKey: process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, "\n"),
  blacklistDuration: parseInt(process.env.BLACKLIST_DURATION) || 10 * 60 * 1000,
  humanBlacklistDuration: parseInt(process.env.HUMAN_BLACKLIST_DURATION) || 60 * 60 * 1000,
  abuseBlacklistDuration: parseInt(process.env.ABUSE_BLACKLIST_DURATION) || 24 * 60 * 60 * 1000,
  idleWarningTime: parseInt(process.env.IDLE_WARNING_TIME) || 5 * 60 * 1000,
  idleTimeoutTime: parseInt(process.env.IDLE_TIMEOUT_TIME) || 10 * 60 * 1000,
  maxAudioSize: parseInt(process.env.MAX_AUDIO_SIZE) || 5 * 1024 * 1024,
  languageModel: process.env.LANGUAGE_MODEL || 'ft:gpt-4o-mini-2024-07-18:personal:modelo-chile-imprime:AEWZI9XK',
  timezone: process.env.TIMEZONE || 'America/Santiago',
  logLevel: process.env.LOG_LEVEL || 'info',
  maxTokens: parseInt(process.env.MAX_TOKENS) || 2000,
  temperature: parseFloat(process.env.TEMPERATURE) || 0.5,
  messageQueueGapSeconds: parseInt(process.env.MESSAGE_QUEUE_GAP_SECONDS) || 3000,
  promoMessageDelay: parseInt(process.env.PROMO_MESSAGE_DELAY) || 15000,
  servicesUpdateInterval: parseInt(process.env.SERVICES_UPDATE_INTERVAL) || 60 * 60 * 1000,
   // Credenciales para Google Drive
   googleDriveServiceAccountEmail: process.env.GOOGLE_DRIVE_SERVICE_ACCOUNT_EMAIL,
   googleDrivePrivateKey: process.env.GOOGLE_DRIVE_PRIVATE_KEY.replace(/\\n/g, "\n"),
   googleDriveFolderId: process.env.GOOGLE_DRIVE_FOLDER_ID,
   // Credenciales para Gmail
   gmailAppPassword: process.env.GMAIL_APP_PASSWORD,
   gmailUserEmail: process.env.GMAIL_USER_EMAIL,
};


// core\blacklist-middleware.js

// core/blacklist-middleware.js

import logger from '../utils/logger.js';

const blacklistMiddleware = (flowManager) => async (ctx, { endFlow }) => {
  const userId = ctx.from;

  if (flowManager.isBlacklisted(userId)) {
    logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
    return endFlow();
  }

  return false; // Continuar con el flujo normal
};

export default blacklistMiddleware;


// core\inactivity-middleware.js

// core/inactivity-middleware.js

import logger from '../utils/logger.js';
import config from '../config/config.js';

const inactivityMiddleware = (flowManager) => async (ctx, { flowDynamic, gotoFlow }) => {
  const userId = ctx.from;

  flowManager.clearIdleTimer(userId);
  
  const warningTimer = setTimeout(async () => {
    await flowDynamic('*‚è∞ ¬øSigues ah√≠? Si necesitas m√°s tiempo, por favor responde cualquier mensaje.*');
  }, config.idleWarningTime);

  const timeoutTimer = setTimeout(() => {
    flowManager.resetConversation(userId);
    gotoFlow(flowManager.getIdleTimeoutFlow());
  }, config.idleTimeoutTime);

  flowManager.setIdleTimers(userId, { warningTimer, timeoutTimer });

  return false; // Continuar con el flujo normal
};

export default inactivityMiddleware;


// core\log-middleware.js

import logger from '../utils/logger.js';

const logMiddleware = async (ctx) => {
  const { from, body } = ctx;
  logger.info(`Mensaje recibido de ${from}: ${body}`);
  return false; // Continuar con el flujo normal
};

export default logMiddleware;


// core\middleware.js

// core/middleware.js

import logger from '../utils/logger.js';

const createMiddleware = (middlewares) => {
  return async (ctx, { flowDynamic, endFlow }) => {
    for (const middleware of middlewares) {
      try {
        const result = await middleware(ctx, { flowDynamic, endFlow });
        if (result === true) {
          return true; // Middleware ha manejado la solicitud, detener el flujo
        }
      } catch (error) {
        logger.error(`Error en middleware: ${error.message}`);
        await flowDynamic('Lo siento, ha ocurrido un error. Por favor, int√©ntalo de nuevo m√°s tarde.');
        return endFlow();
      }
    }
    return false; // Continuar con el flujo normal
  };
};

export default createMiddleware;



// modules\flowManager.js

import { addKeyword, EVENTS } from '@builderbot/bot';
import logger from '../utils/logger.js';
import userContextManager from './userContext.js';
import orderManager from './orderManager.js';
import openaiService from '../services/openaiService.js';
import whatsappService from '../services/whatsappService.js';
import config from '../config/config.js';
import { CustomError } from '../utils/errorHandler.js';
import inactivityMiddleware from '../core/inactivity-middleware.js';
import blacklistMiddleware from '../core/blacklist-middleware.js';
import MessageQueue from './messageQueue.js';
import fileValidationService from '../services/fileValidationService.js';
import commandProcessor from '../commandProcessor.js';

class FlowManager {
  constructor() {
    this.flows = {
      principalFlow: null,
      confirmedFlow: null,
      restartBotFlow: null,
      documentFlow: null,
      voiceNoteFlow: null,
      catchAllFlow: null,
      idleTimeoutFlow: null,
      promoFlow: null,
      mediaFlow: null
    };
    this.blacklist = new Map();
    this.idleTimers = new Map();
    this.messageQueue = new MessageQueue({ gapSeconds: config.messageQueueGapSeconds });
    this.cooldowns = new Map();
    this.initialMessagePromises = new Map();
    this.initialMessageLocks = new Map(); // A√±ade esta l√≠nea

  }


  async initializeFlows() {
    try {
      // Inicializar los flujos
      this.flows.principalFlow = this.createPrincipalFlow();
      this.flows.confirmedFlow = this.createConfirmedFlow();
      this.flows.restartBotFlow = this.createRestartBotFlow();
      this.flows.documentFlow = this.createDocumentFlow();
      this.flows.voiceNoteFlow = this.createVoiceNoteFlow();
      this.flows.catchAllFlow = this.createCatchAllFlow();
      this.flows.idleTimeoutFlow = this.createIdleTimeoutFlow();
      this.flows.promoFlow = this.createPromoFlow();
      this.flows.mediaFlow = this.createMediaFlow();

      // Agregar middlewares
      Object.values(this.flows).forEach(flow => {
        if (flow && typeof flow.addAction === 'function') {
          flow.addAction(inactivityMiddleware(this));
          flow.addAction(blacklistMiddleware(this));
        } else {
          logger.warn(`Un flujo no tiene el m√©todo addAction o es nulo`);
        }
      });

      logger.info('Flujos inicializados correctamente');
      return Object.values(this.flows).filter(flow => flow !== null);
    } catch (error) {
      logger.error(`Error al inicializar flujos: ${error.message}`);
      throw new CustomError('FlowInitializationError', 'Error al inicializar los flujos', error);
    }
  }


  getFlowByName(name) {
    return this.flows[name];
  }

  // Nuevo m√©todo centralizado para manejar mensajes iniciales
  async handleInitialMessagesOnce(userId, flowDynamic) {
    logger.info(`Intentando enviar mensajes iniciales para usuario ${userId}`);
    
    if (this.initialMessageLocks.get(userId)) {
      logger.info(`Usuario ${userId} ya tiene mensajes iniciales en proceso. Ignorando nueva solicitud.`);
      return;
    }

    this.initialMessageLocks.set(userId, true);

    if (!this.initialMessagePromises.has(userId)) {
      this.initialMessagePromises.set(userId, (async () => {
        if (!userContextManager.hasUserInteracted(userId)) {
          logger.info(`Iniciando env√≠o de mensajes iniciales para usuario ${userId}`);

          try {
            // Crear una cola de mensajes
            const messageQueue = [
              { type: 'image', content: 'https://chileimprime.cl/wp-content/uploads/2024/10/Camapanas-politicas-chileimprime-el-m2-mas-economico.jpg' },
              { type: 'services', content: await commandProcessor.handleListAllServices(userId) },
              { type: 'text', content: `
üëâ Selecciona uno de los servicios enviados para iniciar tu cotizaci√≥n.

Tambi√©n puedes realizar las siguientes acciones:
- üîç Ver el estado de tus pedidos anteriores
- üïí Consultar horarios de atenci√≥n
- üéâ Conocer nuestras promociones actuales
- üñ®Ô∏è Resolver dudas sobre procesos de impresi√≥n
- üìÑ Consultar especificaciones de archivos o par√°metros t√©cnicos
- üéôÔ∏è Analizar archivos en tiempo real para evaluar validez.

Si necesitas contactar a un agente, por favor escribe *agente* o *humano.*

Para reiniciar el bot en cualquier momento, simplemente escribe *bot.*` }
            ];

            // Enviar mensajes de la cola con un intervalo
            for (const message of messageQueue) {
              switch (message.type) {
                case 'image':
                  await flowDynamic([{ body: 'Promo campa√±as pol√≠ticas', media: message.content }]);
                  break;
                case 'services':
                  if (message.content && message.content.data) {
                    await flowDynamic(message.content.data);
                  }
                  break;
                case 'text':
                  await flowDynamic(message.content);
                  break;
              }
              await new Promise(resolve => setTimeout(resolve, 3000)); // Espera 3 segundos entre mensajes
            }

            userContextManager.setInitialMessagesSent(userId, true);
            userContextManager.setHasInteracted(userId, true);
            logger.info(`Mensajes iniciales enviados y estado actualizado para usuario ${userId}`);
          } catch (error) {
            logger.error(`Error al enviar mensajes iniciales para usuario ${userId}: ${error.message}`);
          } finally {
            this.initialMessageLocks.delete(userId);
          }
        } else {
          logger.info(`Usuario ${userId} ya ha interactuado, omitiendo mensajes iniciales`);
        }
      })());
    }

    await this.initialMessagePromises.get(userId);
    this.initialMessagePromises.delete(userId);
  }


  createPrincipalFlow() {
    return addKeyword(EVENTS.WELCOME)
      .addAction(async (ctx, { flowDynamic, gotoFlow, endFlow }) => {
        const userId = ctx.from;

        if (this.initialMessageLocks.get(userId)) {
          logger.info(`Ignorando mensaje de usuario ${userId} durante el env√≠o de mensajes iniciales`);
          return;
        }

        if (!userContextManager.hasUserInteracted(userId)) {
          // Send initial messages without processing user input
          await this.handleInitialMessagesOnce(userId, flowDynamic);
        } else {
          // Process user input in subsequent interactions
          this.enqueueMessage(userId, ctx.body, async (accumulatedMessage) => {
            await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
          });
        }
      });
  }

  createMediaFlow() {
    return addKeyword(EVENTS.MEDIA)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Imagen recibida de ${userId}. Enviando instrucciones espec√≠ficas.`);

        userContextManager.setHasInteracted(userId, true);
  
        const messages = [
          'üñºÔ∏è *¬°Hola!* Hemos recibido tu imagen, pero necesitamos que nos env√≠es tu dise√±o como *documento* para preservar la calidad.\n\nLas im√°genes enviadas como foto en WhatsApp se comprimen y pierden calidad, lo que afecta el an√°lisis y la impresi√≥n.\n\nPor favor, env√≠a el mismo archivo como *documento* en uno de los siguientes formatos de alta calidad: *PDF, AI, PSD* o una imagen en alta resoluci√≥n.\n\n*Criterios de Validaci√≥n Resumidos:*\n\n- Resoluci√≥n m√≠nima: 72 dpi y m√°xima: 150 dpi.\n- Formato preferente: CMYK para evitar diferencias de color.\n- Tama√±o real del dise√±o acorde al tama√±o de impresi√≥n.',
          'üì± *C√≥mo enviar un documento en WhatsApp desde Android o iPhone:*\n\n1Ô∏è‚É£ Abre el chat de *Chileimprime*.\n2Ô∏è‚É£ Toca el √≠cono de *adjuntar* (üìé).\n3Ô∏è‚É£ Selecciona *Documento*.\n4Ô∏è‚É£ Busca y selecciona tu archivo de dise√±o.\n5Ô∏è‚É£ Presiona *Enviar*.',
          '‚ú® *Esperamos tu archivo nuevamente como documento para iniciar el an√°lisis.* ¬°Gracias!'
        ];
  
        try {
          for (const message of messages) {
            await flowDynamic(message);
            logger.info(`Mensaje enviado a ${userId}: ${message.substring(0, 50)}...`);
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
          logger.info(`Instrucciones para imagen enviadas exitosamente a ${userId}`);
        } catch (error) {
          logger.error(`Error al enviar mensajes en mediaFlow para usuario ${userId}: ${error.message}`);
          await flowDynamic('‚ö†Ô∏è *Ha ocurrido un error al enviar las instrucciones. Por favor, intenta nuevamente m√°s tarde.*');
        }
      });
  }
  

  createDocumentFlow() {
    return addKeyword(EVENTS.DOCUMENT)
      .addAction(async (ctx, { flowDynamic }) => {
        const userId = ctx.from;
        logger.info(`Documento recibido de ${userId}. Iniciando an√°lisis.`);
        userContextManager.setHasInteracted(userId, true);

        try {
          const filePath = await whatsappService.saveFile(ctx);
          logger.info(`Archivo guardado para usuario ${userId}: ${filePath}`);
  
          const fileInfo = await fileValidationService.analyzeFile(filePath);
          logger.info(`An√°lisis completado para archivo de usuario ${userId}: ${JSON.stringify(fileInfo)}`);
          
          await userContextManager.updateCurrentOrder(userId, {
            filePath: filePath,
            fileAnalysis: fileInfo
          });
          
          await flowDynamic('üìÑ Documento recibido. Analizando...');
  
          await commandProcessor.handleFileAnalysis(ctx, flowDynamic);
          
          logger.info(`An√°lisis de archivo enviado al usuario ${userId}`);
        } catch (error) {
          logger.error(`Error al procesar el documento para usuario ${userId}: ${error.message}`);
          await flowDynamic('‚ùå Hubo un error al procesar tu archivo. Por favor, intenta enviarlo nuevamente o contacta con soporte si el problema persiste.');
        }
      });
    }

    createConfirmedFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          // Modificaci√≥n: Eliminar env√≠o de "SOLICITUD_HUMANO"
          this.addToBlacklist(ctx.from, config.humanBlacklistDuration);
          logger.info(`Cotizaci√≥n ya confirmada para ${ctx.from}. Redirigiendo a atenci√≥n humana.`);
          return endFlow("Un representante se pondr√° en contacto contigo pronto para finalizar tu cotizaci√≥n. Gracias por tu paciencia.");
        });
    }
    
      createRestartBotFlow() {
        return addKeyword(['bot', 'Bot', 'BOT'])
          .addAction(async (ctx, { flowDynamic, gotoFlow }) => {
            const userId = ctx.from;
            logger.info(`Intento de reinicio de bot por usuario ${userId}`);
            this.resetConversation(userId, true); // Reiniciar initialMessagesSent
            logger.info(`Bot reiniciado para usuario ${userId}`);
            await flowDynamic('*¬°Bienvenido de nuevo!* üéâ El bot ha sido reiniciado. *¬øEn qu√© puedo ayudarte hoy?* üòä');
            return gotoFlow(this.flows.principalFlow);
          });
      }

    createVoiceNoteFlow() {
      return addKeyword(EVENTS.VOICE_NOTE)
        .addAction(async (ctx, { flowDynamic, state, gotoFlow, endFlow }) => {
          try {
            const audioPath = await whatsappService.saveAudioFile(ctx);
            const transcription = await openaiService.transcribeAudio(audioPath);
            logger.info(`Transcripci√≥n del audio: ${transcription}`);
            
            await state.update({ lastTranscription: transcription });
            await flowDynamic(`*üìù Transcripci√≥n:*\n${transcription}`);
    
            this.enqueueMessage(ctx.from, transcription, async (accumulatedMessage) => {
              await this.handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, accumulatedMessage);
            });
          } catch (error) {
            logger.error(`Error al procesar la nota de voz: ${error.message}`);
            await flowDynamic('Hubo un error al procesar la nota de voz. Por favor, intenta enviar un mensaje de texto.');
          }
        });
    }
  
  
    createCatchAllFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(this.blacklistMiddleware.bind(this))
        .addAction(async (ctx, { gotoFlow }) => {
          if (orderManager.isOrderConfirmed(ctx.from)) {
            return gotoFlow(this.flows.confirmedFlow);
          } else {
            return gotoFlow(this.flows.principalFlow);
          }
        });
    }
  
    createIdleTimeoutFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { endFlow }) => {
          logger.info(`Tiempo de espera agotado para usuario ${ctx.from}`);
          this.resetConversation(ctx.from);
          return endFlow('*üò¥ Lo siento, el tiempo de espera ha expirado. Tu cotizaci√≥n ha sido cancelada. Si deseas hacer una nueva cotizaci√≥n, por favor env√≠a un mensaje.*');
        });
    }
  
    createPromoFlow() {
      return addKeyword(EVENTS.ACTION)
        .addAction(async (ctx, { flowDynamic, endFlow }) => {
          const promoMessage = whatsappService.getPromoMessage();
          try {
            await flowDynamic(promoMessage);
            logger.info(`Mensaje promocional enviado a ${ctx.from}`);
          } catch (error) {
            logger.error(`Error al enviar mensaje promocional a ${ctx.from}: ${error.message}`);
          }
          return endFlow();
        });
    }
  
    enqueueMessage(userId, message, callback) {
      this.messageQueue.enqueueMessage(userId, message, callback);
    }
  
    async handleChatbotResponse(ctx, { flowDynamic, gotoFlow, endFlow }, message, instruction = '') {
      const userId = ctx.from;
      logger.info(`Procesando mensaje para usuario ${userId}: ${message}`);
  
      if (this.isBlacklisted(userId)) {
        logger.info(`Usuario ${userId} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
  
      if (orderManager.isOrderConfirmed(userId)) {
        logger.info(`Cotizaci√≥n ya confirmada para ${userId}. Redirigiendo a atenci√≥n humana.`);
        return gotoFlow(this.getFlowByName('confirmedFlow'));
      }
  
      this.startIdleTimer(ctx, flowDynamic, gotoFlow);
  
      try {
        const userContext = userContextManager.getUserContext(userId);
        const chatContext = userContextManager.getChatContext(userId);
  
        let aiResponse = await openaiService.getChatCompletion(
          openaiService.getSystemPrompt(userContext.services, userContext.currentOrder, userContext.additionalInfo, chatContext),
          [...chatContext, { role: "user", content: message }],
          instruction
        );
  
        logger.info(`Respuesta inicial de AI para ${userId}: ${aiResponse}`);
  
        // Procesar comandos en la respuesta de la IA
        const commands = this.processAIResponse(aiResponse);
        let currentOrderUpdated = false;
        let missingFields = [];
        let responseHandled = false; // Nueva variable para controlar si la respuesta ya fue manejada
  
        for (const command of commands) {
          // Validar comando antes de procesarlo
          const { validatedCommand, responseSent } = await this.validateCommand(command, userId, aiResponse, message, ctx, flowDynamic);
          if (validatedCommand) {
            if (typeof validatedCommand === 'object') {
              const result = await commandProcessor.processCommand(validatedCommand, userId, ctx, { flowDynamic, gotoFlow, endFlow });
              if (result.currentOrderUpdated) {
                currentOrderUpdated = true;
              }
              if (result.missingFields && result.missingFields.length > 0) {
                missingFields = result.missingFields;
              }
              if (result.messagesSent) {
                logger.info(`Mensajes enviados por comando ${command.command} para ${userId}`);
              }
              if (result.data) {
                await flowDynamic(result.data);
                responseHandled = true;
              }
            }
          }
  
          // Si la respuesta ya fue manejada en validateCommand, establecemos responseHandled en true
          if (responseSent) {
            responseHandled = true;
            break; // Salimos del bucle ya que la respuesta ha sido manejada
          }
        }
  
        // Solo enviar la respuesta original de la IA si no ha sido manejada ya
        if (!responseHandled) {
          const filteredResponse = this.filterJsonCommands(aiResponse);
          if (filteredResponse) {
            await flowDynamic(filteredResponse);
            // Actualizar el contexto con la respuesta enviada
            userContextManager.updateContext(userId, aiResponse, "assistant");
          }
        }
  
        // Actualizar el contexto con el mensaje del usuario
        userContextManager.updateContext(userId, message, "user");
  
        // Manejo de orden completa
        if (userContextManager.isOrderComplete(userId)) {
          logger.info(`Orden completa para ${userId}. Confirmando pedido.`);
          // Enviar comando de confirmaci√≥n
          await commandProcessor.processCommand({ command: "CONFIRM_ORDER" }, userId, ctx, { flowDynamic, gotoFlow, endFlow });
          return gotoFlow(this.getFlowByName('confirmedFlow'));
        }
  
      } catch (error) {
        logger.error(`Error al procesar respuesta para usuario ${userId}: ${error.message}`);
        logger.error(`Stack trace: ${error.stack}`);
        await flowDynamic("Lo siento, ha ocurrido un error inesperado. Por favor, intenta nuevamente en unos momentos.");
      }
    }


  
    processAIResponse(aiResponse) {
      const commandRegex = /{[^}]+}/g;
      const commands = aiResponse.match(commandRegex) || [];
      return commands.map(cmd => {
        try {
          return JSON.parse(cmd);
        } catch (error) {
          logger.error(`Error al parsear comando JSON: ${error.message}`);
          return null;
        }
      }).filter(cmd => cmd !== null);
    }

    filterJsonCommands(aiResponse) {
      // Eliminar todos los comandos JSON de la respuesta
      return aiResponse.replace(/\{.*?\}/g, '').trim();
    }
  
    setIdleTimers(userId, timers) {
      this.idleTimers.set(userId, timers);
    }
  
    addToBlacklist(userId, duration) {
      this.blacklist.set(userId, Date.now() + duration);
      logger.info(`Usuario ${userId} a√±adido a la lista negra por ${duration/1000} segundos`);
    }
  
    isBlacklisted(userId) {
      if (this.blacklist.has(userId)) {
        const blacklistExpiry = this.blacklist.get(userId);
        if (Date.now() < blacklistExpiry) {
          logger.info(`Usuario ${userId} est√° en la lista negra. Tiempo restante: ${(blacklistExpiry - Date.now()) / 1000} segundos`);
          return true;
        } else {
          this.blacklist.delete(userId);
          this.resetConversation(userId);
          logger.info(`Usuario ${userId} removido de la lista negra`);
        }
      }
      return false;
    }
  
    resetConversation(userId, resetInitialMessages = false) {
      userContextManager.resetContext(userId, resetInitialMessages);
      orderManager.resetOrderConfirmation(userId);
      this.blacklist.delete(userId);
      this.clearIdleTimer(userId);
      logger.info(`Conversaci√≥n reiniciada para usuario ${userId}, resetInitialMessages: ${resetInitialMessages}`);
    }
  
    startIdleTimer(ctx, flowDynamic, gotoFlow) {
      this.clearIdleTimer(ctx.from);
      
      const warningTimer = setTimeout(async () => {
        await flowDynamic('*‚è∞ ¬øSigues ah√≠? Si necesitas m√°s tiempo, por favor responde cualquier mensaje.*');
      }, config.idleWarningTime);
  
      const timeoutTimer = setTimeout(() => {
        this.resetConversation(ctx.from);
        gotoFlow(this.getFlowByName('idleTimeoutFlow'));
      }, config.idleTimeoutTime);
  
      this.setIdleTimers(ctx.from, { warningTimer, timeoutTimer });
    }
  
    clearIdleTimer(userId) {
      const timers = this.idleTimers.get(userId);
      if (timers) {
        clearTimeout(timers.warningTimer);
        clearTimeout(timers.timeoutTimer);
        this.idleTimers.delete(userId);
      }
    }
  
    blacklistMiddleware(ctx, { endFlow }) {
      if (this.isBlacklisted(ctx.from)) {
        logger.info(`Usuario ${ctx.from} en lista negra. Mensaje ignorado.`);
        return endFlow();
      }
      return false;
    }

    async validateCommand(command, userId, assistantMessage, userMessage, ctx, flowDynamic) {
      if (command.command === "CONFIRM_ORDER") {
        if (!userContextManager.isOrderComplete(userId)) {
          const missingFields = userContextManager.getIncompleteFields(userId);
          logger.warn(`La orden est√° incompleta para el usuario ${userId}. Campos faltantes: ${missingFields.join(', ')}. Revaluando comando CONFIRM_ORDER.`);
  
          // Llamar primero a extractDataFromUserMessage
          const extractedCommand = await this.extractDataFromUserMessage(userMessage, userId);
  
          if (extractedCommand) {
            logger.info(`Comando extra√≠do de extractDataFromUserMessage para usuario ${userId}: ${JSON.stringify(extractedCommand)}`);
  
            // Procesar el comando extra√≠do
            await commandProcessor.processCommand(extractedCommand, userId, ctx, { flowDynamic });
  
            // Generar una instrucci√≥n para getChatCompletion
            const instruction = `
  El cliente acaba de ${this.getActionDescription(extractedCommand)}.
  
  Contin√∫a la conversaci√≥n con el cliente para avanzar en la cotizaci√≥n.
  
  Importante:
  - No incluyas ning√∫n comando JSON en tu respuesta.
  - No muestres los comandos al cliente.
  - Responde de manera natural y amable, siguiendo las pautas del SystemPrompt.
  
  Responde al cliente:
            `;
  
            // Obtener el SystemPrompt actualizado
            const userContext = userContextManager.getUserContext(userId);
            const systemPrompt = openaiService.getSystemPrompt(
              userContext.services,
              userContext.currentOrder,
              userContext.additionalInfo,
              userContext.chatContext
            );
  
            // Llamar a getChatCompletion con la instrucci√≥n
            const aiResponse = await openaiService.getChatCompletion(
              systemPrompt,
              userContext.chatContext,
              instruction
            );
  
            // Actualizar el contexto
            userContextManager.updateContext(userId, aiResponse, "assistant");
  
            // Enviar la respuesta al cliente
            await flowDynamic(aiResponse);
  
            // Indicar que la respuesta ha sido manejada
            return { validatedCommand: null, responseSent: true };
          } else {
            // Si no se extrae un comando v√°lido, proceder a reevaluateCommand
            const newCommandOrResponse = await this.reevaluateCommand(assistantMessage, userMessage, userId, missingFields);
  
            if (newCommandOrResponse) {
              // Procesar el nuevo comando si existe
              if (newCommandOrResponse.command) {
                logger.info(`Nuevo comando obtenido tras revaluaci√≥n: ${JSON.stringify(newCommandOrResponse.command)}`);
                await commandProcessor.processCommand(newCommandOrResponse.command, userId, ctx, { flowDynamic });
              }
  
              // Enviar la respuesta al usuario si existe
              if (newCommandOrResponse.response) {
                await flowDynamic(newCommandOrResponse.response);
                userContextManager.updateContext(userId, newCommandOrResponse.response, "assistant");
              }
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            } else {
              // Actualizar el contexto del asistente con los campos faltantes
              const systemMessage = `Campos faltantes: La orden no est√° completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
              userContextManager.updateContext(userId, systemMessage, "system");
  
              // Informar al usuario
              await flowDynamic("Parece que a√∫n falta informaci√≥n para completar tu pedido. Por favor, proporci√≥nanos los detalles faltantes.");
  
              // Indicar que la respuesta ha sido manejada
              return { validatedCommand: null, responseSent: true };
            }
          }
        }
      }
      return { validatedCommand: command, responseSent: false };
    }  


    // Nueva funci√≥n para describir la acci√≥n basada en el comando
    getActionDescription(command) {
      switch (command.command) {
        case "SELECT_SERVICE":
          return `seleccionado el servicio: ${command.service}`;
        case "SET_MEASURES":
          return `establecido las medidas: ancho ${command.width} m, alto ${command.height} m`;
        case "SET_QUANTITY":
          return `establecido la cantidad: ${command.quantity}`;
        case "SET_FINISHES":
          return `seleccionado las terminaciones: sellado ${command.sellado}, ojetillos ${command.ojetillos}, bolsillo ${command.bolsillo}`;
        default:
          return `realizado una acci√≥n`;
      }
    }




    // Nueva funci√≥n extractDataFromUserMessage
    async extractDataFromUserMessage(userMessage, userId) {
      logger.info(`Intentando extraer comando del mensaje del usuario ${userId}: "${userMessage}"`);
  
      const chatContext = userContextManager.getChatContext(userId);
      const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');
  
      const currentOrder = userContextManager.getCurrentOrder(userId);
  
      const prompt = `
  Eres un asistente experto en impresi√≥n y gesti√≥n de pedidos. A partir del siguiente mensaje del usuario y el contexto de la conversaci√≥n, extrae el comando apropiado para procesar su solicitud.
  
  Historial de la conversaci√≥n:
  ${lastMessages}
  
  Mensaje del usuario:
  "${userMessage}"
  
  Informaci√≥n actual de la orden:
  ${JSON.stringify(currentOrder)}
  
  Lista de servicios disponibles:
  ${JSON.stringify(userContextManager.getAllServices())}
  
  Tu tarea es analizar el mensaje del usuario y, si es posible, extraer el comando adecuado para avanzar en el procesamiento de su pedido. Solo debes devolver un comando JSON v√°lido si est√°s seguro de que el mensaje del usuario contiene la informaci√≥n necesaria.
  
  Posibles comandos:
  - {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}
  - {"command": "SET_MEASURES", "width": X, "height": Y}
  - {"command": "SET_QUANTITY", "quantity": Z}
  - {"command": "SET_FINISHES", "sellado": true/false, "ojetillos": true/false, "bolsillo": true/false}
  
  Si no es posible extraer un comando v√°lido, no devuelvas nada.
  
  No debes devolver ninguna explicaci√≥n ni texto adicional. Solo devuelve el comando JSON si es aplicable.
  `;
  
      try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de extractDataFromUserMessage para usuario ${userId}: ${aiResponse}`);
  
        // Intentar parsear la respuesta como JSON
        try {
          const extractedCommand = JSON.parse(aiResponse);
          return extractedCommand;
        } catch (parseError) {
          logger.warn(`No se pudo parsear el comando extra√≠do para usuario ${userId}: ${parseError.message}`);
          return null;
        }
      } catch (error) {
        logger.error(`Error al extraer comando del mensaje del usuario ${userId}: ${error.message}`);
        return null;
      }
    }


  async reevaluateCommand(assistantMessage, userMessage, userId, missingFields) {
    logger.info(`Reevaluando comando para usuario ${userId}`);

    // Obtener el historial reciente de la conversaci√≥n
    const chatContext = userContextManager.getChatContext(userId);
    const lastMessages = chatContext.slice(-6).map(msg => `${msg.role}: ${msg.content}`).join('\n');

    // Obtener la lista de servicios disponibles
    const services = userContextManager.getGlobalServices();
    const servicesList = Object.values(services).flat().map(service => service.name).join(', ');
    const currentOrder = userContextManager.getCurrentOrder(userId);

    // Modificaci√≥n del prompt para evitar que el asistente asuma valores por defecto
    const prompt = `
Eres un asistente experto en impresi√≥n y gesti√≥n de pedidos. Aqu√≠ est√° la √∫ltima interacci√≥n:

${lastMessages}

Basado en esta interacci√≥n y el estado actual de la orden:
${JSON.stringify(userContextManager.getCurrentOrder(userId))}

Presta especial atenci√≥n a los siguientes detalles del currentOrder:
- Servicio actual: ${currentOrder.service || 'No seleccionado'}
- Categor√≠a: ${currentOrder.category || 'No especificada'}
- Tipo: ${currentOrder.type || 'No especificado'}
- Medidas seleccionadas: 
  * Ancho: ${currentOrder.measures?.width || 'No especificado'} metros
  * Alto: ${currentOrder.measures?.height || 'No especificado'} metros
- Terminaciones elegidas: 
  * Sellado: ${currentOrder.finishes?.sellado ? 'S√≠' : 'No'}
  * Ojetillos: ${currentOrder.finishes?.ojetillos ? 'S√≠' : 'No'}
  * Bolsillo: ${currentOrder.finishes?.bolsillo ? 'S√≠' : 'No'}
- Cantidad: ${currentOrder.quantity || 'No especificada'}
- Archivo de dise√±o: ${currentOrder.filePath ? 'Subido' : 'No subido'}
- Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
- Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
- √Årea del servicio: ${currentOrder.areaServicio || 'No calculada'} m¬≤

Lista de servicios disponibles: ${servicesList}

Los campos faltantes en la orden son: ${missingFields.join(', ')}

Tu objetivo es ayudar al usuario a completar la informaci√≥n faltante sin asumir ning√∫n valor por defecto. No debes asignar valores a campos faltantes a menos que el usuario los haya proporcionado expl√≠citamente.

Analiza si el comando 'CONFIRM_ORDER' es apropiado. Si la orden est√° incompleta, determina la mejor respuesta posible al usuario para ayudarlo a proporcionar la informaci√≥n faltante.

Recuerda:
- No asumas servicios o valores que el usuario no haya mencionado expl√≠citamente.
- Si el usuario est√° confirmando la selecci√≥n de un servicio, pero no ha proporcionado el nombre del servicio, p√≠dele amablemente que especifique el servicio que desea.
- Proporciona una respuesta clara y amable que gu√≠e al usuario a proporcionar la informaci√≥n faltante.

No debes devolver ning√∫n comando en este caso. Responde al usuario de manera que contin√∫e la conversaci√≥n y facilite la obtenci√≥n de la informaci√≥n necesaria.
    `;

    try {
        const aiResponse = await openaiService.getChatCompletion(prompt, []);
        logger.info(`Respuesta de reevaluaci√≥n del modelo para usuario ${userId}: ${aiResponse}`);

        // Como hemos instruido al asistente a no devolver comandos, procesamos solo la respuesta
        return { command: null, response: aiResponse.trim() };
    } catch (error) {
        logger.error(`Error al reevaluar comando para usuario ${userId}: ${error.message}`);
        return null;
    }
}




  }
  
  export default new FlowManager();


// modules\messageQueue.js

// modules/messageQueue.js

import logger from '../utils/logger.js';

class MessageQueue {
  constructor(config) {
    this.queue = new Map();
    this.config = config;
  }

  enqueueMessage(userId, messageText, callback) {
    logger.info(`Encolando mensaje para usuario ${userId}. Mensaje: ${messageText}`);
    
    if (!this.queue.has(userId)) {
      this.queue.set(userId, { messages: [], timer: null });
      logger.info(`Nueva cola creada para usuario ${userId}`);
    }

    const userQueue = this.queue.get(userId);
    userQueue.messages.push(messageText);

    logger.info(`Mensaje a√±adido a la cola del usuario ${userId}. Mensajes en cola: ${userQueue.messages.length}`);

    clearTimeout(userQueue.timer);

    userQueue.timer = setTimeout(() => {
      logger.info(`Temporizador expirado para usuario ${userId}. Procesando cola...`);
      const messages = userQueue.messages;
      this.queue.delete(userId);
      logger.info(`Cola procesada y eliminada para usuario ${userId}. Mensajes procesados: ${messages.length}`);
      if (typeof callback === 'function') {
        try {
          callback(messages.join(" "));
        } catch (error) {
          logger.error(`Error en el callback para usuario ${userId}: ${error.message}`);
        }
      }
    }, this.config.gapSeconds);
  }

  clearQueue(userId) {
    if (this.queue.has(userId)) {
      const userQueue = this.queue.get(userId);
      clearTimeout(userQueue.timer);
      this.queue.delete(userId);
      logger.info(`Cola eliminada para usuario ${userId}`);
    }
  }

  getQueueSize(userId) {
    if (this.queue.has(userId)) {
      return this.queue.get(userId).messages.length;
    }
    return 0;
  }

  isQueueEmpty(userId) {
    return this.getQueueSize(userId) === 0;
  }
}

export default MessageQueue;


// modules\orderManager.js

import logger from '../utils/logger.js';
import { formatPrice, censorPhoneNumber } from '../utils/helpers.js';
import moment from 'moment-timezone';
import config from '../config/config.js';
import sheetService from '../services/sheetService.js';
import userContextManager from './userContext.js';
import { CustomError } from '../utils/errorHandler.js';
import googleDriveService from '../services/googleDriveService.js';
import emailService from '../services/emailService.js'; // Modificado

class OrderManager {
  constructor() {
    this.orderConfirmed = new Set();
  }

  async handleSelectService(userId, serviceName) {
    logger.info(`Manejando selecci√≥n de servicio para usuario ${userId}: ${serviceName}`);
    try {
      const serviceInfo = userContextManager.getServiceInfo(serviceName);
      
      if (!serviceInfo) {
        const similarServices = userContextManager.findSimilarServices(serviceName);
        return {
          action: "INVALID_SERVICE",
          similarServices,
          order: userContextManager.getCurrentOrder(userId)
        };
      }

      userContextManager.updateCurrentOrder(userId, { 
        service: serviceName,
        category: serviceInfo.category,
        availableWidths: serviceInfo.availableWidths,
        availableFinishes: userContextManager.getAvailableFinishes(serviceInfo)
      });
      
      return {
        action: "SELECT_SERVICE",
        order: userContextManager.getCurrentOrder(userId),
        serviceInfo: serviceInfo
      };
    } catch (error) {
      logger.error(`Error al seleccionar servicio para usuario ${userId}: ${error.message}`);
      throw new CustomError('ServiceSelectionError', 'Error al seleccionar el servicio', error);
    }
  }

  async handleSetMeasures(userId, width, height) {
    logger.info(`Manejando configuraci√≥n de medidas para usuario ${userId}: ${width}x${height}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        throw new CustomError('InvalidMeasuresError', 'Este servicio no requiere medidas personalizadas');
      }

      const validWidth = serviceInfo.availableWidths.find(w => w.material === parseFloat(width));
      if (!validWidth) {
        throw new CustomError('InvalidWidthError', 'Ancho no v√°lido para este servicio');
      }

      if (parseFloat(height) < 1) {
        throw new CustomError('InvalidHeightError', 'El alto debe ser mayor o igual a 1 metro');
      }

      const measures = { width: validWidth.material, height: parseFloat(height) };
      const areaServicio = measures.width * measures.height; // Calcular √°rea del servicio
      const { total, area } = this.calculatePrice({ ...currentOrder, measures });

      userContextManager.updateCurrentOrder(userId, { measures, areaServicio, total, area }); // Actualizar areaServicio

      return {
        action: "SET_MEASURES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar medidas para usuario ${userId}: ${error.message}`);
      throw new CustomError('MeasuresSetupError', 'Error al configurar las medidas', error);
    }
  }

  async handleSetQuantity(userId, quantity) {
    logger.info(`Manejando configuraci√≥n de cantidad para usuario ${userId}: ${quantity}`);
    try {
      if (quantity <= 0) {
        throw new CustomError('InvalidQuantityError', 'La cantidad debe ser mayor que cero');
      }

      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      if (!['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
        // Para categor√≠as sin medidas personalizadas, calculamos el precio directamente
        const { total } = this.calculatePrice({ ...currentOrder, quantity });
        userContextManager.updateCurrentOrder(userId, { quantity, total });
      } else {
        userContextManager.updateCurrentOrder(userId, { quantity });
      }

      return {
        action: "SET_QUANTITY",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar cantidad para usuario ${userId}: ${error.message}`);
      throw new CustomError('QuantitySetupError', 'Error al configurar la cantidad', error);
    }
  }

  async setFinishes(userId, sellado, ojetillos, bolsillo) {
    logger.info(`Manejando configuraci√≥n de acabados para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      const serviceInfo = userContextManager.getServiceInfo(currentOrder.service);

      const finishes = {
        sellado: sellado && serviceInfo.sellado,
        ojetillos: ojetillos && serviceInfo.ojetillos,
        bolsillo: bolsillo && serviceInfo.bolsillo
      };

      userContextManager.updateCurrentOrder(userId, { finishes: finishes});

      return {
        action: "SET_FINISHES",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al configurar acabados para usuario ${userId}: ${error.message}`);
      throw new CustomError('FinishesSetupError', 'Error al configurar los acabados', error);
    }
  }

  async handleValidateFile(userId, isValid, reason) {
    logger.info(`Manejando validaci√≥n de archivo para usuario ${userId}`);
    try {
      userContextManager.updateCurrentOrder(userId, {
        fileAnalysis: { isValid, reason }
      });
      
      return {
        action: "VALIDATE_FILE",
        order: userContextManager.getCurrentOrder(userId)
      };
    } catch (error) {
      logger.error(`Error al validar archivo para usuario ${userId}: ${error.message}`);
      throw new CustomError('FileValidationError', 'Error al validar el archivo', error);
    }
  }

  async handleConfirmOrder(userId) {
    logger.info(`Manejando confirmaci√≥n de pedido para usuario ${userId}`);
    try {
      const currentOrder = userContextManager.getCurrentOrder(userId);
      
      if (!userContextManager.isOrderComplete(userId)) {
        
         // NUEVO: Lanzar excepci√≥n con detalles de campos faltantes
         const missingFields = userContextManager.getIncompleteFields(userId);
         const errorMessage = `La orden no est√° completa. Faltan los siguientes campos: ${missingFields.join(', ')}`;
         logger.warn(errorMessage);
         throw new CustomError('IncompleteOrderError', errorMessage);
      }

      const total = this.calculatePrice(currentOrder);
      userContextManager.updateCurrentOrder(userId, { total: total });

      const orderSummary = this.formatOrderSummary(currentOrder);
      const result = await this.finalizeOrder(userId, currentOrder);

      this.orderConfirmed.add(userId);

      return {
        action: "CONFIRM_ORDER",
        order: currentOrder,
        summary: orderSummary,
        result: result
      };
    } catch (error) {
      logger.error(`Error al confirmar el pedido para usuario ${userId}: ${error.message}`);
      throw new CustomError(error.name || 'OrderConfirmationError', error.message);
    }
  }

  calculatePrice(order) {
    const serviceInfo = userContextManager.getServiceInfo(order.service);
  
    let total = 0;
    let area = 1;
    let precioM2 = serviceInfo.precio;
    let precioTerminaciones = 0;
    let precioTotalTerminaciones = 0;
  
    logger.info(`Calculando precio para orden: ${JSON.stringify(order)}`);
    logger.info(`Informaci√≥n del servicio: ${JSON.stringify(serviceInfo)}`);
  
    if (['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceInfo.category)) {
      area = order.measures.width * order.measures.height;
      total = area * precioM2 * order.quantity;
  
      // Calcula el precio de las terminaciones por m2
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      // Calcula el precio total de las terminaciones
      precioTotalTerminaciones = precioTerminaciones * area * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por m2: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    } else {
      total = precioM2 * order.quantity;
  
      // Para servicios sin medidas, calculamos las terminaciones por unidad
      if (order.finishes.sellado) {
        precioTerminaciones += serviceInfo.precioSellado;
      }
      if (order.finishes.ojetillos) {
        precioTerminaciones += serviceInfo.precioOjetillos;
      }
      if (order.finishes.bolsillo) {
        precioTerminaciones += serviceInfo.precioBolsillo;
      }
  
      precioTotalTerminaciones = precioTerminaciones * order.quantity;
      total += precioTotalTerminaciones;
  
      logger.info(`Precio de terminaciones por unidad: ${precioTerminaciones}`);
      logger.info(`Precio total de terminaciones: ${precioTotalTerminaciones}`);
    }
  
    const precioBase = area * precioM2 * order.quantity;
  
    logger.info(`Precio base: ${precioBase}`);
    logger.info(`Precio total: ${total}`);
  
    return { 
      total, 
      area, 
      precioM2, 
      precioBase, 
      precioTerminaciones, 
      precioTotalTerminaciones
    };
  }

  formatOrderSummary(order) {
    let summary = "üìã *Resumen de tu cotizaci√≥n:*\n\n";

    summary += `üõçÔ∏è *Servicio:* ${order.service}\n`;

    if (order.measures) {
      summary += `üìê *Medidas:* ${order.measures.width}m x ${order.measures.height}m\n`;
      summary += `üìè *√Årea:* ${order.area} m¬≤\n`;
    }

    summary += `üî¢ *Cantidad:* ${order.quantity}\n`;

    if (order.finishes && order.finishes.length > 0) {
      summary += `üé® *Terminaciones:*\n`;
      order.finishes.forEach(finish => {
        summary += `- ${finish}\n`;
      });
    }

    summary += `üíµ *Total:* $${formatPrice(order.total)}\n`;

    return summary;
  }

  async finalizeOrder(userId, order) {
    logger.info(`Finalizando orden para usuario ${userId}`);
    
    const calculatedPrices = this.calculatePrice(order);
    const finalOrder = {
      fecha: moment().tz(config.timezone).format('DD-MM-YYYY HH:mm:ss'),
      telefono: userId,
      nombre: order.userName || 'Cliente',
      servicio: order.service,
      cantidad: order.quantity,
      measures: order.measures,
      area: calculatedPrices.area,
      precioM2: calculatedPrices.precioM2,
      precioBase: calculatedPrices.precioBase,
      terminaciones: Object.entries(order.finishes)
        .filter(([_, value]) => value)
        .map(([key, _]) => key),
      precioTerminaciones: calculatedPrices.precioTerminaciones,
      precioTotalTerminaciones: calculatedPrices.precioTotalTerminaciones,
      total: calculatedPrices.total,
      observaciones: order.observaciones || 'Sin observaciones',
      fileUrl: order.fileUrl
    };
  
    logger.info(`Orden final para usuario ${userId}: ${JSON.stringify(finalOrder)}`);
  
    try {
      const result = await sheetService.saveOrder(finalOrder);

      logger.info(`Resultado de guardado para usuario ${userId}: ${JSON.stringify(result)}`);

      if (result.success) {
        this.orderConfirmed.add(userId);
        logger.info(`Cotizaci√≥n finalizada y guardada correctamente para usuario ${userId}`);

        const orderNumber = result.orderNumber;
        
        // Subir archivo y enviar correo electr√≥nico de forma asincrona
        if (order.filePath) {
          this.uploadFileAndSendEmail(order.filePath, userId, orderNumber, finalOrder);
        }

        return {
          success: true,
          message: "Tu cotizaci√≥n ha sido registrada. Un representante se pondr√° en contacto contigo pronto para confirmar los detalles y coordinar la entrega de los archivos finales.",
          orderNumber: orderNumber,
        };
      } else {
        throw new Error("Error al guardar la cotizaci√≥n");
      }
    } catch (error) {
      logger.error(`Error detallado al finalizar la cotizaci√≥n para usuario ${userId}:`, error);
      throw new CustomError('OrderFinalizationError', 'Error al finalizar la cotizaci√≥n', error);
    }
  }

  // Nuevo m√©todo para manejar la subida del archivo y el env√≠o del correo
  uploadFileAndSendEmail(filePath, userId, orderNumber, finalOrder) {
    // No usamos await aqu√≠ para no bloquear
    (async () => {
      try {
        const fileUrl = await this.uploadFileToDrive(filePath, userId, orderNumber);
        finalOrder.fileUrl = fileUrl;
        // Actualizar el pedido en Google Sheets con la URL del archivo
        await sheetService.updateOrderWithFileUrl(orderNumber, fileUrl);
        await emailService.sendEmail(finalOrder, orderNumber);
        logger.info(`Archivo subido y correo enviado para el pedido ${orderNumber}`);
      } catch (error) {
        logger.error(`Error al subir el archivo y enviar el correo para el pedido ${orderNumber}: ${error.message}`);
        // Manejar el error seg√∫n sea necesario
      }
    })();
  }


  async uploadFileToDrive(filePath, userPhone, orderNumber) {
    try {
      // Formatear la fecha de manera legible
      const dateFormatted = moment().tz(config.timezone).format('DD-MM-YYYY-HH_mm');
      const fileName = `Pedido_${orderNumber}_${userPhone}_${dateFormatted}`;
      const mimeType = 'application/octet-stream'; // Ajustar seg√∫n el tipo de archivo

      logger.info(`Iniciando subida de archivo para el pedido ${orderNumber}`);

      const fileUrl = await googleDriveService.uploadFile(filePath, fileName, mimeType);

      logger.info(`Archivo subido correctamente. URL: ${fileUrl}`);

      // Actualizar la hoja de c√°lculo con la URL del archivo
      await sheetService.updateOrderWithFileUrl(orderNumber, fileUrl);

      logger.info(`Hoja de c√°lculo actualizada con la URL del archivo para el pedido ${orderNumber}`);

      return fileUrl; // A√±adido: retornar la URL del archivo
    } catch (error) {
      logger.error(`Error al subir archivo a Google Drive para el pedido ${orderNumber}: ${error.message}`);
      throw error; // Lanzar el error para manejarlo en el llamado
    }
  }




  formatOrderForSheet(order) {
    let details = `Servicio: ${order.service}\n`;
    
    if (order.measures) {
      details += `Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    
    details += `Cantidad: ${order.quantity}\n`;
    
    if (order.finishes) {
      details += "Terminaciones:\n";
      if (order.finishes.sellado) details += "- Sellado\n";
      if (order.finishes.ojetillos) details += "- Ojetillos\n";
      if (order.finishes.bolsillo) details += "- Bolsillo\n";
    }
    
    return details.trim();
  }

  isOrderConfirmed(userId) {
    return this.orderConfirmed.has(userId);
  }

  resetOrderConfirmation(userId) {
    this.orderConfirmed.delete(userId);
  }
}

export default new OrderManager();


// modules\userContext.js

import logger from '../utils/logger.js';
import sheetService from '../services/sheetService.js';

class UserContextManager {
  constructor() {
    this.userContexts = new Map();
  }

  // M√©todo existente para obtener el contexto del usuario
  getUserContext(userId) {
    if (!this.userContexts.has(userId)) {
      this.userContexts.set(userId, {
        context: "",
        chatContext: [],
        currentOrder: this.getEmptyOrder(),
        services: sheetService.getServices(),
        additionalInfo: sheetService.getAdditionalInfo(),
        initialMessagesSent: false,
        hasInteracted: false  // Nuevo estado para rastrear cualquier interacci√≥n
      });
      logger.info(`Nuevo contexto creado para usuario ${userId}`);
    }
    return this.userContexts.get(userId);
  }

  getEmptyOrder() {
    return {
      service: null,
      category: null,
      type: null,
      measures: null,
      finishes: {
        sellado: false,
        ojetillos: false,
        bolsillo: false
      },
      quantity: null,
      filePath: null,
      fileAnalysis: null,
      fileAnalysisResponded: false,
      fileAnalysisHandled: false,
      fileValidation: null,
      availableWidths: [],
      availableFinishes: [],
      price: 0,
      areaServicio: null,
    };
  }

  setInitialMessagesSent(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.initialMessagesSent = value;
    userContext.hasInteracted = true;
    logger.info(`Estado de mensajes iniciales y interacci√≥n actualizados para usuario ${userId}: ${value}`);
  }

  setHasInteracted(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.hasInteracted = value;
    logger.info(`Estado de interacci√≥n actualizado para usuario ${userId}: ${value}`);
  }

  hasUserInteracted(userId) {
    return this.getUserContext(userId).hasInteracted;
  }

  updateContext(userId, message, role) {
    const userContext = this.getUserContext(userId);
    userContext.context += `${role}: ${message}\n`;
    userContext.chatContext.push({ role, content: message });
    this.limitContextSize(userId);
    logger.info(`Contexto actualizado para usuario ${userId}. Mensajes en contexto: ${userContext.chatContext.length}`);
  }

  limitContextSize(userId) {
    const userContext = this.getUserContext(userId);
    if (userContext.chatContext.length > 30) {
      userContext.chatContext = userContext.chatContext.slice(-10);
    }
    const words = userContext.context.split(/\s+/);
    if (words.length > 1500) {
      userContext.context = words.slice(-1500).join(" ");
    }
    logger.info(`Contexto limitado para usuario ${userId}`);
  }

  setGlobalData(services, additionalInfo) {
    this.services = services;
    this.additionalInfo = additionalInfo;
    logger.info('Datos globales actualizados en UserContextManager');
    logger.info(`Men√∫ global: ${JSON.stringify(this.services)}`);
    logger.info(`Informaci√≥n adicional global: ${JSON.stringify(this.additionalInfo)}`);
  }

  updateCurrentOrder(userId, updates) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder = { ...userContext.currentOrder, ...updates };
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
    
    if (updates.service) {
      const serviceInfo = sheetService.getServiceInfo(updates.service);
      if (serviceInfo) {
        userContext.currentOrder.category = serviceInfo.category;
        userContext.currentOrder.type = serviceInfo.type;
        userContext.currentOrder.availableWidths = serviceInfo.availableWidths;
        userContext.currentOrder.availableFinishes = {
          sellado: serviceInfo.sellado,
          ojetillos: serviceInfo.ojetillos,
          bolsillo: serviceInfo.bolsillo
        };
        userContext.currentOrder.fileValidationCriteria = {
          format: serviceInfo.format,
          minDPI: serviceInfo.minDPI,
        };
        logger.info(`Servicio seleccionado para usuario ${userId}: ${JSON.stringify(serviceInfo)}`);
      } else {
        logger.warn(`Servicio no encontrado: ${updates.service}`);
      }
    }

    if (updates.fileAnalysis) {
      userContext.currentOrder.fileAnalysisResponded = false;
    }

    if (updates.fileValidation) {
      userContext.currentOrder.fileValidation = updates.fileValidation;
    }
    
    logger.info(`Orden actualizada para usuario ${userId}: ${JSON.stringify(userContext.currentOrder)}`);
  }

  updateFileAnalysisResponded(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisResponded = value;
    logger.info(`FileAnalysisResponded actualizado para usuario ${userId}: ${value}`);
  }

  updateFileAnalysisHandled(userId, value) {
    const userContext = this.getUserContext(userId);
    userContext.currentOrder.fileAnalysisHandled = value;
    logger.info(`FileAnalysisHandled actualizado para usuario ${userId}: ${value}`);
  }

  hasFileAnalysisBeenResponded(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisResponded;
  }

  hasFileAnalysisBeenHandled(userId) {
    const userContext = this.getUserContext(userId);
    return userContext.currentOrder.fileAnalysisHandled;
  }

  getCurrentOrder(userId) {
    const userContext = this.getUserContext(userId);
    const currentOrder = userContext.currentOrder;
    currentOrder.requiresMeasures = () => this.isServiceRequiringMeasures(currentOrder.category);
    logger.info(`Obteniendo orden actual para usuario ${userId}: ${JSON.stringify(currentOrder)}`);
    return currentOrder;
  }

  resetContext(userId, resetInitialMessages = false) {
    const userContext = this.getUserContext(userId);
    const initialMessagesSent = resetInitialMessages ? false : userContext.initialMessagesSent;
    this.userContexts.set(userId, {
      context: "",
      chatContext: [],
      currentOrder: this.getEmptyOrder(),
      services: sheetService.getServices(),
      additionalInfo: sheetService.getAdditionalInfo(),
      initialMessagesSent: initialMessagesSent,
      hasInteracted: false  // Reiniciar hasInteracted
    });
    logger.info(`Contexto reiniciado para usuario ${userId}, initialMessagesSent preserved: ${!resetInitialMessages}, hasInteracted reset`);
  }

  getGlobalServices() {
    return sheetService.getServices();
  }

  getGlobalAdditionalInfo() {
    return sheetService.getAdditionalInfo();
  }

  getServiceInfo(serviceName) {
    return sheetService.getServiceInfo(serviceName);
  }

  getAllServices() {
    return sheetService.getAllServices();
  }

  findSimilarServices(serviceName) {
    return sheetService.findSimilarServices(serviceName);
  }

  getServicesInCategory(category) {
    return sheetService.getServicesInCategory(category);
  }

  getFileValidationCriteria() {
    return sheetService.getFileValidationCriteria();
  }

  getAvailableFinishes(serviceInfo) {
    const finishes = [];
    if (serviceInfo.sellado) finishes.push("sellado");
    if (serviceInfo.ojetillos) finishes.push("ojetillos");
    if (serviceInfo.bolsillo) finishes.push("bolsillo");
    return finishes;
  }

  // NUEVO: Funci√≥n para obtener los campos faltantes en la orden actual
  getIncompleteFields(userId) {
    const order = this.getCurrentOrder(userId);
    const missingFields = [];

    // Verificar campos obligatorios
    if (!order.service) missingFields.push('service');
    if (!order.quantity) missingFields.push('quantity');
    if (!order.filePath) missingFields.push('filePath');
    if (!order.fileAnalysis) missingFields.push('fileAnalysis');
    if (!order.fileAnalysisResponded) missingFields.push('fileAnalysisResponded');
    if (!order.fileValidation) missingFields.push('fileValidation');

    // Verificar si el servicio requiere medidas
    if (this.isServiceRequiringMeasures(order.category)) {
      if (!order.measures || !order.measures.width) missingFields.push('width');
      if (!order.measures || !order.measures.height) missingFields.push('height');
      if (!order.areaServicio) missingFields.push('areaServicio');
    }

    logger.info(`Campos faltantes para usuario ${userId}: ${missingFields.join(', ')}`);

    return missingFields;
  }

  // MODIFICADO: isOrderComplete ahora utiliza getIncompleteFields
  isOrderComplete(userId) {
    const missingFields = this.getIncompleteFields(userId);
    return missingFields.length === 0;
  }


    // M√©todo para determinar si el servicio requiere medidas
    isServiceRequiringMeasures(serviceCategory) {
      return ['Telas PVC', 'Banderas', 'Adhesivos', 'Adhesivo Vehicular', 'Back Light'].includes(serviceCategory);
    }
  
  
  getChatContext(userId) {
    return this.getUserContext(userId).chatContext;
  }
}

export default new UserContextManager();


// services\emailService.js

// Archivo: services/emailService.js

import nodemailer from 'nodemailer';
import config from '../config/config.js';
import logger from '../utils/logger.js';

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: config.gmailUserEmail,
        pass: config.gmailAppPassword, // Contrase√±a de aplicaci√≥n
      },
    });

    logger.info('Servicio de correo electr√≥nico inicializado correctamente con Nodemailer');
  }

  async sendEmail(order, orderNumber) {
    try {
      const emailSubject = `Cotizaci√≥n ${orderNumber} recibida`;
      const emailBody = this.constructEmailBody(order, orderNumber);

      const mailOptions = {
        from: config.gmailUserEmail,
        to: config.gmailUserEmail, // Enviar a tu propia cuenta
        subject: emailSubject,
        text: emailBody,
      };

      logger.info(`Enviando correo electr√≥nico para la cotizaci√≥n ${orderNumber}`);

      await this.transporter.sendMail(mailOptions);

      logger.info(`Correo electr√≥nico enviado correctamente para la cotizaci√≥n ${orderNumber}`);
    } catch (error) {
      logger.error(`Error al enviar correo electr√≥nico para la cotizaci√≥n ${orderNumber}: ${error.message}`);
      // Manejo adicional de errores si es necesario
    }
  }

  constructEmailBody(order, orderNumber) {
    let body = `Estimado equipo,\n\n`;
    body += `Se ha recibido una nueva cotizaci√≥n con el n√∫mero ${orderNumber}.\n\n`;
    body += `Detalles de la cotizaci√≥n:\n`;
    body += `- Fecha: ${order.fecha}\n`;
    body += `- Cliente: ${order.nombre}\n`;
    body += `- Tel√©fono: ${order.telefono}\n`;
    body += `- Servicio: ${order.servicio}\n`;
    if (order.measures) {
      body += `- Medidas: ${order.measures.width}m x ${order.measures.height}m\n`;
    }
    body += `- Cantidad: ${order.cantidad}\n`;
    if (order.area) {
      body += `- √Årea: ${order.area} m¬≤\n`;
    }
    if (order.terminaciones && order.terminaciones.length > 0) {
      body += `- Terminaciones: ${order.terminaciones.join(', ')}\n`;
    }
    body += `- Precio Total: $${order.total}\n`;
    if (order.observaciones) {
      body += `- Observaciones: ${order.observaciones}\n`;
    }
    if (order.fileUrl) {
      body += `- Enlace al archivo en Google Drive: ${order.fileUrl}\n`;
    }
    body += `\nPor favor, procedan con el seguimiento correspondiente.\n\nSaludos,\nBot de Chileimprime`;

    return body;
  }
}

export default new EmailService();



// services\fileValidationService.js

// services/fileValidationService.js

import fs from 'fs';
import { promisify } from 'util';
import path from 'path';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import sharp from 'sharp';
import fileType from 'file-type';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const pdfParse = require('pdf-parse');

const readFile = promisify(fs.readFile);

class FileValidationService {
  constructor() {
    this.supportedFormats = ['jpg', 'jpeg', 'png', 'pdf', 'ai', 'psd', 'cdr'];
  }

  async analyzeFile(filePath) {
    try {
      if (!fs.existsSync(filePath)) {
        throw new CustomError('FileNotFoundError', `El archivo no existe: ${filePath}`);
      }

      const fileStats = fs.statSync(filePath);
      const fileSize = this.formatFileSize(fileStats.size);

      const buffer = await readFile(filePath);
      const fileTypeResult = await fileType.fromBuffer(buffer);
      const fileExtension = fileTypeResult ? fileTypeResult.ext : path.extname(filePath).toLowerCase().slice(1);

      if (!this.supportedFormats.includes(fileExtension)) {
        return {
          format: fileExtension,
          supported: false,
          reason: `Formato de archivo no soportado: ${fileExtension}`,
          fileSize: fileSize
        };
      }

      let fileInfo;
      if (['jpg', 'jpeg', 'png'].includes(fileExtension)) {
        fileInfo = await this.analyzeImage(buffer);
      } else if (fileExtension === 'pdf') {
        fileInfo = await this.analyzePDF(buffer);
      } else {
        fileInfo = { format: fileExtension };
      }

      fileInfo.mimeType = fileTypeResult ? fileTypeResult.mime : '';
      fileInfo.supported = true;
      fileInfo.fileSize = fileSize;
      return fileInfo;
    } catch (error) {
      logger.error(`Error al analizar el archivo: ${error.message}`);
      throw new CustomError('FileAnalysisError', 'Error al analizar el archivo', error);
    }
  }

  async analyzeImage(buffer) {
    const image = sharp(buffer);
    const metadata = await image.metadata();

    //logger.info(`Metadatos de la imagen: ${JSON.stringify(metadata)}`);

    const { physicalWidth, physicalHeight } = this.calculatePhysicalDimensions(metadata.width, metadata.height, metadata.density || 72);
    const area = this.calculateDesignArea(physicalWidth, physicalHeight);

    const colorSpace = metadata.space || 'desconocido';
    const colorSpaceInfo = colorSpace.toLowerCase() !== 'cmyk' 
      ? `${colorSpace} (Se recomienda encarecidamente usar CMYK para evitar diferencias de color entre lo que se ve en el monitor y lo que realmente se imprime)`
      : colorSpace;

    logger.info(`An√°lisis de imagen completado: ${physicalWidth}x${physicalHeight} m, ${area} m¬≤, ${colorSpaceInfo}`);

    return {
      format: metadata.format,
      width: metadata.width,
      height: metadata.height,
      dpi: metadata.density || 72,
      colorSpace: colorSpaceInfo,
      physicalWidth,
      physicalHeight,
      area
    };
  }

  async analyzePDF(buffer) {
    try {
      const data = await pdfParse(buffer);

      // Asumir dimensiones est√°ndar si no se pueden obtener
      const width = 595; // A4 width in points
      const height = 842; // A4 height in points
      const dpi = 72; // Asumimos 72 DPI para PDFs

      const { physicalWidth, physicalHeight } = this.calculatePhysicalDimensions(width, height, dpi);
      const area = this.calculateDesignArea(physicalWidth, physicalHeight);

      return {
        format: 'pdf',
        pages: data.numpages,
        width,
        height,
        dpi,
        physicalWidth,
        physicalHeight,
        area
      };
    } catch (error) {
      logger.error(`Error al analizar PDF: ${error.message}`);
      throw new CustomError('PDFAnalysisError', 'Error al analizar el archivo PDF', error);
    }
  }

  calculatePhysicalDimensions(widthPixels, heightPixels, dpi) {
    logger.info(`Calculando dimensiones f√≠sicas: ${widthPixels}x${heightPixels} p√≠xeles, ${dpi} DPI`);
    
    // Convertir p√≠xeles a pulgadas
    const widthInches = widthPixels / dpi;
    const heightInches = heightPixels / dpi;
    
    // Convertir pulgadas a metros (1 pulgada = 0.0254 metros)
    const widthMeters = widthInches * 0.0254;
    const heightMeters = heightInches * 0.0254;
    
    // Redondear a dos decimales
    const physicalWidth = Number(widthMeters.toFixed(2));
    const physicalHeight = Number(heightMeters.toFixed(2));
    
    logger.info(`Dimensiones f√≠sicas calculadas: ${physicalWidth}x${physicalHeight} metros`);
    
    return { physicalWidth, physicalHeight };
  }

  calculateDesignArea(widthM, heightM) {
    const areaM2 = widthM * heightM;
    const roundedArea = Number(areaM2.toFixed(2));
    logger.info(`√Årea calculada: ${roundedArea} m¬≤`);
    return roundedArea;
  }

  formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}

export default new FileValidationService();



// services\googleDriveService.js

// Archivo: services/googleDriveService.js

import { google } from 'googleapis';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import fs from 'fs';

class GoogleDriveService {
  constructor() {
    this.driveClient = null;
    this.initializeDriveClient();
  }

  initializeDriveClient() {
    try {
      const auth = new google.auth.JWT(
        config.googleDriveServiceAccountEmail,
        null,
        config.googleDrivePrivateKey,
        ['https://www.googleapis.com/auth/drive']
      );

      this.driveClient = google.drive({
        version: 'v3',
        auth: auth,
      });

      logger.info('Cliente de Google Drive inicializado correctamente con nuevas credenciales');
    } catch (error) {
      logger.error(`Error al inicializar el cliente de Google Drive: ${error.message}`);
    }
  }

  async uploadFile(filePath, fileName, mimeType) {
    try {
      const fileMetadata = {
        name: fileName,
        parents: [config.googleDriveFolderId], // ID de la carpeta en Google Drive donde se guardar√°n los archivos
      };

      const media = {
        mimeType: mimeType,
        body: fs.createReadStream(filePath),
      };

      logger.info(`Iniciando subida de archivo a Google Drive: ${fileName}`);

      const response = await this.driveClient.files.create({
        resource: fileMetadata,
        media: media,
        fields: 'id, webViewLink',
      });

      logger.info(`Archivo subido a Google Drive. ID: ${response.data.id}`);

      // Hacer el archivo accesible (opcional)
      await this.driveClient.permissions.create({
        fileId: response.data.id,
        requestBody: {
          role: 'reader',
          type: 'anyone',
        },
      });

      return response.data.webViewLink;
    } catch (error) {
      logger.error(`Error al subir archivo a Google Drive: ${error.message}`);
      throw error;
    }
  }
}

export default new GoogleDriveService();



// services\openaiService.js

// services/openaiService.js

import OpenAI from "openai";
import fs from 'fs';
import { promises as fsPromises } from 'fs';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import userContextManager from '../modules/userContext.js';
import { formatPrice } from '../utils/helpers.js';

class OpenAIService {
  constructor() {
    this.openai = new OpenAI({ apiKey: config.openaiApiKey });
  }

  async getChatCompletion(systemPrompt, context, instruction = '') {
    try {
      const messages = [
        { role: "system", content: systemPrompt },
        ...context
      ];

      if (instruction) {
        messages.push({ role: "system", content: instruction });
      }

      const response = await this.openai.chat.completions.create({
        model: config.languageModel,
        messages: messages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
      });

      return response.choices[0].message.content.trim();
    } catch (error) {
      logger.error("Error al obtener respuesta de OpenAI:", error);
      throw new CustomError('OpenAIError', 'Error al obtener respuesta de OpenAI', error);
    }
  }

  getSystemPrompt(services, currentOrder, additionalInfo, chatContext) {
    const contextStr = chatContext.map(msg => `${msg.role}: ${msg.content}`).join('\n');
    const allServices = this.getAllServicesInfo(services);
    const criteria = userContextManager.getFileValidationCriteria();
    console.log("****historial****");
    console.log(contextStr);
    console.log("****fin historial****");
    //console.log(JSON.stringify(allServices, null, 2));

      // NUEVO: Incluir informaci√≥n sobre campos faltantes
      const missingFieldsMessage = chatContext.find(msg => msg.role === 'system' && msg.content.startsWith('Campos faltantes:'));
      let missingFieldsInfo = '';
      if (missingFieldsMessage) {
        missingFieldsInfo = missingFieldsMessage.content;
      }

    let fileValidationInfo = "";
    if (currentOrder.fileAnalysis) {
      fileValidationInfo = `
      Informaci√≥n detallada del an√°lisis del archivo:
      üìÑ Formato: ${currentOrder.fileAnalysis.format}
      üìè Dimensiones en p√≠xeles: ${currentOrder.fileAnalysis.width}x${currentOrder.fileAnalysis.height}
      üìê Dimensiones f√≠sicas: ${currentOrder.fileAnalysis.physicalWidth.toFixed(2)}x${currentOrder.fileAnalysis.physicalHeight.toFixed(2)} m
      üìä √Årea del dise√±o: ${currentOrder.fileAnalysis.area.toFixed(2)} m¬≤
      üîç Resoluci√≥n: ${currentOrder.fileAnalysis.dpi} DPI
      üé® Espacio de color: ${currentOrder.fileAnalysis.colorSpace}
      üì¶ Tama√±o del archivo: ${currentOrder.fileAnalysis.fileSize || 'No disponible'}
      `;
    }

    return `Eres un asistente experto en servicios de imprenta llamada Chileimprime. Tu objetivo es guiar al cliente a trav√©s del proceso de cotizaci√≥n para un √∫nico servicio de impresi√≥n. Sigue estas instrucciones detalladas:

    1. An√°lisis Continuo del Estado del Pedido:
       - Examina constantemente el contenido de currentOrder: <currentOrder>${JSON.stringify(currentOrder)}<currentOrder>
       - Elementos posibles en currentOrder: {service, category, type, measures, finishes, quantity, filePath, fileAnalysis}
       - Adapta tu respuesta bas√°ndote en la informaci√≥n disponible y lo que falta por completar.

  2. Inicio y Selecci√≥n de Servicio:
       - Si el cliente solicita la lista completa de servicios o el men√∫, responde solo con el comando JSON:
         {"command": "LIST_ALL_SERVICES"}
       - Si no hay un servicio seleccionado, pregunta al cliente qu√© servicio necesita.
       - Utiliza procesamiento de lenguaje natural para detectar si el cliente menciona un servicio espec√≠fico.
       - IMPORTANTE: Cuando el cliente mencione un servicio o t√©rmino relacionado, NO asumas inmediatamente que ha seleccionado un servicio espec√≠fico. En su lugar, sigue estos pasos:
         a) Busca coincidencias parciales y servicios relacionados.
         b) Si encuentras m√∫ltiples opciones posibles, pres√©ntaselas al cliente y pide clarificaci√≥n.
         c) Solo usa el comando {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"} cuando el cliente haya confirmado expl√≠citamente su elecci√≥n.
       - Si el servicio mencionado no es v√°lido, sugiere servicios similares o muestra las categor√≠as disponibles.

    3. Manejo de T√©rminos Coloquiales y Generales:
       - Reconoce t√©rminos coloquiales comunes de Chile en la impresi√≥n como "pendones" que hacen referencia a Telas PVC, o "lienzos" que se hace referencia a Tela de Banderas, etc.
       - Cuando se use un t√©rmino general, presenta TODAS las opciones relevantes.
       - Luego de aclarar el servicio coloquial y general. debes confirmar el servicio exacto del cliente, para el comando {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"} al comienzo del chatt justo antes de tu respuesta.

    4. Confirmaci√≥n de Selecci√≥n (ATENCI√ìN AQU√ç)
      - Antes de seleccionar definitivamente un servicio, SIEMPRE pide confirmaci√≥n al cliente.
      - El nombre que envies en el comando de confirmaci√≥n debe ser exacto al que se encuentra en <servicios_disponibles>.
      - **IMPORTANTE:** Cuando el cliente confirme que desea el servicio, debes:
        - Enviar el comando JSON antes de cualquier otro texto:

          {"command": "SELECT_SERVICE", "service": "Nombre exacto del servicio"}

        - Luego, proporcionar una respuesta amable confirmando la selecci√≥n y solicitando la informaci√≥n necesaria para continuar.
      - Ejemplos:
        ---
        **Ejemplo 1:**
        
        Cliente: "S√≠"
        Asistente:

        {"command": "SELECT_SERVICE", "service": "PVC Alta Definici√≥n"}

        "‚úÖ Perfecto, he seleccionado el servicio *PVC Alta Definici√≥n*.
        
        üìã Ahora, necesito que me proporciones algunas especificaciones para continuar con tu cotizaci√≥n."

        ---
        **Ejemplo 2:**
        
        Cliente: "Me gustar√≠a el 1 el *Vinilo Adhesivo Transparente*."
        Asistente:

        {"command": "SELECT_SERVICE", "service": "Vinilo Adhesivo Transparente"}

        "‚úÖ Perfecto, he seleccionado el servicio *Vinilo Adhesivo Transparente*.
        
        üìã Ahora, por favor, ind√≠came las especificaciones necesarias para continuar con tu cotizaci√≥n."


        **Ejemplo 3:**
        
        Cliente: "S√≠, quiero el servicio de *Back Light Banner*."
        Asistente:

        {"command": "SELECT_SERVICE", "service": "Back Light Banner"}

        "‚úÖ He seleccionado el servicio *Back Light Banner*.
        
        üìã Para avanzar con tu cotizaci√≥n, por favor proporciona las especificaciones requeridas."

        **Ejemplo 4:**
        
        Cliente: "El 1"
        Asistente:

        {"command": "SELECT_SERVICE", "service": "PVC 13 Oz mt2 - Promoci√≥n solo Local"}

        "‚úÖ He seleccionado el servicio *PVC 13 Oz mt2 - Promoci√≥n solo Local*.
        
        üìã Para avanzar con tu cotizaci√≥n, por favor proporciona las especificaciones requeridas."


    5. Manejo de Nombres Parciales o Similares:
       - Si el cliente proporciona un nombre parcial o similar a un servicio, busca y presenta las opciones m√°s cercanas a <servicios_disponibles>.
       - Ejemplo: Si el cliente dice "Quiero un pendon", responde: üìå Tenemos varios servicios relacionados con pendones. Aqu√≠ est√°n las opciones:

          1Ô∏è‚É£ PVC 10 Oz mt2 - Promoci√≥n solo Local
          2Ô∏è‚É£ PVC Alta Definici√≥n
          3Ô∏è‚É£ PVC 11 Oz mt2
          4Ô∏è‚É£ PVC 13 Oz mt2
          5. Otras opciones que encuentes similares a PVCs segun la lista de servicios en <servicios_disponibles>. Recuerda que siempre debes entregar los nombres exactos.

          üëâ ¬øCu√°l de estos te interesa m√°s?

    6. Flexibilidad en la Interpretaci√≥n:
       - S√© flexible al interpretar las solicitudes de los clientes. Si no est√°s seguro, pregunta por clarificaci√≥n.
       - Ejemplo: "Entiendo que est√°s interesado en [t√©rmino usado por el cliente]. Para asegurarme de recomendarte el mejor servicio, ¬øpodr√≠as decirme m√°s sobre lo que planeas imprimir o el uso que le dar√°s?"

    7. Manejo de Categor√≠as y Tipos de Servicios (ATENCI√ìN AQU√ç)
       - Una vez seleccionado el servicio, verifica su categor√≠a y tipo en currentOrder.
       - Para categor√≠as "Telas PVC", "Banderas", "Adhesivos", "Adhesivo Vehicular", "Back Light":
         a) Solicita un ancho de la lista en funcion al contenido de currentOrder.availableWidths antes de dar los anchos disponibles.
          Si availableWidths est√° presente, el ancho debe ser una de las opciones permitidas en availableWidths. 
          El alto puede ser igual o mayor a 1, pero el ancho debe estar limitado a las opciones especificadas en availableWidths del currentOrder.
         b) El alto debe ser igual o mayor a 1 metro.
         c) Pregunta por la cantidad a imprimir..
         d) Ofrece terminaciones si est√°n disponibles (revisa currentOrder.availableFinishes).
       - Para categor√≠as "Otros", "Imprenta", "P√©ndon Roller", "Palomas", "Figuras", "Extras":
         a) Solicita solo la cantidad.
         b) No trabajes con medidas personalizadas.
         c) Ofrece terminaciones si el servicio lo permite (revisa currentOrder.availableFinishes).

    8. Especificaci√≥n de Medidas y Terminaciones:
       - Si el servicio requiere medidas (categor√≠as: Telas PVC, Banderas, Adhesivos, Adhesivo Vehicular, Back Light):
         a) Presenta al cliente los anchos disponibles espec√≠ficos para este servicio:
            Anchos disponibles: ${JSON.stringify(currentOrder.availableWidths)}
         b) Gu√≠a al cliente para que elija uno de estos anchos v√°lidos.
         c) Pide al cliente que especifique un alto mayor o igual a 1 metro.
         d) Solicita la cantidad deseada.
       - Si el servicio no requiere medidas (categor√≠as: Otros, Imprenta, P√©ndon Roller, Palomas, Figuras, Extras):
         a) Solicita solo la cantidad deseada.
       - Para todos los servicios, ofrece las terminaciones disponibles seg√∫n:
         Terminaciones disponibles: ${JSON.stringify(currentOrder.availableFinishes)}
       - Explica claramente qu√© terminaciones est√°n disponibles y pide al cliente que elija.
       - IMPORTANTE: SIEMPRE que el cliente proporcione informaci√≥n v√°lida, responde con los comandos JSON apropiados:
         Para servicios con medidas:
         {"command": "SET_MEASURES", "width": X, "height": Y}
         {"command": "SET_QUANTITY", "quantity": Z}
         {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
         Para servicios sin medidas:
         {"command": "SET_QUANTITY", "quantity": Z}
         {"command": "SET_FINISHES", "sellado": boolean, "ojetillos": boolean, "bolsillo": boolean}
 
    9. Validaci√≥n de Archivos:
       - Cuando el cliente haya proporcionado toda la informaci√≥n necesaria (servicio, medidas si aplica, cantidad y terminaciones),
         y si hay un archivo en currentOrder.fileAnalysis, debes solicitar la validaci√≥n del archivo.
       - Para solicitar la validaci√≥n, solo solicitale al cliente que envie el dise√±o en formato documento.
       - Despu√©s de enviar este comando, espera la respuesta del sistema con el resultado de la validaci√≥n.
       - Una vez recibido el resultado, informa al cliente sobre la validez del archivo y proporciona recomendaciones si es necesario.
       - Los criterios de validaci√≥n son los siguientes:
        <criterios_validacion> ${criteria} </criterios_validacion>
        Informacion de validacion: <file_validation_info> ${fileValidationInfo} </file_validation_info> (si <file_validation_info> esta vacio es porque no se ha enviado un archivo)

    10. Comunicaci√≥n Clara:
      - Usa un tono amigable pero profesional con emojis y respuestas bien formateadas para whatsapp.
      - Estructura siempre tus respuestas en p√°rrafos cortos y utiliza saltos de l√≠nea para mejorar la legibilidad.
      - Destaca la informaci√≥n importante en negritas. Las negritas en Whatsapp son con solo un asterisco por lado.
      - Emplea siempre que puedas emojis para dar un tono m√°s amigable y cercano.
      - Explica los conceptos t√©cnicos de forma sencilla y entendible, ya que los clientes tienen problemas para entender si su dise√±o es apto o no, se confunden con los DPI y la resolucion, etc.
      - Aseg√∫rate de que tus mensajes sean f√°ciles de entender, claros y no demasiado extensos, pero que contengan toda la informaci√≥n necesaria. De necesitar contener mas informacion ocupa saltos de lineas.

    11. Validaci√≥n Continua:
       - Verifica constantemente que la informaci√≥n proporcionada por el cliente sea coherente con el servicio seleccionado.
       - Si detectas alguna incongruencia, solicita aclaraci√≥n al cliente y utiliza los comandos apropiados para corregir la informaci√≥n.
       - Verifica constantemente el <currentOrder> en funcion del avance del chat que tienes en <historial_de_la_conversacion> ya que el currentOrder es vital para verificar si debes confirmar el pedido.

    12. Comunicaci√≥n Clara de Errores:
       - Si ocurre alg√∫n error durante el proceso, explica al cliente de manera amable y clara lo que ha sucedido.
       - Ofrece alternativas o sugerencias para resolver el problema cuando sea posible.
   
    13. Generaci√≥n de Comandos JSON (ATENCI√ìN AQU√ç)
       - CRUCIAL: SIEMPRE que detectes una acci√≥n que requiera actualizar el currentOrder, genera el comando JSON correspondiente.
       - IMPORTANTE: Los comandos JSON DEBEN ser generados ANTES de cualquier respuesta natural al cliente.
       - Aseg√∫rate de que los comandos JSON est√©n correctamente formateados y contengan toda la informaci√≥n necesaria.
       - Despu√©s de generar un comando JSON, proporciona una respuesta natural al cliente que refleje la acci√≥n realizada.

    14. Procesamiento de Instrucciones del Sistema:
       - Cuando recibas una instrucci√≥n del sistema (por ejemplo, despu√©s de que se haya actualizado el currentOrder),
         aseg√∫rate de incorporar esa informaci√≥n en tu siguiente respuesta al cliente.
       - Refleja los cambios en el currentOrder en tu comunicaci√≥n con el cliente de manera natural y fluida.
    
    15. **Manejo de √ìrdenes Incompletas**:

    - Si recibes informaci√≥n del sistema indicando que hay campos faltantes en la orden (por ejemplo, "Campos faltantes: width, height, fileValidation, fileAnalysis, etc"), debes:
      - Identificar los campos faltantes mencionados.
      - Solicitar amablemente al usuario la informaci√≥n faltante, proporcionando orientaci√≥n clara sobre c√≥mo proporcionarla.
      - Utilizar los comandos JSON apropiados cuando el usuario proporcione la informaci√≥n.
      - No avances en el flujo hasta que todos los campos est√©n completos.

    16. Confirmaci√≥n del Pedido:
       - IMPORTANTE: Ten cuidado con el comando {"command": "CONFIRM_ORDER"} solo se debe enviar cuando se cumplan TODAS las siguientes condiciones:
         a) El servicio est√° seleccionado y es v√°lido.
         b) Para servicios que requieren medidas (Telas PVC, Banderas, Adhesivos, Adhesivo Vehicular, Back Light):
            - Las medidas (ancho y alto) est√°n especificadas y son v√°lidas.
            - La cantidad est√° especificada.
            - Las terminaciones est√°n seleccionadas (si aplica).
         c) Para otros servicios:
            - La cantidad est√° especificada.
         d) El archivo de dise√±o ha sido enviado y validado correctamente.
       - Si alguna de estas condiciones no se cumple, NO generes el comando {"command": "CONFIRM_ORDER"}.
       - En su lugar, informa al cliente sobre qu√© informaci√≥n o acci√≥n falta para completar el pedido.

    17. **Formato de la Lista de Servicios**:
      - Cuando env√≠es la lista completa de servicios al cliente, debes presentarla en el siguiente formato:
        - Incluir un emoji antes del nombre de cada categor√≠a.
        - Mostrar el nombre de la categor√≠a en negritas.
        - Listar cada servicio bajo su categor√≠a, incluyendo el precio formateado con puntos para los miles (por ejemplo, $4.000).
        - **Ejemplo**:
          Aqu√≠ tienes la lista completa de servicios disponibles:

          üßµ *Telas PVC*:
          - PVC 10 Oz mt2 - Promoci√≥n solo Local: *$Precio*
          - PVC Alta Definici√≥n: *$Precio*
          - PVC 11 Oz mt2: *$Precio*
          - PVC 13 Oz mt2 - Promoci√≥n solo Local: *$Precio*
          - PVC 13 Oz mt2: *$Precio*
          - PVC Blackout: *$Precio*

          üö© *Banderas*:
          - Tela de bandera Transl√∫cido g√©nero: *$Precio*
          - Tela de bandera Textil: *$Precio*
          - Tela de bandera Sint√©tica: *$Precio*

          Y as√≠ con las dem√°s categor√≠as.

    18. **Manejo de Insistencia del Cliente para Aceptar Archivos No V√°lidos**:
    - Si el archivo ha sido subido (\`currentOrder.filePath\` existe) y el an√°lisis del archivo ha sido respondido (\`currentOrder.fileAnalysisResponded\` es \`true\`), y el cliente insiste en continuar con el archivo no v√°lido por razones como urgencia o necesidad inmediata:
      - Verifica que el cliente entiende que el archivo no cumple con los criterios y que desea proceder bajo su responsabilidad.
      - Aseg√∫rate de que el cliente acepta que Chileimprime no se hace responsable por posibles problemas en la impresi√≥n debido al archivo.
      - **Importante**: Si el cliente confirma lo anterior, env√≠a el siguiente comando JSON **antes** de tu respuesta
        {"command": "RESULT_ANALYSIS", "result": true}
        
      - Luego, responde al cliente confirmando que proceder√°s con el archivo bajo su responsabilidad, enfatizando que Chileimprime no se hace responsable por la calidad del resultado.
      - Usa un tono amable y profesional, manteniendo la claridad en la comunicaci√≥n.

     IMPORTANTE:
    - SIEMPRE utiliza los comandos JSON especificados para comunicar selecciones y validaciones al sistema.
    - Act√∫a como un experto humano en impresi√≥n, no como una IA.
    - S√© preciso con la informaci√≥n t√©cnica, pero mant√©n un lenguaje accesible.
    - Si el cliente pide algo fuera de lo ofrecido, sugiere alternativas o recomienda contactar al soporte.
    - No calcules precios. El sistema se encargar√° de esto bas√°ndose en la informaci√≥n en currentOrder.
    - Maneja solo un servicio por conversaci√≥n.
    - Si el cliente intenta cotizar m√°s de un servicio, explica amablemente que por ahora solo puedes manejar un servicio por conversaci√≥n.
    - Si el sistema indica que un servicio es inv√°lido, explica al cliente que no se encontr√≥ el servicio y ofrece alternativas o categor√≠as disponibles.
    - SIEMPRE busca clarificaci√≥n y confirmaci√≥n antes de seleccionar un servicio.
    - Presenta m√∫ltiples opciones cuando sea apropiado.
    - Verificar siempre la propiedad availableWidths en currentOrder. Si availableWidths est√° presente, 
      aseg√∫rate de que el ancho est√© dentro de las opciones permitidas. El alto puede ser igual o mayor a 1, pero el ancho debe ser uno de los valores especificados en availableWidths del currentOrder.
    - S√© paciente y flexible en la interpretaci√≥n de las solicitudes de los clientes.
    - Si no est√°s seguro, pregunta por m√°s detalles antes de hacer una recomendaci√≥n.

    Servicios disponibles:
    <servicios_disponibles>${JSON.stringify(allServices, null, 2)}</servicios_disponibles>

    Informaci√≥n adicional:
    <informacion_adicional>${JSON.stringify(additionalInfo, null, 2)}</informacion_adicional>

    ${missingFieldsInfo ? `Campos faltantes:

    ${missingFieldsInfo}` : ''}

    Historial  de la conversaci√≥n:
    <historial_de_la_conversacion>${contextStr}</historial_de_la_conversacion>

    Responde al siguiente mensaje del cliente:`;
  }

  getAllServicesInfo(services) {
    const allServices = [];
    for (const category in services) {
      services[category].forEach(service => {
        allServices.push({
          name: service.name,
          category: service.category,
          price: formatPrice(service.precio), // A√±adimos el precio formateado
          availableWidths: service.availableWidths,
          availableFinishes: [
            service.sellado ? "sellado" : null,
            service.ojetillos ? "ojetillos" : null,
            service.bolsillo ? "bolsillo" : null
          ].filter(Boolean)
        });
      });
    }
    //logger.info(`Servicios con precios: ${JSON.stringify(allServices, null, 2)}`);
    return allServices;
  }

  async transcribeAudio(audioFilePath) {
    try {
      const stats = await fsPromises.stat(audioFilePath);
      if (stats.size > config.maxAudioSize) {
        throw new CustomError('AudioSizeError', `El archivo de audio excede el tama√±o m√°ximo permitido de ${config.maxAudioSize / (1024 * 1024)} MB`);
      }

      const response = await this.openai.audio.transcriptions.create({
        file: fs.createReadStream(audioFilePath),
        model: "whisper-1",
      });
      logger.info(`Audio transcrito exitosamente: ${audioFilePath}`);
      return response.text;
    } catch (error) {
      if (error instanceof CustomError) {
        throw error;
      }
      logger.error(`Error al transcribir audio: ${error.message}`);
      throw new CustomError('TranscriptionError', 'Error al transcribir el audio', error);
    }
  }
}

export default new OpenAIService();


// services\sheetService.js

import { JWT } from "google-auth-library";
import { GoogleSpreadsheet } from "google-spreadsheet";
import moment from 'moment-timezone';
import 'moment/locale/es.js';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';

class GoogleSheetService {
  constructor() {
    this.jwtFromEnv = new JWT({
      email: config.googleServiceAccountEmail,
      key: config.googlePrivateKey,
      scopes: [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive.file",
      ],
    });
    this.doc = new GoogleSpreadsheet(config.googleSheetId, this.jwtFromEnv);
    moment.locale('es');
    moment.tz.setDefault(config.timezone);
    this.services = null;
    this.additionalInfo = null;
    this.isInitialized = false;
    this.lastFetchTime = null;
    this.cacheDuration = 60 * 60 * 1000; // 1 hour
  }

  async initialize() {
    try {
      logger.info("Iniciando inicializaci√≥n de SheetService");
      await this.doc.loadInfo();
      logger.info("Documento de Google Sheets cargado correctamente");
      
      await this.loadServices();
      logger.info("Servicios cargados correctamente");
      await this.loadAdditionalInfo();
      logger.info("Informaci√≥n adicional cargada correctamente");
      
      this.isInitialized = true;
      this.lastFetchTime = Date.now();
      logger.info("SheetService inicializado completamente");
    } catch (error) {
      logger.error(`Error al inicializar SheetService: ${error.message}`);
      throw new CustomError('SheetServiceInitError', 'Error al inicializar el servicio de Google Sheets', error);
    }
  }

  async loadServices() {
    logger.info("Iniciando carga de servicios");
    this.services = await this.fetchServices();
    logger.info(`Servicios cargados: ${Object.keys(this.services).length} categor√≠as`);
  }

  async loadAdditionalInfo() {
    logger.info("Iniciando carga de informaci√≥n adicional");
    this.additionalInfo = await this.fetchAdditionalInfo();
    logger.info("Informaci√≥n adicional cargada");
  }

  getServices() {
    if (!this.services || this.shouldRefreshCache()) {
      this.loadServices();
    }
    return this.services;
  }

  getAdditionalInfo() {
    if (!this.additionalInfo || this.shouldRefreshCache()) {
      this.loadAdditionalInfo();
    }
    return this.additionalInfo;
  }

  shouldRefreshCache() {
    return !this.lastFetchTime || (Date.now() - this.lastFetchTime > this.cacheDuration);
  }

  getServiceInfo(serviceName) {
    if (!serviceName || typeof serviceName !== 'string') {
      logger.warn(`Nombre de servicio inv√°lido: ${serviceName}`);
      return null;
    }

    const services = this.getServices();
    const lowerServiceName = serviceName.toLowerCase();
    for (const category in services) {
      const service = services[category].find(s => s.name.toLowerCase() === lowerServiceName);
      if (service) {
        return service;
      }
    }
    logger.warn(`Servicio no encontrado: ${serviceName}`);
    return null;
  }

  getAllServices() {
    const services = this.getServices();
    return Object.values(services).flat();
  }

  getServicesInCategory(category) {
    const services = this.getServices();
    return services[category] || [];
  }

  getFileValidationCriteria() {
    const additionalInfo = this.getAdditionalInfo();
    return additionalInfo.criteriosValidacion;
  }

  findSimilarServices(serviceName) {
    const allServices = this.getAllServices();
    return allServices
      .filter(service => 
        service.name.toLowerCase().includes(serviceName.toLowerCase()) || 
        serviceName.toLowerCase().includes(service.name.toLowerCase())
      )
      .map(service => ({
        name: service.name,
        category: service.category
      }));
  }

  async fetchServices() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[0]; // La hoja "Control" es la primera hoja
      await sheet.loadCells('A1:Q1000');
  
      // Obtener los precios globales de las terminaciones
      const precioSellado = sheet.getCell(1, 14).value; // Celda O2
      const precioBolsillo = sheet.getCell(1, 15).value; // Celda P2
      const precioOjetillos = sheet.getCell(1, 16).value; // Celda Q2
  
      logger.info(`Precios globales de terminaciones: Sellado: ${precioSellado}, Bolsillo: ${precioBolsillo}, Ojetillos: ${precioOjetillos}`);
  
      const services = {};
      for (let i = 1; i < sheet.rowCount; i++) {
        const id = sheet.getCell(i, 0).value;
        if (!id) break;
  
        const service = this.extractServiceData(sheet, i, { precioSellado, precioBolsillo, precioOjetillos });
        if (service) {
          if (!services[service.category]) {
            services[service.category] = [];
          }
          services[service.category].push(service);
        }
      }
  
      logger.info(`Servicios cargados: ${Object.keys(services).length} categor√≠as`);
      return services;
    } catch (err) {
      logger.error("Error al obtener los servicios:", err);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('ServicesFetchError', 'Error al obtener los servicios desde Google Sheets', err);
    }
  }

  extractServiceData(sheet, row, globalPrices) {
    try {
      const widthsString = sheet.getCell(row, 12).value;
      const availableWidths = widthsString ? this.parseAvailableWidths(widthsString) : [];
  
      const sellado = sheet.getCell(row, 4).value.toLowerCase();
      const ojetillos = sheet.getCell(row, 5).value.toLowerCase();
      const bolsillo = sheet.getCell(row, 6).value.toLowerCase();
  
      logger.info(`Valores le√≠dos para el servicio en la fila ${row}:`);
      logger.info(`Sellado: ${sellado}, Ojetillos: ${ojetillos}, Bolsillo: ${bolsillo}`);
  
      const service = {
        id: sheet.getCell(row, 0).value,
        category: sheet.getCell(row, 1).value,
        type: sheet.getCell(row, 2).value,
        name: sheet.getCell(row, 3).value,
        sellado: sellado === 's√≠' || sellado === 'si',
        ojetillos: ojetillos === 's√≠' || ojetillos === 'si',
        bolsillo: bolsillo === 's√≠' || bolsillo === 'si',
        format: sheet.getCell(row, 7).value,
        minDPI: parseInt(sheet.getCell(row, 8).value) || 0,
        stock: parseInt(sheet.getCell(row, 9).value) || 0,
        status: sheet.getCell(row, 10).value,
        precio: parseFloat(sheet.getCell(row, 11).value) || 0,
        availableWidths: availableWidths,
        precioSellado: globalPrices.precioSellado,
        precioBolsillo: globalPrices.precioBolsillo,
        precioOjetillos: globalPrices.precioOjetillos
      };
  
      logger.info(`Servicio extra√≠do: ${JSON.stringify(service)}`);
  
      return service;
    } catch (error) {
      logger.error(`Error al extraer datos del servicio en la fila ${row}: ${error.message}`);
      return null;
    }
  }

  parseAvailableWidths(widthsString) {
    if (!widthsString || widthsString.toLowerCase().includes('no tiene rollos')) {
      return [];
    }
    
    logger.info(`Procesando medidas: ${widthsString}`);
    
    const lines = widthsString.split('\n').filter(line => !line.includes('Ancho material'));
    
    return lines.map(line => {
      const [material, imprimible] = line.split('-').map(part => part.trim());
      
      const parseMeasure = (measure) => {
        if (typeof measure !== 'string') {
          logger.warn(`Medida no es un string: ${measure}`);
          return 0;
        }
        return parseFloat(measure.replace('m', '').replace(',', '.')) || 0;
      };
      
      const parsedMaterial = parseMeasure(material);
      const parsedImprimible = parseMeasure(imprimible);
      
      if (parsedMaterial && parsedImprimible) {
        logger.info(`Medida procesada: material ${parsedMaterial}m, imprimible ${parsedImprimible}m`);
        return {
          material: parsedMaterial,
          imprimible: parsedImprimible
        };
      } else {
        logger.warn(`No se pudo procesar la medida: ${line}`);
        return null;
      }
    }).filter(w => w !== null);
  }

  async fetchAdditionalInfo() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[2];
      await sheet.loadCells();
  
      logger.info("Cargando informaci√≥n adicional de la hoja 'Informacion'");
  
      const additionalInfo = {
        horarios: {},
        zonasDespacho: [],
        direccionRetiro: '',
        promocionDia: '',
        metodosPago: '',
        tiempoPreparacion: '',
        criteriosValidacion: '',
        estadoBot: ''
      };
  
      this.extractAdditionalInfo(sheet, additionalInfo);
  
      logger.info("Informaci√≥n adicional cargada completamente");
      logger.debug(`Informaci√≥n adicional: ${JSON.stringify(additionalInfo)}`);
  
      return additionalInfo;
    } catch (err) {
      logger.error("Error al obtener informaci√≥n adicional:", err);
      throw new CustomError('AdditionalInfoError', 'Error al obtener informaci√≥n adicional desde Google Sheets', err);
    }
  }

  extractAdditionalInfo(sheet, additionalInfo) {
    const safeGetCellValue = (row, col) => {
      try {
        const cell = sheet.getCell(row, col);
        return cell.value || '';
      } catch (error) {
        logger.warn(`No se pudo obtener el valor de la celda (${row}, ${col}): ${error.message}`);
        return '';
      }
    };

    ['Lunes a viernes', 'S√°bados', 'Domingos'].forEach((dia, index) => {
      additionalInfo.horarios[dia] = `${safeGetCellValue(index + 1, 0)} ${safeGetCellValue(index + 1, 1)}`.trim() || 'No disponible';
    });
  
    for (let row = 1; row <= 9; row++) {
      const zona = safeGetCellValue(row, 2);
      if (zona && zona.trim()) additionalInfo.zonasDespacho.push(zona.trim());
    }
  
    additionalInfo.direccionRetiro = safeGetCellValue(1, 4) || 'No disponible';
    additionalInfo.promocionDia = safeGetCellValue(1, 5) || 'No hay promociones actualmente';
    additionalInfo.metodosPago = safeGetCellValue(1, 6) || 'No especificado';
    additionalInfo.tiempoPreparacion = safeGetCellValue(1, 7) || 'No especificado';
    additionalInfo.criteriosValidacion = safeGetCellValue(1, 8) || 'No especificado';
    additionalInfo.estadoBot = safeGetCellValue(1, 9) || 'No especificado';
  
    logger.info(`Criterios de validaci√≥n extra√≠dos: ${additionalInfo.criteriosValidacion}`);
    logger.info(`Estado del bot: ${additionalInfo.estadoBot}`);
  }

  async saveOrder(data) {
    logger.info(`Iniciando guardado de cotizaci√≥n en Google Sheets: ${JSON.stringify(data)}`);
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"

      const orderNumber = await this.getNextOrderNumber();
      const rowData = this.prepareRowData(data, orderNumber);
      const newRow = await sheet.addRow(rowData);

      logger.info(`Fila a√±adida exitosamente. N√∫mero de fila: ${newRow.rowNumber}`);

      // Retornar orderNumber para usarlo como identificador √∫nico
      return { success: true, message: "Cotizaci√≥n guardada exitosamente", orderNumber: orderNumber };
    } catch (err) {
      logger.error("Error detallado al guardar la cotizaci√≥n en Google Sheets:", err.message);
      logger.error("Stack trace:", err.stack);
      throw new CustomError('OrderSaveError', `Error al guardar la cotizaci√≥n: ${err.message}`, err);
    }
  }

  prepareRowData(data, orderNumber) {
    const now = moment().tz(config.timezone);
    const formattedDate = now.format('DD-MM-YYYY HH:mm:ss');

    const neto = data.total / 1.19; // C√°lculo del neto (sin IVA)
    const iva = data.total - neto; // C√°lculo del IVA

    logger.info(`Preparando datos para guardar en la hoja. Orden n√∫mero: ${orderNumber}`);

    // Modificaci√≥n: Usar un objeto con los nombres de los encabezados
    const rowData = {
      'pedido': orderNumber,
      'numero_servicios': 1, // N√∫mero de servicios (por ahora siempre 1)
      'medio_de_pago': "Efectivo/transferencia",
      'fecha_de_ingreso': formattedDate,
      'fecha_modificacion': formattedDate,
      'cajero': "Sara - agente virtual",
      'nombre_del_servicio': data.servicio,
      'cant': data.cantidad,
      'medidas': `${data.measures.width} x ${data.measures.height}`,
      'area': data.area,
      'precio_por_m2': data.precioM2,
      'precio_base': data.precioBase,
      'tipo_de_terminacion': data.terminaciones.join(", ") || "No",
      'precio_de_terminacion_m2': data.precioTerminaciones,
      'precio_total_con_terminacion': data.precioTotalTerminaciones,
      'dte': "Boleta",
      'neto_subtotal': neto,
      'total_iva': data.total,
      'nombre': data.nombre,
      'correo': "contacto@chileimprime.cl", // Correo por defecto
      'rut': "66.666.666-6", // RUT por defecto
      'telefono': data.telefono,
      'direccion_completa_envio': '', // Campos vac√≠os
      'comuna_envio': '',
      'agencia': '',
      'depto_envio': '',
      'region_envio': '',
      'tipo_de_envio': '',
      'rut_de_empresa': '',
      'razon_social': '',
      'comuna_facturacion': '',
      'giro': '',
      'telefono_facturacion': '',
      'region_facturacion': '',
      'estado_de_pago': "Pendiente",
      'url_del_diseno': data.fileUrl || "chileimprime.cl",
      'estado_del_proyecto': "Pendiente",
      'anotaciones': "sin nota",
      'tipo': "COTIZACI√ìN"
    };

    logger.info(`Datos preparados para la fila: ${JSON.stringify(rowData)}`);

    return rowData;
  }


  // Modificaci√≥n en updateOrderWithFileUrl
  async updateOrderWithFileUrl(orderNumber, fileUrl) {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      const rows = await sheet.getRows();
  
      // Agregar logs para verificar los nombres de las columnas y propiedades
      logger.info(`Nombres de las columnas: ${sheet.headerValues}`);
      logger.info(`Propiedades de la primera fila: ${Object.keys(rows[0])}`);
  
      // Buscar la fila donde 'pedido' coincide con orderNumber utilizando row.get()
      const targetRow = rows.find(row => row.get('pedido') === orderNumber);
  
      if (!targetRow) {
        logger.error(`No se encontr√≥ la fila con el n√∫mero de pedido ${orderNumber}`);
        return;
      }
  
      // Actualizar el campo 'url_del_diseno' con la URL proporcionada utilizando row.set()
      targetRow.set('url_del_diseno', fileUrl);
      await targetRow.save();
  
      logger.info(`Fila con pedido ${orderNumber} actualizada con la URL del archivo en Google Sheets.`);
    } catch (error) {
      logger.error(`Error al actualizar la fila con pedido ${orderNumber} con la URL del archivo: ${error.message}`);
    }
  }

  processAddRowResult(result, sheet) {
    if (Array.isArray(result) && result.length > 0) {
      const firstRow = result[0];
      const rowIndex = firstRow.rowIndex || firstRow._rowNumber || sheet.rowCount;
      logger.info(`Fila a√±adida exitosamente. ID de la nueva fila: ${rowIndex}`);
      return { success: true, message: "Cotizaci√≥n guardada exitosamente", rowIndex: rowIndex };
    } else {
      logger.warn("No se pudo obtener informaci√≥n de la fila a√±adida");
      return { success: true, message: "Cotizaci√≥n guardada exitosamente, pero no se pudo obtener el ID de la fila" };
    }
  }

  async getNextOrderNumber() {
    try {
      await this.doc.loadInfo();
      const sheet = this.doc.sheetsByIndex[1]; // Hoja "Pedidos"
      await sheet.loadCells('A:A');
      
      let lastOrderNumber = 0;
      for (let i = sheet.rowCount - 1; i >= 2; i--) {
        const cell = sheet.getCell(i, 0);
        if (cell.value) {
          const match = cell.value.match(/WA-(\d+)/);
          if (match) {
            lastOrderNumber = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      const newOrderNumber = lastOrderNumber + 1;
      return `WA-${newOrderNumber}`;
    } catch (error) {
      logger.error("Error al generar n√∫mero de pedido:", error);
      throw new CustomError('OrderNumberGenerationError', 'Error al generar n√∫mero de pedido', error);
    }
  }

  censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) return phoneNumber;
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    return `${firstTwo}${'*'.repeat(middleLength)}${lastThree}`;
  }
}

export default new GoogleSheetService();


// services\whatsappService.js

// services/whatsappService.js

import { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot';
import { BaileysProvider } from '@builderbot/provider-baileys';
import config from '../config/config.js';
import logger from '../utils/logger.js';
import { CustomError } from '../utils/errorHandler.js';
import fs from 'fs/promises';
import path from 'path';

class WhatsAppService {
  constructor() {
    this.provider = null;
    this.bot = null;
  }

  async initialize(flows) {
    try {
      const adapterDB = new MemoryDB();
      const adapterFlow = createFlow(flows);
      const adapterProvider = createProvider(BaileysProvider, {
        groupsIgnore: true,
      });

      this.provider = adapterProvider;

      const { bot, httpServer } = await createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
      }, {
        queue: {
          timeout: 60000,
          concurrencyLimit: 100
        }
      });

      this.bot = bot;

      httpServer(config.port);
      logger.info(`Bot iniciado en el puerto ${config.port}`);
    } catch (error) {
      logger.error('Error al inicializar WhatsApp Service:', error);
      throw new CustomError('WhatsAppInitError', 'Error al inicializar el servicio de WhatsApp', error);
    }
  }

  async sendMessage(to, message, options = {}) {
    try {
      await this.bot.sendMessage(to, message, options);
      logger.info(`Mensaje enviado a ${to}`);
    } catch (error) {
      logger.error(`Error al enviar mensaje a ${to}:`, error);
      throw new CustomError('MessageSendError', 'Error al enviar mensaje de WhatsApp', error);
    }
  }

  async saveAudioFile(ctx) {
    try {
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo de audio');
      }
    } catch (error) {
      logger.error('Error al guardar archivo de audio:', error);
      throw new CustomError('AudioSaveError', 'Error al guardar archivo de audio', error);
    }
  }

  async saveFile(ctx) {
    try {
      if (!this.provider) {
        throw new Error('El proveedor de WhatsApp no est√° inicializado');
      }
      const savedFile = await this.provider.saveFile(ctx);
      if (typeof savedFile === 'string') {
        return savedFile;
      } else if (savedFile && savedFile.path) {
        return savedFile.path;
      } else {
        throw new Error('No se pudo obtener la ruta del archivo');
      }
    } catch (error) {
      logger.error('Error al guardar archivo:', error);
      throw new CustomError('FileSaveError', 'Error al guardar archivo', error);
    }
  }

  async processVoiceNote(ctx, audioPath) {
    try {
      logger.info(`Procesando nota de voz para usuario ${ctx.from}`);
      const transcription = await openaiService.transcribeAudio(audioPath);
      await fs.unlink(audioPath);
      logger.info(`Nota de voz procesada y archivo eliminado: ${audioPath}`);
      return transcription;
    } catch (error) {
      logger.error(`Error procesando nota de voz: ${error.message}`);
      throw new CustomError('VoiceNoteProcessError', 'Error al procesar nota de voz', error);
    }
  }

  getPromoMessage() {
    return `ü§ñ *¬°Gracias por probar nuestro Bot de Demostraci√≥n!* üöÄ
  
  Desarrollado con ‚ù§Ô∏è por *SuperPyme*
  
  üçΩÔ∏è *Ver Men√∫ y Pedidos:*
  https://docs.google.com/spreadsheets/d/1ZFq1c0IWbR3prkuZdnbJ_Och-GhxI9iMh56yqYlmAjo/edit?usp=sharing
  
  üîí _Nota: Los n√∫meros est√°n censurados para proteger la privacidad de nuestros usuarios de prueba._
  
  ‚ú® *¬øQuieres un bot as√≠ para tu negocio?* ‚ú®
  
  üì± Whatsapp: *+56 9 7147 1884*
  üìß Escr√≠benos: *oficina@superpyme.cl*
  üåê M√°s informaci√≥n: *superpyme.cl*
  
  üöÄ *¬°Lleva tu negocio al siguiente nivel con SuperPyme!* üíº
  
  PD: Puedes volver a probar el bot en 10 minutos, si quieres probarlo de inmediato, escribe desde otro n√∫mero.`;
  }
}

export default new WhatsAppService();


// utils\commandUtils.js

// utils/commandUtils.js

import logger from './logger.js';

const knownCommands = {
  'LIST_ALL_SERVICES': ['list all services', 'listallservices'],
  'SELECT_SERVICE': ['select service', 'selectservice'],
  'SET_MEASURES': ['set measures', 'setmeasures'],
  'SET_QUANTITY': ['set quantity', 'setquantity'],
  'SET_FINISHES': ['set finishes', 'setfinishes'],
  'CONFIRM_ORDER': ['confirm order', 'confirmorder'],
  'RESULT_ANALYSIS': ['result analysis', 'resultanalysis']
};

export function normalizeCommand(command) {
  return command.toLowerCase().replace(/\s+/g, '_');
}

export function findClosestCommand(command) {
  const normalizedCommand = normalizeCommand(command);
  
  // Primero, buscar una coincidencia exacta
  for (const [knownCommand, variations] of Object.entries(knownCommands)) {
    if (normalizedCommand === knownCommand.toLowerCase() || variations.includes(normalizedCommand)) {
      return knownCommand;
    }
  }
  
  // Si no hay coincidencia exacta, usar la distancia de Levenshtein
  let closestCommand = null;
  let minDistance = Infinity;
  
  for (const knownCommand of Object.keys(knownCommands)) {
    const distance = levenshteinDistance(normalizedCommand, knownCommand.toLowerCase());
    if (distance < minDistance) {
      minDistance = distance;
      closestCommand = knownCommand;
    }
  }
  
  // Solo devolver el comando m√°s cercano si la distancia es menor que un umbral
  return minDistance <= 3 ? closestCommand : null;
}

function levenshteinDistance(a, b) {
  const matrix = [];

  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }

  return matrix[b.length][a.length];
}

export function sanitizeJsonString(jsonString) {
  // Asegurar que las propiedades del JSON est√©n entre comillas dobles
  return jsonString.replace(/(\w+):/g, '"$1":');
}


// utils\errorHandler.js

import logger from './logger.js';

export class CustomError extends Error {
  constructor(name, message, originalError = null) {
    super(message);
    this.name = name;
    this.originalError = originalError;
  }
}

export const errorHandler = async (error, ctx, { flowDynamic, endFlow }) => {
  logger.error(`Error: ${error.name} - ${error.message}`);
  if (error.originalError) {
    logger.error(`Error original: ${error.originalError.message}`);
    logger.error(`Stack trace: ${error.originalError.stack}`);
  }

  let userMessage = 'Lo siento, ha ocurrido un error inesperado. Por favor, int√©ntalo de nuevo m√°s tarde.';

  switch (error.name) {
    case 'OpenAIError':
      userMessage = 'Estamos experimentando problemas con nuestro servicio de IA. Por favor, int√©ntalo de nuevo en unos minutos.';
      break;
    case 'SheetServiceError':
      userMessage = 'Hay un problema temporal con nuestro sistema de pedidos. Por favor, int√©ntalo de nuevo m√°s tarde.';
      break;
    case 'WhatsAppError':
      userMessage = 'Estamos teniendo dificultades para procesar tu mensaje. Por favor, int√©ntalo de nuevo.';
      break;
    case 'MiddlewareError':
      userMessage = 'Ha ocurrido un error al procesar tu solicitud. Por favor, int√©ntalo de nuevo.';
      break;
  }

  await flowDynamic(userMessage);
  return endFlow();
};


// utils\helpers.js

// utils/helpers.js

export function formatPrice(price) {
  const formattedPrice = price.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ".");
  return formattedPrice;
}
  
  export function censorPhoneNumber(phoneNumber) {
    if (phoneNumber.length <= 5) {
      return phoneNumber;
    }
    const firstTwo = phoneNumber.slice(0, 2);
    const lastThree = phoneNumber.slice(-3);
    const middleLength = phoneNumber.length - 5;
    const censoredMiddle = '*'.repeat(middleLength);
    return `${firstTwo}${censoredMiddle}${lastThree}`;
  }


  // Nueva funci√≥n para enviar mensajes divididos
export async function sendSplitMessages(flowDynamic, aiResponse) {
  // Filtrar el comando JSON inicial
  const filteredResponse = aiResponse.replace(/^\s*\{.*?\}\s*/, '').trim();

  // Dividir la respuesta en secciones basadas en los encabezados "### "
  const sections = filteredResponse.split(/(?=### )/).map(s => s.trim()).filter(s => s);

  for (const section of sections) {
    await flowDynamic(section);
    // Espera de 3 segundos antes de enviar el siguiente mensaje
    await new Promise(resolve => setTimeout(resolve, 3000));
  }
}


// utils\logger.js

import winston from 'winston';
import config from '../config/config.js';
import moment from 'moment-timezone';

const { combine, timestamp, printf } = winston.format;

const myFormat = printf(({ level, message, timestamp }) => {
  const formattedTimestamp = moment(timestamp).tz('America/Santiago').format('DD-MM-YY - HH:mm:ss a');
  return `${formattedTimestamp} : [${level.toUpperCase()}] ${message}`;
});

const logger = winston.createLogger({
  level: config.logLevel || 'info',
  format: combine(
    timestamp(),
    myFormat
  ),
  defaultMeta: { service: 'chatbot-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: myFormat,
  }));
}

export default logger;


